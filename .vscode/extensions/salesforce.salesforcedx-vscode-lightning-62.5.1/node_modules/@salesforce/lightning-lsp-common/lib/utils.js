"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeJsonSync = exports.readJsonSync = exports.memoize = exports.elapsedMillis = exports.deepMerge = exports.appendLineIfMissing = exports.getCoreResource = exports.getSfdxResource = exports.getResourcePath = exports.getBasename = exports.getExtension = exports.pathStartsWith = exports.relativePath = exports.unixify = exports.isAuraRootDirectoryCreated = exports.isLWCRootDirectoryCreated = exports.containsDeletedLwcWatchedDirectory = exports.includesDeletedAuraWatchedDirectory = exports.includesDeletedLwcWatchedDirectory = exports.isAuraWatchedDirectory = exports.isLWCWatchedDirectory = exports.toResolvedPath = exports.glob = void 0;
const fs = __importStar(require("fs-extra"));
const path_1 = require("path");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const deep_equal_1 = __importDefault(require("deep-equal"));
const shared_1 = require("./shared");
const util_1 = require("util");
const glob_1 = require("glob");
const jsonc = __importStar(require("jsonc-parser"));
exports.glob = (0, util_1.promisify)(glob_1.Glob);
const RESOURCES_DIR = 'resources';
async function fileContainsLine(file, expectLine) {
    const trimmed = expectLine.trim();
    for (const line of (await fs.readFile(file, 'utf8')).split('\n')) {
        if (line.trim() === trimmed) {
            return true;
        }
    }
    return false;
}
function toResolvedPath(uri) {
    return (0, path_1.resolve)(vscode_uri_1.URI.parse(uri).fsPath);
}
exports.toResolvedPath = toResolvedPath;
function isLWCRootDirectory(context, uri) {
    if (context.type === shared_1.WorkspaceType.SFDX) {
        const file = toResolvedPath(uri);
        return file.endsWith('lwc');
    }
    return false;
}
function isAuraDirectory(context, uri) {
    if (context.type === shared_1.WorkspaceType.SFDX) {
        const file = toResolvedPath(uri);
        return file.endsWith('aura');
    }
    return false;
}
async function isLWCWatchedDirectory(context, uri) {
    const file = toResolvedPath(uri);
    return await context.isFileInsideModulesRoots(file);
}
exports.isLWCWatchedDirectory = isLWCWatchedDirectory;
async function isAuraWatchedDirectory(context, uri) {
    const file = toResolvedPath(uri);
    return await context.isFileInsideAuraRoots(file);
}
exports.isAuraWatchedDirectory = isAuraWatchedDirectory;
/**
 * @return true if changes include a directory delete
 */
// TODO This is not waiting for the response of the promise isLWCWatchedDirectory, maybe we have the same problem on includesDeletedAuraWatchedDirectory
async function includesDeletedLwcWatchedDirectory(context, changes) {
    for (const event of changes) {
        if (event.type === vscode_languageserver_1.FileChangeType.Deleted && event.uri.indexOf('.') === -1 && (await isLWCWatchedDirectory(context, event.uri))) {
            return true;
        }
    }
    return false;
}
exports.includesDeletedLwcWatchedDirectory = includesDeletedLwcWatchedDirectory;
async function includesDeletedAuraWatchedDirectory(context, changes) {
    for (const event of changes) {
        if (event.type === vscode_languageserver_1.FileChangeType.Deleted && event.uri.indexOf('.') === -1 && (await isAuraWatchedDirectory(context, event.uri))) {
            return true;
        }
    }
    return false;
}
exports.includesDeletedAuraWatchedDirectory = includesDeletedAuraWatchedDirectory;
async function containsDeletedLwcWatchedDirectory(context, changes) {
    for (const event of changes) {
        const insideLwcWatchedDirectory = await isLWCWatchedDirectory(context, event.uri);
        if (event.type === vscode_languageserver_1.FileChangeType.Deleted && insideLwcWatchedDirectory) {
            const { dir, name, ext } = (0, path_1.parse)(event.uri);
            const folder = (0, path_1.basename)(dir);
            const parentFolder = (0, path_1.basename)((0, path_1.dirname)(dir));
            if (
            // LWC component
            (/.*(.ts|.js)$/.test(ext) && folder === name && parentFolder === 'lwc') ||
                // Folder deletion, subdirectory of lwc or lwc directory itself
                // When there is no extension the name is the folder name and 
                // folder becomes the parent folder
                // ex: /path/to/some/dir, name => dir, folder => some
                (!ext && (folder === 'lwc' || name === 'lwc'))) {
                return true;
            }
        }
    }
    return false;
}
exports.containsDeletedLwcWatchedDirectory = containsDeletedLwcWatchedDirectory;
function isLWCRootDirectoryCreated(context, changes) {
    for (const event of changes) {
        if (event.type === vscode_languageserver_1.FileChangeType.Created && isLWCRootDirectory(context, event.uri)) {
            return true;
        }
    }
    return false;
}
exports.isLWCRootDirectoryCreated = isLWCRootDirectoryCreated;
function isAuraRootDirectoryCreated(context, changes) {
    for (const event of changes) {
        if (event.type === vscode_languageserver_1.FileChangeType.Created && isAuraDirectory(context, event.uri)) {
            return true;
        }
    }
    return false;
}
exports.isAuraRootDirectoryCreated = isAuraRootDirectoryCreated;
function unixify(filePath) {
    return filePath.replace(/\\/g, '/');
}
exports.unixify = unixify;
function relativePath(from, to) {
    return unixify((0, path_1.relative)(from, to));
}
exports.relativePath = relativePath;
function pathStartsWith(path, root) {
    if (process.platform === 'win32') {
        return path.toLowerCase().startsWith(root.toLowerCase());
    }
    return path.startsWith(root);
}
exports.pathStartsWith = pathStartsWith;
function getExtension(textDocument) {
    const filePath = vscode_uri_1.URI.parse(textDocument.uri).fsPath;
    return filePath ? (0, path_1.extname)(filePath) : '';
}
exports.getExtension = getExtension;
function getBasename(textDocument) {
    const filePath = vscode_uri_1.URI.parse(textDocument.uri).fsPath;
    const ext = (0, path_1.extname)(filePath);
    return filePath ? (0, path_1.basename)(filePath, ext) : '';
}
exports.getBasename = getBasename;
function getResourcePath(resourceName) {
    return (0, path_1.join)(__dirname, RESOURCES_DIR, resourceName);
}
exports.getResourcePath = getResourcePath;
function getSfdxResource(resourceName) {
    return (0, path_1.join)(__dirname, RESOURCES_DIR, 'sfdx', resourceName);
}
exports.getSfdxResource = getSfdxResource;
function getCoreResource(resourceName) {
    return (0, path_1.join)(__dirname, RESOURCES_DIR, 'core', resourceName);
}
exports.getCoreResource = getCoreResource;
async function appendLineIfMissing(file, line) {
    if (!(await fs.pathExists(file))) {
        return fs.writeFile(file, line + '\n');
    }
    else if (!(await fileContainsLine(file, line))) {
        return fs.appendFile(file, '\n' + line + '\n');
    }
}
exports.appendLineIfMissing = appendLineIfMissing;
/**
 * Deep merges the 'from' object into the 'to' object
 * (assumes simple JSON config objects)
 * @return true if the 'to' object was modified, false otherwise
 */
function deepMerge(to, from) {
    let modified = false;
    for (const key of Object.keys(from)) {
        const fromVal = from[key];
        const toVal = to.hasOwnProperty(key) ? to[key] : undefined;
        if (!to.hasOwnProperty(key)) {
            // if 'to' doesn't have the property just assign the 'from' one
            to[key] = fromVal;
            modified = true;
        }
        else if (Array.isArray(fromVal)) {
            // assign 'from' array values to the 'to' array (create array if 'to' is a scalar)
            const toArray = Array.isArray(toVal) ? toVal : (to[key] = [toVal]);
            for (const e of fromVal) {
                if (!toArray.some(value => (0, deep_equal_1.default)(value, e))) {
                    toArray.push(e);
                    modified = true;
                }
            }
        }
        else if (Array.isArray(toVal)) {
            // if 'to' is array and 'from' scalar, push 'from' to the array
            if (!toVal.includes(fromVal)) {
                toVal.push(fromVal);
                modified = true;
            }
        }
        else if (fromVal !== null && typeof fromVal === 'object') {
            // merge object values
            if (deepMerge(toVal, fromVal)) {
                modified = true;
            }
        }
        // do not overwrite existing values
    }
    return modified;
}
exports.deepMerge = deepMerge;
/**
 * @return string showing elapsed milliseconds from start mark
 */
function elapsedMillis(start) {
    const elapsed = process.hrtime(start);
    return (elapsed[0] * 1000 + elapsed[1] / 1e6).toFixed(2) + ' ms';
}
exports.elapsedMillis = elapsedMillis;
const memoize = (fn) => {
    let cache;
    return () => {
        if (cache) {
            return cache;
        }
        cache = fn.apply(this);
        return cache;
    };
};
exports.memoize = memoize;
function readJsonSync(file) {
    const exists = fs.pathExistsSync(file);
    try {
        // jsonc.parse will return an object without comments.
        // Comments will be lost if this object is written back to file.
        // Individual properties should be updated directly via VS Code API to preserve comments.
        return exists ? jsonc.parse(fs.readFileSync(file, 'utf8')) : {};
    }
    catch (err) {
        console.log(`onIndexCustomComponents(LOTS): Error reading jsconfig ${file}`, err);
    }
}
exports.readJsonSync = readJsonSync;
function writeJsonSync(file, json) {
    fs.writeJSONSync(file, json, {
        spaces: 4,
    });
}
exports.writeJsonSync = writeJsonSync;
//# sourceMappingURL=utils.js.map
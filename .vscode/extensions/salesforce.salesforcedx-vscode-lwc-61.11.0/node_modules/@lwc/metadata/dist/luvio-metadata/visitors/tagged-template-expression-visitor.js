'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var t = require('@babel/types');
var node_crypto = require('node:crypto');
var utils = require('../../script-metadata/utils.js');

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);

const GQL_MODULE_SPECIFIER = 'lightning/uiGraphQLApi';
const GQL_IMPORT_IDENTIFIER = 'gql';
function isValidGQLTagImport(path) {
    const { tag } = path.node;
    if (!t__namespace.isIdentifier(tag)) {
        return false;
    }
    const gql = path.scope.getBinding(tag.name);
    if (gql && gql.path.isImportSpecifier()) {
        const { node } = gql.path.parentPath;
        if (t__namespace.isImportDeclaration(node) && node.source.value === GQL_MODULE_SPECIFIER) {
            const { imported } = gql.path.node;
            return (t__namespace.isIdentifier(imported) &&
                imported.name === GQL_IMPORT_IDENTIFIER);
        }
    }
    return false;
}
function visitorFunction({ gqlTag }) {
    return function TaggedTemplateExpressionVisitorFunction(path) {
        // early-exit for all tags other than `gql`
        // and `gql` imports other than lightning module specifier
        if (!isValidGQLTagImport(path)) {
            return;
        }
        const { quasi, quasi: { quasis }, } = path.node;
        // metadata
        const query = quasis.reduce((previousValue, { value: { raw } }) => `${previousValue}${raw}`, '');
        // a non-exhaustive list of expressions might have these
        // 1. Identifier
        // 2. ArrowFunctionExpression
        // 3. FunctionExpression
        // 4. CallExpression
        // 5. ConditionalExpression
        // 6. ??
        // we just gather if expressions exists in the query
        // and generate a unique token for the query omitted off expressions
        gqlTag.push({
            hash: node_crypto.createHash('md5').update(query, 'utf8').digest('hex'),
            hasExpressions: quasis.length > 1,
            location: utils.generateSourceLocation(quasi),
        });
    };
}

exports.default = visitorFunction;
//# sourceMappingURL=tagged-template-expression-visitor.js.map

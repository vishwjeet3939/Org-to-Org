'use strict';

var path = require('node:path');
var index$2 = require('./template-metadata/index.js');
var index$1 = require('./script-metadata/index.js');
var index = require('./style-metadata/index.js');

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespaceCompat(path);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function resolveEntryFile(bundleName, files) {
    let entryFileName;
    for (const { fileName } of files) {
        const parsedPath = path__namespace.parse(fileName);
        // If file name matches bundle name
        // NOTE: the directory is already validated in validateBundleConfig()
        if (parsedPath.name === bundleName) {
            if (parsedPath.ext === '.css') {
                // If a js entry file has not been discovered yet, could be a css only module
                entryFileName = fileName;
            }
            else if (parsedPath.ext === '.js' || parsedPath.ext === '.ts') {
                // If a js entry file is found, exit early
                return fileName;
            }
        }
    }
    return entryFileName;
}
function rollupDiagnostics(files) {
    return files.flatMap((file) => {
        const diagnostics = file.diagnostics;
        // Reset the diagnostic for individual files to avoid duplicating them at the bundle
        // level and file level
        file.diagnostics = [];
        return diagnostics;
    });
}
/* function validateBundleConfig(config: BundleConfig): void {
    const { files, namespace, name: bundleName } = config;

    // 1. Verify that every fileName has "<namespace>/<bundlename>" as the directory
    const expectedDirectoryName = namespace + '/' + bundleName;
    const violatingFiles = files
        .filter(({ fileName }) => {
            const parsedPath = path.parse(fileName);
            return !parsedPath.dir.startsWith(expectedDirectoryName);
        })
        .map(({ fileName }) => fileName);
    if (violatingFiles.length) {
        throw new Error(
            `Invalid fileName provided in BundleConfig. Expected format "namespace/bundleName/filename.ext". Offending file names: \n${violatingFiles.join(
                '\n'
            )}`
        );
    }
} */
const version = '2.50.0-0';
function collectBundleMetadata(config) {
    // validateBundleConfig(config);
    const { namespace, name, type, namespaceMapping, files, enableKomaci, strictCSSTokenCollection, enableLuvio, experimentalComplexExpressions, } = config;
    const filesResult = [];
    files.forEach(({ fileName, source }) => {
        const ext = path__namespace.extname(fileName);
        switch (ext) {
            case '.html':
                filesResult.push(index$2.collectTemplateMetadataFromSource(fileName, source, {
                    namespaceMapping,
                    enableKomaci,
                    experimentalComplexExpressions,
                }));
                break;
            case '.js':
            case '.ts':
                // collect metadata for all js files and internal ts files
                if (ext === '.js' || type === 'internal') {
                    filesResult.push(index$1.collectScriptMetadataFromSource(fileName, source, {
                        namespaceMapping,
                        bundleType: type,
                        enableKomaci,
                        enableLuvio,
                    }));
                }
                break;
            case '.css':
                filesResult.push(index.collectCssMetadataFromSource(fileName, source, {
                    namespaceMapping,
                    strictCSSTokenCollection,
                }));
                break;
        }
    });
    const entryFileName = resolveEntryFile(name, files);
    const diagnostics = [];
    diagnostics.push(...rollupDiagnostics(filesResult));
    return {
        version,
        moduleSpecifier: `${namespace}/${name}`,
        name,
        namespace,
        files: filesResult,
        entryFileName,
        diagnostics,
    };
}

exports.collectBundleMetadata = collectBundleMetadata;
//# sourceMappingURL=bundle-metadata.js.map

import { ID } from '../schema/typescript-types/script-metadata-types';
import { BundleType, NamespaceMapping } from './config';
/**
 * Returns true if the value is null
 * @param {any} o
 */
export declare function isNull(o: any): o is null;
/**
 * Returns true if the value is undefined
 * @param {any} o
 */
export declare function isUndefined(o: any): o is undefined;
/**
 * Returns true if value is true
 * @param {any} o
 */
export declare function isTrue(o: any): o is true;
/**
 * Returns false if value is false
 * @param {any} o
 */
export declare function isFalse(o: any): o is false;
/**
 * Returns true if
 *  the value is an array and length is zero or
 *  the value is a string and the trimmed value is an empty string
 * @param {string | Array<any>} o
 */
export declare function isEmpty(o: string | Array<any>): boolean;
/**
 * Returns true if
 *  the value is truthy and has no enumerable keys
 * @param {object} o
 */
export declare function isEmptyObject(o: object): boolean;
/**
 * Generate a unique reference id for a reference object
 * @param refType Reference type
 * @param idx unique numerical identifier to be appended to the end of the generated id
 * @param name name of the reference
 */
export declare function generateReferenceId(refType: string, idx: number, name?: string): ID;
export declare class State {
    private idx;
    fileName: string;
    namespaceMapping: NamespaceMapping;
    bundleType: BundleType;
    constructor({ fileName, namespaceMapping, bundleType, }: {
        fileName: string;
        namespaceMapping: NamespaceMapping;
        bundleType: BundleType;
    });
    generateReferenceId(refType: string, name?: string): ID;
}
export declare function tagNameToComponentName(name: string): string;
export declare function attributeNameToPropertyName(name: string): string;
declare const assign: {
    <T extends {}, U>(target: T, source: U): T & U;
    <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V;
    <T_2 extends {}, U_2, V_1, W>(target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W;
    (target: object, ...sources: any[]): any;
}, keys: {
    (o: object): string[];
    (o: {}): string[];
}, hasOwnProperty: (v: PropertyKey) => boolean;
export { assign, keys, hasOwnProperty };

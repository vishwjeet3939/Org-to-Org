'use strict';

var utils$1 = require('../script-metadata/utils.js');
var utils = require('../shared/utils.js');

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
// Convert metadata of an LWC script file into a Komaci Document.
function generateKomaciDocFromScript(scriptFile, scriptState) {
    const komaciDoc = {};
    const analyzerContext = {
        komaciDoc,
        defaultBindingsMap: {},
        exportedNamesMap: {},
        exportedWithoutLocalNames: {},
        importIndexes: {},
        adgNameIndexMap: {},
        aliasToLocalMap: {},
        namespaceImports: [],
    };
    gatherBindingNames(analyzerContext, scriptFile);
    gatherExportedNames(analyzerContext, scriptFile);
    processClasses(analyzerContext, scriptFile);
    processClassExtends(analyzerContext, scriptFile, scriptState);
    return komaciDoc;
}
// Construct defaultBindingsMap & aliasToLocalMap on AnalyzerContext
function gatherBindingNames(analyzerContext, scriptFile) {
    const defaultBindingsMap = analyzerContext.defaultBindingsMap;
    scriptFile.imports.forEach((importMetadata) => {
        if (importMetadata.defaultBinding) {
            let moduleDefaultBindingNames = defaultBindingsMap[importMetadata.moduleSpecifier];
            if (!moduleDefaultBindingNames) {
                moduleDefaultBindingNames = [];
                defaultBindingsMap[importMetadata.moduleSpecifier] = moduleDefaultBindingNames;
            }
            moduleDefaultBindingNames.push(importMetadata.defaultBinding.name);
        }
        if (importMetadata.namedImports) {
            importMetadata.namedImports.forEach((namedImport) => {
                if (namedImport.aliasName) {
                    analyzerContext.aliasToLocalMap[namedImport.aliasName] = namedImport.name;
                }
            });
        }
        if (importMetadata.namespaceImport) {
            analyzerContext.namespaceImports.push(importMetadata.moduleSpecifier);
        }
    });
}
// Construct mapping of the localName of named exports to their corresponding exported names.
function gatherExportedNames(analyzerContext, scriptFile) {
    const exportedNamesMap = analyzerContext.exportedNamesMap;
    const exportedWithoutLocalNames = analyzerContext.exportedWithoutLocalNames;
    scriptFile.exports.forEach((exportMetadata) => {
        if (exportMetadata.namedExports) {
            exportMetadata.namedExports.forEach((namedExport) => {
                const localName = namedExport.localName;
                if (localName) {
                    const exportedNames = utils.hasOwnProperty.call(exportedNamesMap, localName) &&
                        exportedNamesMap[localName];
                    if (!exportedNames) {
                        exportedNamesMap[localName] = [namedExport.exportedName];
                    }
                    else {
                        exportedNames.push(namedExport.exportedName);
                    }
                }
                else {
                    exportedWithoutLocalNames[namedExport.exportedName] = true;
                }
            });
        }
    });
}
// Cycle metadata for LWC classes to convert component classes to Komaci ADGs.
function processClasses(analyzerContext, scriptFile) {
    const komaciDoc = analyzerContext.komaciDoc;
    scriptFile.classes.forEach((classMetadata) => {
        if (classMetadata.extends) {
            const adg = {};
            if (!komaciDoc.adgs) {
                komaciDoc.adgs = [];
            }
            komaciDoc.adgs.push(adg);
            const adgIdx = komaciDoc.adgs.length - 1;
            // Unnamed class can not be referenced from the same module
            if (classMetadata.name)
                analyzerContext.adgNameIndexMap[classMetadata.name] = adgIdx;
            processClassProperties(analyzerContext, adg, classMetadata);
            processClassMethods(analyzerContext, adg, classMetadata);
            // Contribute exports to the KomaciDoc based on the exported names for this class.
            const exportedNames = getExportedNames(analyzerContext, scriptFile, classMetadata);
            exportedNames?.forEach((name) => {
                if (!komaciDoc.exports) {
                    komaciDoc.exports = {};
                }
                komaciDoc.exports[name] = {
                    type: 'AdgReference',
                    value: adgIdx,
                };
            });
        }
    });
}
/**
 * Add ParentClass property to ADG if it does not direclty extend from LightningElement.
 * @param analyzerContext
 * @param scriptFile
 */
function processClassExtends(analyzerContext, scriptFile, scriptState) {
    const komaciDoc = analyzerContext.komaciDoc;
    scriptFile.classes.forEach((classMetadata) => {
        // LightningElement does not need to be added explicitly as parentClass
        if (!classMetadata.isComponentClass &&
            classMetadata.extends &&
            classMetadata.name &&
            komaciDoc.adgs) {
            const adgIdx = analyzerContext.adgNameIndexMap[classMetadata.name];
            const adg = komaciDoc.adgs[adgIdx];
            const parentClass = classMetadata.extends;
            let ref;
            if (parentClass !== 'unresolved' &&
                'moduleSpecifier' in parentClass &&
                isValidKomaciModuleName(parentClass.moduleSpecifier)) {
                // imports reference
                const localNameForParentClass = analyzerContext.aliasToLocalMap[parentClass.name];
                const parentClassName = localNameForParentClass
                    ? localNameForParentClass
                    : parentClass.name;
                ref = getImportReference(analyzerContext, parentClass.moduleSpecifier, parentClassName, { useKomaciModuleName: true }, parentClass.location);
            }
            else if (parentClass !== 'unresolved' &&
                !('moduleSpecifier' in parentClass) &&
                parentClass.name != undefined) {
                // do not add adg.parentClass
                if (analyzerContext.adgNameIndexMap[parentClass.name] === undefined) {
                    return;
                }
                // reference another adg in the same komaci doc
                ref = {
                    type: 'AdgReference',
                    value: analyzerContext.adgNameIndexMap[parentClass.name],
                    location: parentClass.location,
                };
            }
            else {
                // generate location from script state in unresolvable case
                const classNodePath = scriptState.classNodeLookup.get(classMetadata);
                if (classNodePath) {
                    const location = utils$1.generateSourceLocation(classNodePath.parentPath.node);
                    ref = getUnresolvedValue(location);
                }
                else {
                    ref = getUnresolvedValue();
                }
            }
            adg.parentClass = ref;
        }
    });
}
// Cycle properties on the LWC class metadata and contribute Komaci
// properties to its provided Adg.
function processClassProperties(analyzerContext, adg, classMetadata) {
    if (classMetadata.properties.length === 0) {
        return;
    }
    const properties = {};
    adg.properties = properties;
    classMetadata.properties.forEach((propertyMetadata) => {
        if (propertyMetadata.dataProperty) {
            const property = {
                isPublic: propertyMetadata.decorators.some(isApiDecorator),
            };
            properties[propertyMetadata.name] = property;
            const initialValue = getStaticValue(analyzerContext, propertyMetadata.dataProperty.initialValue);
            // Omit primitive undefined, as that is the default.
            if (initialValue.value !== undefined) {
                property.initial = initialValue;
            }
            // If property is wired, then process the wire's metadata.
            const wireDecorator = propertyMetadata.decorators.find(isWireDecorator);
            if (wireDecorator) {
                const wireFunction = processWireFunction(analyzerContext, wireDecorator);
                if (!adg.functions) {
                    adg.functions = [];
                }
                adg.functions.push(wireFunction);
                const functionIdx = adg.functions.length - 1;
                // Link the created function as input to this property.
                property.input = {
                    type: 'FunctionReference',
                    value: functionIdx,
                };
            }
        }
        else if (propertyMetadata.getter) {
            const property = {
                isPublic: propertyMetadata.decorators.some(isApiDecorator),
                // Komaci sets the hardcoded getters value as the input to this prop
                input: getStaticValue(analyzerContext, propertyMetadata.getter.initialValue),
            };
            properties[propertyMetadata.name] = property;
        }
    });
}
// Convert LWC wire metadata to Komaci WireFunction.
function processWireFunction(analyzerContext, wireMetadata) {
    let wireReference;
    if (wireMetadata.adapterModule === 'unresolved') {
        wireReference = getUnresolvedValue();
    }
    else {
        wireReference = getImportReference(analyzerContext, wireMetadata.adapterModule, wireMetadata.adapterId.importedName, { useKomaciModuleName: false });
    }
    // Construct input into the function based on the config metadata.
    const adapterLoc = wireMetadata.adapterId.location;
    const functionInput = [];
    const wireFunction = {
        type: 'WireFunction',
        reference: wireReference,
        input: functionInput,
        location: {
            startLine: wireMetadata.location.startLine,
            startColumn: wireMetadata.location.startColumn,
            endLine: wireMetadata.location.endLine,
            endColumn: wireMetadata.location.endColumn,
        },
        adapterLocation: {
            startLine: adapterLoc.startLine,
            startColumn: adapterLoc.startColumn,
            endLine: adapterLoc.endLine,
            endColumn: adapterLoc.endColumn,
        },
    };
    if (wireMetadata.adapterConfig) {
        const wireConfig = {};
        functionInput.push({
            type: 'ObjectValue',
            value: wireConfig,
        });
        const propLocs = {};
        // Configuration where value is a static.
        for (const propName of Object.keys(wireMetadata.adapterConfig.static)) {
            wireConfig[propName] = getStaticValue(analyzerContext, wireMetadata.adapterConfig.static[propName].value);
            const loc = wireMetadata.adapterConfig.static[propName].keyLocation;
            propLocs[propName] = {
                startLine: loc.startLine,
                startColumn: loc.startColumn,
                endLine: loc.endLine,
                endColumn: loc.endColumn,
            };
        }
        // Config prefixed with $ to reference a property on the component instance.
        for (const propName of Object.keys(wireMetadata.adapterConfig.reactive)) {
            wireConfig[propName] = getPropertyReference(wireMetadata.adapterConfig.reactive[propName].classProperty);
            const loc = wireMetadata.adapterConfig.reactive[propName].keyLocation;
            propLocs[propName] = {
                startLine: loc.startLine,
                startColumn: loc.startColumn,
                endLine: loc.endLine,
                endColumn: loc.endColumn,
            };
        }
        wireFunction.adapterConfigLocations = propLocs;
    }
    return wireFunction;
}
// Identify class methods which are decorated as wires. These will become
// functions in Komaci ADG which are not associated with a property.
function processClassMethods(analyzerContext, adg, classMetadata) {
    classMetadata.methods.forEach((methodMetadata) => {
        const wireDecorator = methodMetadata.decorators.find(isWireDecorator);
        if (wireDecorator) {
            const wireFunction = processWireFunction(analyzerContext, wireDecorator);
            if (!adg.functions) {
                adg.functions = [];
            }
            adg.functions.push(wireFunction);
        }
    });
}
/**
 * Search for existing Komaci Import, dynamically create them as needed.
 *
 * @param komaciDoc
 * @param moduleSpecifier Name of module containing the exported binding.
 * @param importedName Name of binding exported from the module.
 * @param useKomaciModuleName Boolean value, describing the import is komaci module.
 * @returns Reference to import (e.g. 0/names/0).
 */
function getImportReference(analyzerContext, moduleSpecifier, importedName, options, location) {
    const { komaciDoc, defaultBindingsMap, importIndexes, namespaceImports } = analyzerContext;
    let namespacedMember;
    if (!komaciDoc.imports) {
        komaciDoc.imports = [];
    }
    // See if the importedName is a default binding from the specified module.
    if (defaultBindingsMap[moduleSpecifier]?.includes(importedName)) {
        // If yes, Komaci will use "default" as the name.
        importedName = 'default';
    }
    // if the imported module is namespace import, collect member name and update importName to '*'
    if (namespaceImports.includes(moduleSpecifier)) {
        namespacedMember = importedName === '*' ? undefined : importedName;
        importedName = '*';
    }
    // Use index info for the specified module to construct ImportReference.
    const resourceName = options.useKomaciModuleName
        ? getKomaciModuleName(moduleSpecifier)
        : moduleSpecifier;
    const indexInfo = importIndexes[resourceName];
    let value;
    if (indexInfo) {
        // KomaciDoc has an import for this module.
        const moduleImportIndex = indexInfo.moduleIndex;
        let importedNameIndex = indexInfo.names[importedName];
        if (importedNameIndex === undefined) {
            // Komaci Import exist but names doesn't contain the importedName.
            const komaciImport = komaciDoc.imports[moduleImportIndex];
            komaciImport.names.push(importedName);
            // Record the index info of the imported name.
            importedNameIndex = komaciImport.names.length - 1;
            indexInfo.names[importedName] = importedNameIndex;
        }
        value = `${moduleImportIndex}/names/${importedNameIndex}`;
    }
    else {
        // KomaciDoc has no imports for this module.
        komaciDoc.imports.push({
            resourceName,
            names: [importedName],
        });
        const moduleImportIndex = komaciDoc.imports.length - 1;
        // Record the index of the module and imported name.
        importIndexes[resourceName] = {
            moduleIndex: moduleImportIndex,
            names: {
                [importedName]: 0,
            },
        };
        value = `${moduleImportIndex}/names/0`;
    }
    const ref = {
        type: 'ImportReference',
        value: value,
    };
    if (location)
        ref.location = location;
    if (namespacedMember)
        ref.namespacedMember = namespacedMember;
    return ref;
}
/**
 * Convert moduleSpecifier to Komaci Module Name
 *
 * @param moduleSpecifier Name of module being imported (e.g c/foo).
 * @returns Reference of the komaci module to import (e.g.: salesforce/komaci/c__foo__foo.js).
 */
function getKomaciModuleName(moduleSpecifier) {
    // Construct komaciModuleName of the import.
    const [namespace, name] = moduleSpecifier.split('/');
    return `@salesforce/komaci/${namespace}__${name}__${name}.js`;
}
/**
 * Validate if a komaci module reference can be obtained from the provided moduleSpecifier.
 *
 * @param moduleSpecifier Name of module being imported (e.g c/foo).
 * @returns A boolean value.
 */
function isValidKomaciModuleName(moduleSpecifier) {
    return moduleSpecifier.split('/').length === 2;
}
// Coverts LWC Value into Komaci StaticValue.
function getStaticValue(analyzerContext, value) {
    switch (value.type) {
        case 'Number':
        case 'String':
        case 'Boolean':
        case 'Null':
        case 'Undefined':
            return {
                type: 'PrimitiveValue',
                value: value.value,
            };
        case 'Array':
            return {
                type: 'ArrayValue',
                value: value.value.map((val) => getStaticValue(analyzerContext, val)),
            };
        case 'Object': {
            const object = {};
            for (const [k, v] of Object.entries(value.value)) {
                object[k] = getStaticValue(analyzerContext, v);
            }
            return {
                type: 'ObjectValue',
                value: object,
            };
        }
        case 'ImportedValue': {
            const importRef = getImportReference(analyzerContext, value.moduleSpecifier, value.importedName, { useKomaciModuleName: false });
            return importRef;
        }
        case 'Unresolved':
        default:
            return getUnresolvedValue();
    }
}
// Given a class determine the name(s) its Adg should be exported under.
// Classes that are not exported, would return 'undefined'.
function getExportedNames(analyzerContext, scriptFile, classMetadata) {
    const className = classMetadata.name;
    if (!className) {
        // TODO: Revisit when anonymous classes appear in metadata (W-8789710)
        return [];
    }
    const exportedNames = analyzerContext.exportedNamesMap[className];
    const exportedWithoutLocalNames = analyzerContext.exportedWithoutLocalNames[className];
    const isMainClass = scriptFile.mainClass?.refId === classMetadata.id;
    if (exportedNames) {
        // The class is exported under different name(s).
        if (isMainClass) {
            // If it's also the main class, then export as 'default' as well.
            return ['default', ...exportedNames];
        }
        return exportedNames;
    }
    else if (exportedWithoutLocalNames) {
        // The class is exported without different local name.
        return [className];
    }
    else if (isMainClass) {
        return ['default'];
    }
}
// Convert LWC reactive property reference into Komaci property ref.
function getPropertyReference(reactiveValue) {
    // This regex will match . or ?. used for optional chaining.
    const parts = reactiveValue.split(/\??\./);
    return {
        type: 'PropertyReference',
        value: parts.join('/'),
    };
}
// Reference to non-analyzable data (e.g. private properties/functions).
// These are intionally preserved in the Komaci Documents generated
// at this level of the framework.
function getUnresolvedValue(location) {
    const unresolved = {
        type: 'Unresolved',
        value: '',
    };
    if (location)
        unresolved.location = location;
    return unresolved;
}
function isApiDecorator(d) {
    return d.type === 'Api';
}
function isWireDecorator(d) {
    return d.type === 'Wire';
}

exports.generateKomaciDocFromScript = generateKomaciDocFromScript;
//# sourceMappingURL=analyzeScriptFile.js.map

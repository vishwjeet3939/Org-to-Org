'use strict';

var utils = require('../shared/utils.js');

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
// Convert LWC metadata of an HTML template file into a Komaci Document.
function generateKomaciDocFromTemplate(htmlFile) {
    const komaciRoot = {
        type: 'Container',
    };
    const komaciDoc = {
        compositions: [komaciRoot],
        exports: {
            default: {
                type: 'CompositionReference',
                value: 0,
            },
        },
    };
    // Recursively walk AST to construct full Komaci composition.
    const astRoot = htmlFile.ast;
    if (astRoot) {
        const analyzerContext = {
            komaciDoc: komaciDoc,
            componentToImportMapping: {},
            iterationContext: [],
        };
        processChildren(analyzerContext, astRoot, komaciRoot);
    }
    return komaciDoc;
}
// Recurse into the children of the provided node.
function processChildren(analyzerContext, astParentNode, komaciParentNode) {
    const compositions = [];
    astParentNode.children.forEach((astChildNode) => {
        const komaciChildNode = astNodeToKomaciNode(analyzerContext, astChildNode);
        if (komaciChildNode) {
            let isRelevantChild = true;
            if (komaciChildNode.type === 'Container') {
                // TODO: Improve typings to avoid the type guard here.
                const komaciContainer = komaciChildNode;
                isRelevantChild =
                    komaciContainer.slot !== undefined ||
                        komaciContainer.key !== undefined ||
                        komaciContainer.isActive !== undefined;
            }
            // If the child node is relevant add it to the parent composition, otherwise flatten
            // the irrelevant child node composition it the parent composition.
            if (isRelevantChild) {
                compositions.push(komaciChildNode);
            }
            else {
                const childComposition = komaciChildNode.compositions ?? [];
                compositions.push(...childComposition);
            }
        }
    });
    if (compositions.length > 0) {
        komaciParentNode.compositions = compositions;
    }
}
// Convert a single AST node into its Komaci representation.
function astNodeToKomaciNode(analyzerContext, astNode) {
    switch (astNode.type) {
        case 'If':
            return getKomaciContainer(analyzerContext, astNode);
        case 'ForEach':
        case 'ForOf':
            return getKomaciIteration(analyzerContext, astNode);
        case 'Component':
            return getKomaciComposedAdg(analyzerContext, astNode);
        case 'Slot':
            return getKomaciSlot(analyzerContext, astNode);
        case 'Element': {
            if (astNode.name === 'img') {
                return getKomaciImg(analyzerContext, astNode);
            }
            else {
                return getKomaciContainer(analyzerContext, astNode);
            }
        }
        case 'Text':
        case 'Comment':
        case 'IfBlock':
        case 'ElseifBlock':
        case 'ElseBlock':
        case 'ScopedSlotFragment':
        case 'ExternalComponent':
        case 'Lwc':
            // Do nothing
            return;
        default: {
            const exhaustiveCheck = astNode;
            throw new Error(`Unknown child node ${exhaustiveCheck}`);
        }
    }
}
/**
 * Returns the KomaciDoc representation of an <img> tag. This method returns `undefined` if the src parameter is blank,
 * which means that no KomaciDoc representation of the <img> tag would be included in the KomaciDoc
 * @param {AnalyzerContext} analyzerContext the current state of the analyzer
 * @param {Element} astElement the template compiler Element
 * @returns {KomaciImage | undefined} the KomaciDoc representation of the <img> tag, as a komaci Image {Image}, or undefined
 * if none can be returned.
 */
function getKomaciImg(analyzerContext, astElement) {
    const attrValue = getAttributeValue(astElement, 'src');
    const { startTag } = astElement.location;
    const imgTagLocation = lwcSourceLocationToKomaci(startTag);
    if (attrValue) {
        if (attrValue.type === 'Literal') {
            // if `myValue.value` is blank (or not a string), we return `undefined`, as we should not generate
            // an Image KomaciDoc element for this
            if (typeof attrValue.value === 'boolean' ||
                attrValue.value === '' ||
                attrValue.value.startsWith('data:') ||
                attrValue.value.startsWith('blob:')) {
                return undefined;
            }
            return {
                type: 'Image',
                src: {
                    type: 'PrimitiveValue',
                    value: attrValue.value,
                },
                location: imgTagLocation,
            };
        }
        else if (attrValue.type === 'MemberExpression' || attrValue.type === 'Identifier') {
            const binding = expressionToBinding(analyzerContext, attrValue);
            // if `binding.value` is blank, we return `undefined`, as we should not generate an Image KomaciDoc element for this
            if (binding.value === '' ||
                binding.value.startsWith('data:') ||
                binding.value.startsWith('blob:')) {
                return undefined;
            }
            return {
                type: 'Image',
                src: binding,
                location: imgTagLocation,
            };
        }
    }
    return undefined;
}
/**
 * Find attribute with matching name.
 * @param {Element} node the template compiler Element, from which to find the attribute
 * @param {string} attributeName the name of the attribute to return, as a string
 * @returns {Attribute['value'] | undefined} value of matching attribute as a Literal, or an Expression, otherwise returns `undefined`
 */
function getAttributeValue(node, attributeName) {
    return node.attributes.find((attr) => attr.name === attributeName)?.value;
}
// Construct generic container which has an impact on the compositions data flow.
function getKomaciContainer(analyzerContext, astNode) {
    const container = {
        type: 'Container',
    };
    if (astNode.type === 'If') {
        container.isActive = {
            input: expressionToBinding(analyzerContext, astNode.condition),
            negate: astNode.modifier === 'false',
        };
        container.location = lwcSourceLocationToKomaci(astNode.directiveLocation);
    }
    if (astNode.type === 'Element') {
        const keyDirective = astNode.directives.find(isKeyDirective);
        if (keyDirective) {
            container.key = expressionToBinding(analyzerContext, keyDirective.value);
        }
        const slotAttribute = astNode.attributes.find(isSlotAttribute);
        if (slotAttribute) {
            container.slot = slotAttribute.value.value;
        }
    }
    processChildren(analyzerContext, astNode, container);
    return container;
}
// Convert AST for:each or iterator directive into a Komaci iteration.
// TODO: Handle `key` attribute for nodes inside iterations (depends on W-8667336).
function getKomaciIteration(analyzerContext, astNode) {
    const { iterationContext } = analyzerContext;
    let iteration;
    let iterationInfo;
    if (astNode.type === 'ForEach') {
        iteration = {
            type: 'Iteration',
            input: expressionToBinding(analyzerContext, astNode.expression),
            iterator: astNode.item.name,
            location: lwcSourceLocationToKomaci(astNode.directiveLocation),
        };
        iterationInfo = {
            directive: 'for:each',
            itemName: iteration.iterator,
            indexName: astNode.index?.name,
        };
    }
    else {
        iteration = {
            type: 'Iteration',
            input: expressionToBinding(analyzerContext, astNode.expression),
            iterator: astNode.iterator.name,
            location: lwcSourceLocationToKomaci(astNode.directiveLocation),
        };
        iterationInfo = {
            directive: 'iterator',
            itemName: iteration.iterator,
        };
    }
    // Use context to understand which iterations contain the code being analyzed.
    iterationContext.unshift(iterationInfo);
    processChildren(analyzerContext, astNode, iteration);
    // Finished with this iteration, remove from context.
    iterationContext.shift();
    return iteration;
}
// Get a ComposedAdg for the provided component reference.
function getKomaciComposedAdg(analyzerContext, astComponent) {
    const isDynamicComponent = astComponent.directives.some((attribute) => attribute.name === 'Dynamic' || attribute.name === 'Is');
    if (isDynamicComponent) {
        // Komaci doesn't support dynamic components (yet).
        return;
    }
    const importRef = getComponentImportReference(analyzerContext, utils.tagNameToComponentName(astComponent.name));
    const properties = {};
    const composedAdg = {
        type: 'ComposedAdg',
        input: importRef,
        properties,
        location: lwcSourceLocationToKomaci(astComponent.location),
    };
    const keyDirective = astComponent.directives.find(isKeyDirective);
    if (keyDirective) {
        composedAdg.key = expressionToBinding(analyzerContext, keyDirective.value);
    }
    [...astComponent.attributes, ...astComponent.properties].forEach((attrOrProp) => {
        const propName = attrOrProp.type === 'Attribute'
            ? utils.attributeNameToPropertyName(attrOrProp.name)
            : attrOrProp.name;
        switch (attrOrProp.value.type) {
            case 'Literal': {
                if (attrOrProp.type === 'Attribute' && isSlotAttribute(attrOrProp)) {
                    composedAdg.slot = attrOrProp.value.value;
                }
                else {
                    properties[propName] = {
                        type: 'PrimitiveValue',
                        value: attrOrProp.value.value,
                    };
                }
                break;
            }
            case 'Identifier':
            case 'MemberExpression': {
                properties[propName] = expressionToBinding(analyzerContext, attrOrProp.value);
                break;
            }
            default: {
                const exhaustiveCheck = attrOrProp.value;
                throw new Error(`Unknown value type ${exhaustiveCheck}`);
            }
        }
    });
    processChildren(analyzerContext, astComponent, composedAdg);
    return composedAdg;
}
// Convert AST slot element into Komaci slot.
function getKomaciSlot(analyzerContext, astElement) {
    const slot = {
        type: 'Slot',
        name: astElement.slotName ?? '',
    };
    const keyDirective = astElement.directives.find(isKeyDirective);
    if (keyDirective) {
        slot.key = expressionToBinding(analyzerContext, keyDirective.value);
    }
    const slotAttribute = astElement.attributes.find(isSlotAttribute);
    if (slotAttribute) {
        slot.slot = slotAttribute.value.value;
    }
    // Process the default content of this slot.
    processChildren(analyzerContext, astElement, slot);
    return slot;
}
/**
 * Map a component to an import reference based on it's namespace/name.
 * If no import exist for the adg associated with the component, then
 * create one and contribute it to the KomaciDocument being generated.
 *
 * @param analyzerContext
 * @param namespaceName namespace/name (in camelcase) of component being referenced.
 */
function getComponentImportReference(analyzerContext, namespaceName) {
    // check cache first.
    let importRef = analyzerContext.componentToImportMapping[namespaceName];
    if (importRef) {
        return importRef;
    }
    // cache miss. initialize imports, if needed.
    const komaciDoc = analyzerContext.komaciDoc;
    if (!komaciDoc.imports) {
        komaciDoc.imports = [];
    }
    // Construct resourceName of the import.
    const segments = namespaceName.split('/');
    if (segments.length !== 2) {
        throw new Error('Invalid component name. Expected format: <ns>/<name>. Received: ' + namespaceName);
    }
    const namespace = segments[0];
    const name = segments[1];
    // This import should be for the default export of component's js file.
    // Which is the Adg of the component being referenced.
    // Example: @salesforce/komaci/c__child__child.js
    const resourceName = `@salesforce/komaci/${namespace}__${name}__${name}.js`;
    // Add import to doc, create ref and cache for future use.
    komaciDoc.imports.push({ resourceName, names: ['default'] });
    const importIdx = komaciDoc.imports.length - 1;
    importRef = {
        type: 'ImportReference',
        value: `${importIdx}/names/0`,
    };
    analyzerContext.componentToImportMapping[namespaceName] = importRef;
    return importRef;
}
// Recursively process LWC expression into Komaci expression format (e.g. record/data/id).
function processExpression(astExpression) {
    if (astExpression.type === 'Identifier') {
        return astExpression.name;
    }
    else {
        return `${processExpression(astExpression.object)}/${astExpression.property.name}`;
    }
}
// Convert LWC expression metadata to Komaci binding reference.
function expressionToBinding(analyzerContext, astExpression) {
    const { iterationContext } = analyzerContext;
    let komaciExpression = processExpression(astExpression);
    if (iterationContext.length) {
        // Komaci normalizes expressions bound to for:each to look
        // the same as those used within the 'iterator' directive.
        const parts = komaciExpression.split('/');
        const firstPart = parts[0];
        const iterationInfo = iterationContext.find((info) => firstPart === info.itemName || firstPart === info.indexName);
        if (iterationInfo?.directive === 'for:each') {
            if (firstPart === iterationInfo.itemName) {
                parts.splice(1, 0, 'value');
            }
            else if (firstPart === iterationInfo.indexName) {
                parts[0] = iterationInfo.itemName;
                parts.splice(1, 0, 'index');
            }
            komaciExpression = parts.join('/');
        }
    }
    return {
        type: 'Binding',
        value: komaciExpression,
    };
}
// Assert if a directive is the special lwc `key` directive.
function isKeyDirective(directive) {
    return directive.name === 'Key';
}
// Assert if an attribute is a `slot` attribute.
function isSlotAttribute(attribute) {
    return (attribute.name === 'slot' &&
        attribute.value.type === 'Literal' &&
        typeof attribute.value.type === 'string');
}
// Convert a lwc formatted SourceLocation to komaci schema
function lwcSourceLocationToKomaci(lwcSourceLocation) {
    return {
        startLine: lwcSourceLocation.startLine,
        startColumn: lwcSourceLocation.startColumn,
        endLine: lwcSourceLocation.endLine,
        endColumn: lwcSourceLocation.endColumn,
    };
}

exports.generateKomaciDocFromTemplate = generateKomaciDocFromTemplate;
//# sourceMappingURL=analyzeTemplateFile.js.map

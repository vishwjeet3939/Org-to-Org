'use strict';

var postcssValueParser = require('postcss-value-parser');
var sfdcCompilerUtils = require('@lwc/sfdc-compiler-utils');
var utils = require('../shared/utils.js');
var utils$1 = require('../script-metadata/utils.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var postcssValueParser__default = /*#__PURE__*/_interopDefaultCompat(postcssValueParser);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function getImportInfo(param) {
    let root;
    try {
        root = postcssValueParser__default.default(param);
    }
    catch {
        // Ignore cases where the params value is malformed.
        return;
    }
    const node = root.nodes[0];
    if (utils.isUndefined(node)) {
        return;
    }
    // @import "./module.css";
    if (node.type === 'string') {
        return {
            name: node.value,
            offset: node.sourceIndex,
        };
    }
    // @import url(./module.css);
    // @import url("./module.css");
    if (node.type === 'function' && node.value === 'url') {
        const params = node.nodes;
        if (utils.isUndefined(params[0])) {
            return;
        }
        if (params[0].type === 'string') {
            return {
                name: params[0].value,
                offset: params[0].sourceIndex + 1, // Add the front quote to the offset.
            };
        }
        if (params[0].type === 'word') {
            return {
                name: params[0].value,
                offset: params[0].sourceIndex,
            };
        }
    }
}
function getLocation(rule, info) {
    // The at-rule parameter offset relative to the at-rule node is:
    //     - 1 for the '@' prefix length
    //     - the at-rule name length
    //     - the whitespace after the name length.
    const paramOffset = 1 + rule.name.length + (rule.raws.afterName?.length ?? 1);
    // relative position of module name with respect to the import statement
    const moduleNameRelativeOffset = paramOffset + info.offset + utils$1.QUOTE_LENGTH;
    const start = rule.positionInside(moduleNameRelativeOffset);
    const end = rule.positionInside(moduleNameRelativeOffset + info.name.length);
    const startOffset = rule.source.start.offset + moduleNameRelativeOffset;
    return {
        startLine: start.line,
        startColumn: start.column,
        endLine: end.line,
        endColumn: end.column,
        start: startOffset,
        end: startOffset + info.name.length,
    };
}
function getImportType(name) {
    if (name.startsWith('.')) {
        return 'local';
    }
    else if (name.startsWith('@salesforce')) {
        return '@salesforce';
    }
    else {
        return 'external';
    }
}
function createReference(name, references, namespaceMapping) {
    const type = getImportType(name);
    const id = utils.generateReferenceId('ModuleReference', references.size, name);
    const namespacedName = type === 'external' ? sfdcCompilerUtils.getNamespacedIdForResource(name, namespaceMapping) : undefined;
    return {
        id,
        name,
        namespacedName,
        type,
        locations: [],
    };
}
function collectImports(result, root, namespaceMapping) {
    const references = new Map();
    root.walkAtRules('import', (rule) => {
        const importInfo = getImportInfo(rule.params);
        // Ignore malformed at-rule imports.
        if (utils.isUndefined(importInfo)) {
            return;
        }
        const { name } = importInfo;
        const importLocation = getLocation(rule, importInfo);
        let reference = references.get(name);
        if (utils.isUndefined(reference)) {
            reference = createReference(name, references, namespaceMapping);
            result.imports.push(reference);
            references.set(name, reference);
        }
        reference.locations.push(importLocation);
    });
}

exports.collectImports = collectImports;
//# sourceMappingURL=imports.js.map

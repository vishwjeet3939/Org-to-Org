'use strict';

var postcssValueParser = require('postcss-value-parser');
var utils = require('../shared/utils.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var postcssValueParser__default = /*#__PURE__*/_interopDefaultCompat(postcssValueParser);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function collectCustomProperties(result, root, strict) {
    root.walkDecls((decl) => {
        // Early exit if the declaration doesn't includes a var() function. This avoid parsing the
        // selector when not needed.
        if (!decl.value.includes('var(')) {
            return;
        }
        // The value offset from the start of the declaration node is:
        // - the declaration property name length
        // - the space between the declaration and the value (raws.between includes the `:`)
        const valueOffset = decl.prop.length + (decl.raws.between?.length ?? 1);
        let parsedValue;
        try {
            parsedValue = postcssValueParser__default.default(decl.value);
        }
        catch (error) {
            // Ignore cases where the declaration value is malformed.
            return;
        }
        // Use the 'strict' flag to determine whether to comprehensively collect lwc tokens nested within
        // css functions. Fallback to backwards compatible behavior when 'strict' is false.
        let nodeWalker;
        if (strict) {
            nodeWalker = parsedValue.walk.bind(parsedValue);
        }
        else {
            // To keep the implementation backwards compatible with metadata-v1, only process declaration
            // values that start with a "var". This is not comprehensive, as lwc tokens nested with in
            // css functions are not collected. But doing so now will break existing usages in production
            const { nodes } = parsedValue;
            const declarationValueStartsWithVar = nodes.filter((n) => {
                return n.type === 'function' && n.value === 'var';
            });
            nodeWalker = postcssValueParser__default.default.walk.bind(postcssValueParser__default.default, declarationValueStartsWithVar);
        }
        nodeWalker((node) => {
            if (node.type !== 'function' || node.value !== 'var') {
                return;
            }
            const params = node.nodes;
            if (utils.isUndefined(params[0]) || params[0].type !== 'word') {
                return;
            }
            const name = params[0].value;
            // Relative position of the variable with respect to the declaration
            const relativeOffset = valueOffset + params[0].sourceIndex;
            const start = decl.positionInside(relativeOffset);
            const end = decl.positionInside(relativeOffset + name.length);
            const startOffset = decl.source.start.offset + relativeOffset;
            // const endOffset = startOffset + name.length;
            result.customProperties.push({
                name,
                location: {
                    startLine: start.line,
                    startColumn: start.column,
                    endLine: end.line,
                    endColumn: end.column,
                    start: startOffset,
                    end: startOffset + name.length,
                },
            });
        });
    });
}

exports.collectCustomProperties = collectCustomProperties;
//# sourceMappingURL=custom-properties.js.map

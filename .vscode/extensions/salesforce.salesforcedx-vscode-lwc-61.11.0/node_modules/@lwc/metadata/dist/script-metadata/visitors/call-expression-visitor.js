'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var t = require('@babel/types');
var eventDispatch = require('../events/event-dispatch.js');
var utils = require('../utils.js');
var eventListener = require('../events/event-listener.js');

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function extractCallDetails(path) {
    const { node: { callee, arguments: args }, scope, } = path;
    let calleeName;
    let methodScope;
    // Function calls of type object.method(), where method is the property of an object
    // method.call(), object.method.call(), parentObject.nested.method()
    if (callee.type === 'MemberExpression') {
        const { property, computed } = callee;
        // object['method']()
        if (property.type === 'StringLiteral') {
            calleeName = property.value;
            methodScope = callee.object;
        }
        // object.method()
        else if (property.type === 'Identifier') {
            // method.call(), object.method.call()
            if (property.name === 'call') {
                // method.call()
                if (callee.object.type === 'Identifier') {
                    calleeName = computed
                        ? utils.resolveIdentifierValue(callee.object, scope)
                        : callee.object.name;
                }
                // object.method.call()
                else if (callee.object.type === 'MemberExpression') {
                    const { property: calleeObjectProperty, computed } = callee.object;
                    // object['method'].call()
                    if (calleeObjectProperty.type === 'StringLiteral') {
                        calleeName = calleeObjectProperty.value;
                    }
                    // object.method.call()
                    else if (calleeObjectProperty.type === 'Identifier') {
                        calleeName = computed
                            ? utils.resolveIdentifierValue(calleeObjectProperty, scope)
                            : calleeObjectProperty.name;
                    }
                }
                if (t__namespace.isExpression(args[0])) {
                    methodScope = args[0];
                    args.shift();
                }
            }
            // parentObject.object.method() or object.method()
            else {
                calleeName = computed ? utils.resolveIdentifierValue(property, scope) : property.name;
                methodScope = callee.object;
            }
        }
    }
    // Function calls of type method()
    else if (callee.type === 'Identifier') {
        calleeName = callee.name;
    }
    return { calleeName, methodScope, args };
}
function visitorFunction(state, result) {
    return function CallExpressionVisitorFunction(path) {
        const { node: { callee }, } = path;
        const { object: calleeObject } = callee;
        const { args, calleeName, methodScope } = extractCallDetails(path);
        if (calleeName === 'dispatchEvent') {
            // collect references like this.dispatchEvent(), this.template.dispatchEvent(), foo.dispatchEvent()
            // do not collect references like dispatchEvent() or dispatchEvent.call(), where the left hand side of dispatchEvent is empty
            if (
            // dispatchEvent()
            callee.type !== 'MemberExpression' ||
                // dispatchEvent.call()
                (callee.property.type === 'Identifier' &&
                    callee.property.name === 'call' &&
                    calleeObject.type === 'Identifier')) {
                return;
            }
            eventDispatch.gatherEventDispatchMetadata(path, args, methodScope, result, state);
        }
        else if (calleeName === 'addEventListener') {
            // collect references like this.addEventListener(), this.template.addEventListener(), foo.addEventListener()
            // do not collect references like addEventListener() or addEventListener.call(),
            // where 'dispatchEvent' is not resolved as a property of an object
            if (
            // addEventListener()
            callee.type !== 'MemberExpression' ||
                // addEventListener.call()
                (callee.property.type === 'Identifier' &&
                    callee.property.name === 'call' &&
                    calleeObject.type === 'Identifier')) {
                return;
            }
            eventListener.gatherEventListenerMetadata(path, args, methodScope, result);
        }
    };
}

exports.default = visitorFunction;
//# sourceMappingURL=call-expression-visitor.js.map

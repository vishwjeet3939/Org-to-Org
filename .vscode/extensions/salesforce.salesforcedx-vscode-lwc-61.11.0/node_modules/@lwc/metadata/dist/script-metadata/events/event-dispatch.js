'use strict';

var utils = require('../utils.js');
var utils$1 = require('../../shared/utils.js');

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function gatherEventDispatchMetadata(path, args, methodScope, result, state) {
    const dispatchEvent = {
        location: utils.generateSourceLocation(path.node),
        targetType: 'unresolved',
        event: 'unresolved',
    };
    if (args.length > 0 && args[0].type === 'NewExpression') {
        // Event constructors will be resolved during post processing
        state.eventsPendingResolution.push({
            eventDispatch: dispatchEvent,
            eventConstructor: args[0],
        });
    }
    if (!utils$1.isUndefined(methodScope)) {
        if (methodScope.type === 'ThisExpression') {
            // Is this sufficient to determine that the target is 'host'
            dispatchEvent.targetType = 'host';
        }
        else if (methodScope.type === 'MemberExpression' &&
            methodScope.object.type === 'ThisExpression' &&
            ((methodScope.property.type === 'Identifier' &&
                methodScope.property.name === 'template') ||
                (methodScope.property.type === 'StringLiteral' &&
                    methodScope.property.value === 'template'))) {
            dispatchEvent.targetType = 'shadowRoot';
        }
        else if (methodScope.type === 'Identifier') {
            const identifier = utils.resolveIdentifierValue(methodScope, path.scope);
            if (identifier === 'window' || identifier === 'document') {
                dispatchEvent.targetType = identifier;
            }
        }
    }
    result.eventsDispatched.push(dispatchEvent);
}

exports.gatherEventDispatchMetadata = gatherEventDispatchMetadata;
//# sourceMappingURL=event-dispatch.js.map

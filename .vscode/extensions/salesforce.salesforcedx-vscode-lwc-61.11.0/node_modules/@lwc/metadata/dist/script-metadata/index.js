'use strict';

var path = require('node:path');
var t = require('@babel/types');
var parser = require('@babel/parser');
var traverse = require('@babel/traverse');
var errors = require('@lwc/errors');
var errors$1 = require('../errors/errors.js');
var utils$1 = require('../shared/utils.js');
var analyzeScriptFile = require('../dependency-analyzer/analyzeScriptFile.js');
var index = require('../luvio-metadata/index.js');
var utils = require('./utils.js');
var classVisitor = require('./visitors/class-visitor.js');
var dynamicImportsVisitor = require('./visitors/dynamic-imports-visitor.js');
var exportAllVisitor = require('./visitors/export-all-visitor.js');
var exportDefaultVisitor = require('./visitors/export-default-visitor.js');
var exportNamedVisitor = require('./visitors/export-named-visitor.js');
var moduleImportsVisitor = require('./visitors/module-imports-visitor.js');
var callExpressionVisitor = require('./visitors/call-expression-visitor.js');
var newExpressionVisitor = require('./visitors/new-expression-visitor.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespaceCompat(path);
var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);
var traverse__default = /*#__PURE__*/_interopDefaultCompat(traverse);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function generateEmptyResult(fileName, fileType) {
    return {
        fileType,
        fileName,
        moduleReferences: [],
        classes: [],
        imports: [],
        dynamicImports: [],
        exports: [],
        domEvents: [],
        eventListeners: [],
        eventsDispatched: [],
        diagnostics: [],
    };
}
function updateEventReferences(eventLookup, eventsPendingResolution) {
    eventsPendingResolution.forEach(({ eventDispatch, eventConstructor }) => {
        const domEvent = eventLookup.get(eventConstructor);
        if (!utils$1.isUndefined(domEvent)) {
            eventDispatch.event = { refId: domEvent.id };
        }
    });
}
function pruneClasses(klasses, state) {
    const { classLookup, classNodeLookup, mainClass: mainClassNode } = state;
    const mainClass = mainClassNode && classLookup.get(mainClassNode);
    // A class is qualified for metadata collection if
    //  - It is a component class
    //  - If the class is exported (named or default export)
    //  - If the class is a main class (default export identifier that resolves to a class)
    const shouldCollect = (klass) => {
        const { isComponentClass } = klass;
        const classPath = classNodeLookup.get(klass);
        const isExportedClass = t__namespace.isExportDefaultDeclaration(classPath.parent) ||
            t__namespace.isExportNamedDeclaration(classPath.parent);
        const isMainClass = mainClass === klass;
        return isComponentClass || isExportedClass || isMainClass;
    };
    // Get all the ancestor classes for a given class.
    const getAncestorClasses = (klass) => {
        if (utils$1.isUndefined(klass.extends) || klass.extends === 'unresolved') {
            return [];
        }
        const ancestorRefId = klass.extends.refId;
        const ancestor = klasses.find((k) => k.id === ancestorRefId);
        if (utils$1.isUndefined(ancestor)) {
            return [];
        }
        return [...getAncestorClasses(ancestor), ancestor];
    };
    const collected = new Set();
    for (const klass of klasses) {
        if (shouldCollect(klass)) {
            collected.add(klass);
            for (const ancestor of getAncestorClasses(klass)) {
                collected.add(ancestor);
            }
        }
    }
    return Array.from(collected);
}
/**
 * If the script file exports a class as the default export, then update the result
 * Note 1: Currently only considers
 *  1. ExportDefaultDeclaration of a ClassDeclaration(Example: export default expression).
 *  2. ExportDefaultDeclaration of an Identifier that resolves to a class(
 *      Example 1:
 *          class Foo {
 *          }
 *          export default Foo;
 *      Example 2:
 *          const Foo = class {}
 *          export default Foo;
 *     )
 *
 *  Note 2: ExportNamedDeclaration with a DefaultSpecifier is not considered because lwc compiler does
 *  not consider that as a component class(Example: export {MyComponent as default}).
 */
function updateMainClass(result, state) {
    const { mainClass } = state;
    if (!utils$1.isUndefined(mainClass)) {
        const klass = state.classLookup.get(mainClass);
        // klass might be undefined if the class metadata gathering encountered diagnostic issues
        if (!utils$1.isUndefined(klass)) {
            result.mainClass = {
                name: klass.name,
                refId: klass.id,
            };
        }
    }
}
function collectScriptMetadataFromSource(fileName, source, config) {
    const { bundleType } = config;
    let ast;
    const plugins = [
        ['decorators', { decoratorsBeforeExport: true }],
        'classProperties',
    ];
    const fileType = path__namespace.extname(fileName) === '.ts' ? 'ts' : 'js';
    // Use Babel's built-in TypeScript plugin for parsing internal components
    if (fileType === 'ts' && bundleType === 'internal') {
        plugins.push('typescript');
    }
    try {
        ast = parser.parse(source, {
            sourceType: 'module',
            plugins: plugins,
            sourceFilename: fileName,
        });
    }
    catch (e) {
        const result = generateEmptyResult(fileName, fileType);
        result.diagnostics.push(errors.generateCompilerDiagnostic(errors$1.Errors.SYNTAX_ERROR, {
            messageArgs: [fileName, e.message],
            origin: {
                filename: fileName,
                location: {
                    line: e.loc?.line,
                    column: e.loc?.column,
                },
            },
        }));
        return result;
    }
    const { namespaceMapping, enableKomaci, enableLuvio } = config;
    const state = new utils.ScriptState({ fileName, namespaceMapping, bundleType, source, fileType });
    const collectionResult = collectScriptMetadataFromAst(fileName, ast, state);
    if (enableKomaci) {
        collectionResult.komaciDoc = analyzeScriptFile.generateKomaciDocFromScript(collectionResult, state);
    }
    if (enableLuvio) {
        collectionResult.luvioMetadata = index.generateLuvioMetadata(ast);
    }
    return collectionResult;
}
/** Internal API, optimization to reuse existing ast from compilation process **/
function collectScriptMetadataFromAst(fileName, astRoot, state) {
    const result = generateEmptyResult(fileName, state.fileType);
    try {
        traverse__default.default(astRoot, {
            enter(path) {
                // Force the all the import declarations to be collected first. The other visitors
                // depends on the collected imports data.
                path.traverse({
                    ImportDeclaration: moduleImportsVisitor.default(state, result),
                });
            },
            CallExpression: callExpressionVisitor.default(state, result),
            Class: classVisitor.default(state, result),
            ExportAllDeclaration: exportAllVisitor.default(state, result),
            ExportDefaultDeclaration: exportDefaultVisitor.default(state, result),
            ExportNamedDeclaration: exportNamedVisitor.default(state, result),
            Import: dynamicImportsVisitor.default(state, result),
            NewExpression: newExpressionVisitor.default(state, result),
        });
    }
    catch (e) {
        if (e instanceof errors$1.MetadataCollectionError) {
            result.diagnostics = e.diagnostics;
        }
        else {
            // Any other type of error will be re-thrown
            throw e;
        }
    }
    updateEventReferences(state.eventLookup, state.eventsPendingResolution);
    result.classes = pruneClasses(result.classes, state);
    updateMainClass(result, state);
    return result;
}
/** End internal API **/

exports.collectScriptMetadataFromSource = collectScriptMetadataFromSource;
//# sourceMappingURL=index.js.map

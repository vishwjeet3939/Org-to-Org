'use strict';

var t = require('@babel/types');
var utils = require('../shared/utils.js');

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
const defaultLocation = {
    startLine: 0,
    startColumn: 0,
    endLine: 0,
    endColumn: 0,
    start: 0,
    end: 0,
};
// Offset quotes for string literal nodes
const QUOTE_LENGTH = 1;
function generateSourceLocation(node, precedingOffset = 0, followingOffset = 0, fileName) {
    const { loc, start, end } = node;
    const result = utils.isNull(loc) || utils.isUndefined(loc)
        ? defaultLocation
        : {
            startLine: loc.start.line,
            // Convert to 1-based index
            startColumn: loc.start.column + precedingOffset + 1,
            endLine: loc.end.line,
            // Convert to 1-based index
            endColumn: loc.end.column - followingOffset + 1,
            start: start + precedingOffset,
            end: end - followingOffset,
        };
    if (fileName) {
        result.fileName = fileName;
    }
    return result;
}
function isGlobalIdentifier(identifier, scope) {
    // If the identifier name can be resolved in current scope, then it is not a global identifier
    return utils.isUndefined(scope.getBinding(identifier.name));
}
function resolveIdentifierValue(identifier, scope) {
    const binding = scope.getBinding(identifier.name);
    if (utils.isUndefined(binding)) {
        return identifier.name;
    }
    else if (binding.kind === 'const' &&
        binding.path.node.type === 'VariableDeclarator' &&
        !utils.isNull(binding.path.node.init) &&
        !utils.isUndefined(binding.path.node.init) &&
        binding.path.node.init.type === 'StringLiteral') {
        return binding.path.node.init.value;
    }
}
class ScriptState extends utils.State {
    constructor({ fileName, namespaceMapping, bundleType, source, fileType, }) {
        super({ fileName, namespaceMapping, bundleType });
        // Lookup for module reference by module specifier, used incase a module is imported twice in the same file
        this.moduleReferenceLookup = new Map();
        this.eventLookup = new Map();
        // Any unresolved Event references unresolved when EventDispatch was create will be updated in post processing
        this.eventsPendingResolution = [];
        // Used to look up class metadata by ast Class node
        this.classLookup = new Map();
        // Used to prune class list based on ast node information
        this.classNodeLookup = new Map();
        this.source = source;
        this.fileType = fileType;
    }
}
function isClassMember(node) {
    return (t__namespace.isClassProperty(node) ||
        (t__namespace.isClassMethod(node) &&
            (node.kind === 'get' || node.kind === 'set' || node.kind === 'method')));
}
function isClassPropertyOrAccessor(node) {
    return (t__namespace.isClassProperty(node) ||
        (t__namespace.isClassMethod(node) && (node.kind === 'get' || node.kind === 'set')));
}
function getClassMemberName(node) {
    switch (node.key.type) {
        case 'Identifier':
            return node.key.name;
        case 'StringLiteral':
            return node.key.value;
        case 'NumericLiteral':
            return node.key.value.toString();
    }
}

exports.QUOTE_LENGTH = QUOTE_LENGTH;
exports.ScriptState = ScriptState;
exports.generateSourceLocation = generateSourceLocation;
exports.getClassMemberName = getClassMemberName;
exports.isClassMember = isClassMember;
exports.isClassPropertyOrAccessor = isClassPropertyOrAccessor;
exports.isGlobalIdentifier = isGlobalIdentifier;
exports.resolveIdentifierValue = resolveIdentifierValue;
//# sourceMappingURL=utils.js.map

'use strict';

var t = require('@babel/types');
var utils = require('../shared/utils.js');

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function unresolved() {
    return {
        type: 'Unresolved',
        value: 'unresolved',
    };
}
function resolveImportSpecifierImported(imported) {
    return t__namespace.isStringLiteral(imported) ? imported.value : imported.name;
}
function resolveExportSpecifierExported(imported) {
    return t__namespace.isStringLiteral(imported) ? imported.value : imported.name;
}
function resolveIdentifier(identifier, scope, unresolvedIdentifiers) {
    const binding = scope.getBinding(identifier.name);
    if (utils.isUndefined(binding)) {
        return { type: 'Undefined', value: undefined };
    }
    const { kind, path, identifier: bindingIdentifier } = binding;
    // If identifier is a constant and it has a initial value
    if (kind === 'const') {
        if (path.node.type === 'VariableDeclarator' &&
            !utils.isNull(path.node.init) &&
            !utils.isUndefined(path.node.init)) {
            // If an unresolved identifier is visited twice in the current resolution cycle, there is a circular reference
            if (unresolvedIdentifiers.has(bindingIdentifier)) {
                return unresolved();
            }
            unresolvedIdentifiers.add(bindingIdentifier);
            const value = resolveExpression(path.node.init, scope, unresolvedIdentifiers);
            unresolvedIdentifiers.delete(bindingIdentifier);
            return value;
        }
    }
    else if (kind === 'module') {
        // If identifier is a value imported from an external module
        const { parent, node } = path;
        if (t__namespace.isImportDeclaration(parent)) {
            if (t__namespace.isImportSpecifier(node)) {
                return {
                    type: 'ImportedValue',
                    importedName: resolveImportSpecifierImported(node.imported),
                    localName: node.local.name,
                    moduleSpecifier: parent.source.value,
                };
            }
            else if (t__namespace.isImportDefaultSpecifier(node)) {
                return {
                    type: 'ImportedValue',
                    importedName: 'default',
                    localName: node.local.name,
                    moduleSpecifier: parent.source.value,
                };
            }
            else if (t__namespace.isImportNamespaceSpecifier(node)) {
                return {
                    type: 'ImportedValue',
                    importedName: '*',
                    localName: node.local.name,
                    moduleSpecifier: parent.source.value,
                };
            }
        }
    }
    return unresolved();
}
/**
 * Resolve MemberExpression only if the expression resolves to an ImportedBinding of a NameSpaceImport
 * https://tc39.es/ecma262/multipage/ecmascript-language-scripts-and-modules.html#prod-NameSpaceImport
 * Resolved expression:
 * 1.
 *      import * as namespacedImport from 'module-name';
 *      export default class {
 *          get value() { return namespacedImport.someMethod; }
 *      }
 * 2.
 *      import * as namespacedImport from 'module-name';
 *      export default class {
 *          get value() { return namespacedImport['someMethod']; }
 *      }
 *
 * Unresolved expressions:
 * 1.
 *      import * as namespacedImport from 'module-name';
 *      export default class {
 *          get value() { return namespacedImport.someObject.property; }
 *          get value1() { return namespacedImport.someObject; }
 *      }
 *
 * 2.
 *      import { namedBinding } from 'module-name';
 *      export default class {
 *          get value() { return namedBinding.property; }
 *      }
 * 3.
 *      import { default as namedBinding } from 'module-name';
 *      export default class {
 *          get value() { return namedBinding.property; }
 *      }
 * 4.
 *      import defaultBinding from 'module-name';
 *      export default class {
 *          get value() { return defaultBinding.property; }
 *      }
 */
function resolveMemberExpression(memberExpression, scope) {
    // Only consider simple member expression:
    // - Object and property identifiers 'foo.bar'
    // - Object identifier and string literal property 'foo["bar"]'
    if (!t__namespace.isIdentifier(memberExpression.object) ||
        // If the member expression is computed and the property is not a string literal
        (memberExpression.computed && !t__namespace.isStringLiteral(memberExpression.property)) ||
        // If the member expression is not computed and the property is not an identifier(can be a private field), exit fast
        (!memberExpression.computed && !t__namespace.isIdentifier(memberExpression.property))) {
        return unresolved();
    }
    const root = memberExpression.object;
    const binding = scope.getBinding(root.name);
    // If the root of the MemberExpression cannot be resolved in the current scope, we will deem it unresolvable
    if (utils.isUndefined(binding)) {
        return unresolved();
    }
    if (binding.kind === 'module') {
        // If identifier is a value imported from an external module
        const { parent, node } = binding.path;
        const importedBinding = t__namespace.isIdentifier(memberExpression.property)
            ? memberExpression.property.name
            : memberExpression.property.value;
        if (t__namespace.isImportDeclaration(parent) && t__namespace.isImportNamespaceSpecifier(node)) {
            // Represent the namespaced import in a named import format, it is a good enough approximation
            return {
                type: 'ImportedValue',
                importedName: importedBinding,
                localName: importedBinding,
                moduleSpecifier: parent.source.value,
            };
        }
    }
    return unresolved();
}
/**
 * Resolve TemplateLiteral only if the expression is a static string without any expressions
 * Resolved expression:
 * 1.
 *      `hello world`
 * 2.
 *      `
 *          hello
 *             world
 *      `
 *
 * Unresolved expressions:
 * 1.
 *      `
 *          hello
 *          ${world}
 *      `
 */
function resolveTemplateLiteralExpression(templateLiteral) {
    const { expressions, quasis } = templateLiteral;
    if (expressions.length > 0 || quasis.length !== 1) {
        return unresolved();
    }
    const first = quasis[0];
    const { raw } = first.value;
    return {
        type: 'String',
        value: raw,
    };
}
/**
 * Resolve an expression to a Value.
 * @param expression expression to resolve
 * @param scope scope in which the expression was found
 * @param unresolvedIdentifiers  To detect ciruclar reference in identifiers
 * @returns Resolved value
 */
function resolveExpression(expression, scope, unresolvedIdentifiers = new Set()) {
    switch (expression.type) {
        case 'ArrayExpression':
            return {
                type: 'Array',
                value: expression.elements.map((element) => {
                    if (t__namespace.isExpression(element)) {
                        return resolveExpression(element, scope, unresolvedIdentifiers);
                    }
                    else {
                        return unresolved();
                    }
                }),
            };
        case 'BooleanLiteral':
            return {
                type: 'Boolean',
                value: expression.value,
            };
        case 'StringLiteral':
            return {
                type: 'String',
                value: expression.value,
            };
        case 'NumericLiteral':
            return {
                type: 'Number',
                value: expression.value,
            };
        case 'ObjectExpression':
            return {
                type: 'Object',
                value: expression.properties.reduce((accumulator, property) => {
                    if (t__namespace.isObjectProperty(property) &&
                        // Following key types considered {key: 'value'}, {'key': 'value'}, {1: 'value'}
                        (t__namespace.isIdentifier(property.key) ||
                            t__namespace.isStringLiteral(property.key) ||
                            t__namespace.isNumericLiteral(property.key))) {
                        const key = t__namespace.isIdentifier(property.key)
                            ? property.key.name
                            : property.key.value;
                        if (t__namespace.isExpression(property.value)) {
                            accumulator[key] = resolveExpression(property.value, scope, unresolvedIdentifiers);
                        }
                        else {
                            accumulator[key] = unresolved();
                        }
                    }
                    return accumulator;
                }, {}),
            };
        case 'NullLiteral':
            return {
                type: 'Null',
                value: null,
            };
        case 'Identifier':
            return resolveIdentifier(expression, scope, unresolvedIdentifiers);
        case 'MemberExpression':
            return resolveMemberExpression(expression, scope);
        case 'TemplateLiteral':
            return resolveTemplateLiteralExpression(expression);
    }
    return unresolved();
}
/**
 * Return value resolution will be returned only if the code block contains a single return statement
 * and no other statements, except for ExpressionStatement or declarations. Such limitation is
 * enforced to eliminate return value ambiguity in a multi-statement code blocks and reduce complexity.
 *
 * For ex, multiple return statements that are nested inside other statements, such as 'if', 'for',
 * etc, can be very difficult and non-performant to locate. Therefore, we look for a return
 * statement in the immediate scope and ensure no other statements exist.
 */
function resolveMethodReturnValue(methodNode, scope) {
    let hasUnsupportedStatement = false;
    const returnStatements = [];
    for (const node of methodNode.body.body) {
        if (t__namespace.isReturnStatement(node)) {
            returnStatements.push(node);
        }
        else if (!t__namespace.isExpressionStatement(node) && !t__namespace.isDeclaration(node)) {
            hasUnsupportedStatement = true;
        }
        // Don't proceed if there is more than one statement
        if (returnStatements.length > 1 || hasUnsupportedStatement) {
            break;
        }
    }
    // Existence of any 'statement' nodes inside a code block, other than a return or an expression
    // type, will result in 'unresolved' return type.
    if (hasUnsupportedStatement) {
        return unresolved();
    }
    else if (returnStatements.length === 1) {
        if (utils.isUndefined(returnStatements[0].argument) || utils.isNull(returnStatements[0].argument)) {
            return {
                type: 'Undefined',
                value: undefined,
            };
        }
        return resolveExpression(returnStatements[0].argument, scope);
    }
    else {
        return {
            type: 'Undefined',
            value: undefined,
        };
    }
}

exports.resolveExportSpecifierExported = resolveExportSpecifierExported;
exports.resolveExpression = resolveExpression;
exports.resolveImportSpecifierImported = resolveImportSpecifierImported;
exports.resolveMethodReturnValue = resolveMethodReturnValue;
exports.unresolved = unresolved;
//# sourceMappingURL=resolver.js.map

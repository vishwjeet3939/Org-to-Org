'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('../../../../errors/errors.js');
var utils = require('../utils.js');
var utils$1 = require('../../../../shared/utils.js');

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
const APEX_PREFIX = '@salesforce/apex';
const APEX_CONTINUATION_PREFIX = '@salesforce/apexContinuation';
function isValidApexServiceImport(value) {
    return value.startsWith(APEX_PREFIX);
}
function validateApexId(moduleSpecifier, sourceNode, id, filename, apexPrefix) {
    if (utils$1.isNull(id) || utils$1.isEmpty(id)) {
        throw new errors.MetadataCollectionError([
            utils.createReferenceDiagnostic(sourceNode, filename, errors.Errors.MISSING_RESOURCE_VALUE, [
                moduleSpecifier,
            ]),
        ]);
    }
    const sourceDiagnostics = [];
    const parts = id.split('.');
    const method = parts.pop();
    const classname = parts.pop();
    const namespace = parts.pop();
    // apex modules should have both method and classname unless it is `refreshApex`
    if (!method || !classname) {
        sourceDiagnostics.push(utils.createReferenceDiagnostic(sourceNode, filename, errors.Errors.MODULE_SHOULD_HAVE_METHOD_AND_CLASSNAME, [apexPrefix]));
    }
    // no default 'c' namespace
    if (namespace === 'c') {
        sourceDiagnostics.push(utils.createReferenceDiagnostic(sourceNode, filename, errors.Errors.MODULE_SHOULD_NOT_BE_IMPORTED_FROM_DEFAULT_NAMESPACE, [apexPrefix]));
    }
    if (!utils$1.isEmpty(sourceDiagnostics)) {
        throw new errors.MetadataCollectionError(sourceDiagnostics);
    }
}
function getApexContinuationReferences(moduleSpecifier, node, state) {
    return getBaseApexReference(APEX_CONTINUATION_PREFIX, 'apexContinuation', moduleSpecifier, node, state);
}
function getApexReference(moduleSpecifier, node, state) {
    return getBaseApexReference(APEX_PREFIX, 'apexMethod', moduleSpecifier, node, state);
}
function getBaseApexReference(apexPrefix, apexType, moduleSpecifier, node, state) {
    const source = node.source;
    const { fileName, namespaceMapping } = state;
    utils.assertOnlyDefaultImport(node, fileName, apexPrefix);
    const id = utils.getId(apexPrefix, moduleSpecifier);
    validateApexId(moduleSpecifier, source, id, fileName, apexPrefix);
    return utils.generateSalesforceReference(source, moduleSpecifier, apexType, id, namespaceMapping, state);
}
const apexCollector = {
    matches(value) {
        return (utils.isValidImportForPrefix(APEX_PREFIX, value) ||
            utils.isValidImportForPrefix(APEX_CONTINUATION_PREFIX, value) ||
            isValidApexServiceImport(value));
    },
    collect(value, node, state) {
        let reference;
        if (utils.isValidImportForPrefix(APEX_PREFIX, value)) {
            reference = getApexReference(value, node, state);
        }
        else if (utils.isValidImportForPrefix(APEX_CONTINUATION_PREFIX, value)) {
            reference = getApexContinuationReferences(value, node, state);
        }
        else if (isValidApexServiceImport(value)) {
            // must be "import { refreshApex } from '@salesforce/apex';"
            // refresh apex is treated as a salesforce module
            reference = utils.getModuleReference(value, node.source, state, '@salesforce');
            if (!utils$1.isUndefined(reference)) {
                reference.sfdcResource = { id: '', scoped: 'apex' };
            }
        }
        else {
            throw new errors.MetadataCollectionError([
                utils.createReferenceDiagnostic(node.source, state.fileName, errors.Errors.INVALID_MODULE_ID, [
                    value,
                ]),
            ]);
        }
        return reference;
    },
};

exports.default = apexCollector;
//# sourceMappingURL=apex.js.map

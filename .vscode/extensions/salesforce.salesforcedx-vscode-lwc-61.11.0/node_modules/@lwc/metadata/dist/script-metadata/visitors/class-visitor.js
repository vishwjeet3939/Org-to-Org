'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var t = require('@babel/types');
var utils = require('../utils.js');
var utils$1 = require('../../shared/utils.js');
var index = require('../decorators/index.js');
var resolver = require('../resolver.js');

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function gatherParentClassMetadata(superClass, scope, state) {
    const superClassName = superClass.name;
    const binding = scope.getBinding(superClassName);
    if (utils$1.isUndefined(binding)) {
        return 'unresolved';
    }
    const { node, parent } = binding.path;
    // Super class was imported, resolve ModuleReference
    if (t__namespace.isImportDeclaration(parent) &&
        (t__namespace.isImportSpecifier(node) || t__namespace.isImportDefaultSpecifier(node))) {
        const moduleSpecifier = parent.source.value;
        return {
            name: superClassName,
            moduleSpecifier,
            refId: state.moduleReferenceLookup.get(moduleSpecifier)?.id,
            location: utils.generateSourceLocation(superClass),
        };
    }
    else if (t__namespace.isClass(node)) {
        return {
            name: superClassName,
            refId: state.classLookup.get(node)?.id,
            location: utils.generateSourceLocation(superClass),
        };
    }
    return 'unresolved';
}
function extractComment(node) {
    if (node.leadingComments) {
        const lastCommentNode = node.leadingComments[node.leadingComments.length - 1];
        if (lastCommentNode.type === 'CommentBlock') {
            return lastCommentNode.value.charAt(0) === '*' ? lastCommentNode.value : undefined;
        }
    }
}
function extractClassComment(path) {
    if (path.node.leadingComments) {
        return extractComment(path.node);
    }
    else if (t__namespace.isExportDefaultDeclaration(path.parentPath.node) ||
        t__namespace.isExportNamedDeclaration(path.parentPath.node)) {
        return extractComment(path.parentPath.node);
    }
}
function visitorFunction(state, result) {
    return function ClassVisitorFunction(path) {
        const { node, scope } = path;
        const { id, superClass, body } = node;
        const name = id?.name;
        const classMetadata = {
            location: utils.generateSourceLocation(node),
            name,
            id: state.generateReferenceId('Class', name),
            properties: [],
            methods: [],
            __internal__doc: extractClassComment(path),
        };
        if (!utils$1.isNull(superClass) && !utils$1.isUndefined(superClass)) {
            let parentClass;
            if (superClass.type === 'Identifier') {
                parentClass = gatherParentClassMetadata(superClass, scope, state);
            }
            else {
                parentClass = 'unresolved';
            }
            classMetadata.extends = parentClass;
            if (parentClass !== 'unresolved' &&
                parentClass.name === 'LightningElement' &&
                parentClass['moduleSpecifier'] === 'lwc') {
                classMetadata.isComponentClass = true;
            }
        }
        // Look up for processing getter/setter pair as a single class property
        const visitedAccessors = new Map();
        const classMemberPaths = path.get('body.body');
        body.body.forEach((classMember, index$1) => {
            const classMemberPath = classMemberPaths[index$1];
            // Ignore all the unsupported class members by metadata gathering - eg. members with
            // computed names or private fields.
            if (!utils.isClassMember(classMember) || utils$1.isTrue(classMember.computed)) {
                return;
            }
            // Ignore all the class member where name can't be extracted.
            const memberName = utils.getClassMemberName(classMember);
            if (utils$1.isUndefined(memberName)) {
                return;
            }
            const doc = extractComment(classMember);
            const location = utils.generateSourceLocation(classMember);
            const decorators = index.gatherDecoratorMetadata(classMember, scope, state);
            if (utils.isClassPropertyOrAccessor(classMember)) {
                // if it is a data property
                if (t__namespace.isClassProperty(classMember)) {
                    const initialValue = classMember.value
                        ? resolver.resolveExpression(classMember.value, scope)
                        : {
                            type: 'Undefined',
                            value: undefined,
                        };
                    classMetadata.properties.push({
                        type: 'Property',
                        name: memberName,
                        propertyType: 'dataProperty',
                        dataProperty: {
                            initialValue,
                            location,
                        },
                        decorators,
                        static: classMember.static ?? false,
                        __internal__doc: doc,
                    });
                }
                else {
                    // else must be a setter or getter
                    // If this is the first time the property is being visited
                    let classPropertyMeta = visitedAccessors.get(memberName);
                    if (utils$1.isUndefined(classPropertyMeta)) {
                        classPropertyMeta = {
                            type: 'Property',
                            name: memberName,
                            propertyType: 'accessor',
                            decorators: [],
                            static: classMember.static ?? false,
                            __internal__doc: doc, // The first accessor with doc wins, keeping same behavior as v1
                        };
                        visitedAccessors.set(memberName, classPropertyMeta);
                        classMetadata.properties.push(classPropertyMeta);
                    }
                    if (classMember.kind === 'get') {
                        const initialValue = resolver.resolveMethodReturnValue(classMember, classMemberPath.scope);
                        classPropertyMeta.getter = {
                            initialValue,
                            location,
                        };
                    }
                    else {
                        classPropertyMeta.setter = {
                            location,
                        };
                    }
                    classPropertyMeta.decorators.push(...decorators);
                }
            }
            else {
                classMetadata.methods.push({
                    type: 'Method',
                    name: memberName,
                    location,
                    decorators,
                    __internal__doc: doc,
                });
            }
        });
        state.classLookup.set(path.node, classMetadata);
        state.classNodeLookup.set(classMetadata, path);
        result.classes.push(classMetadata);
    };
}

exports.default = visitorFunction;
//# sourceMappingURL=class-visitor.js.map

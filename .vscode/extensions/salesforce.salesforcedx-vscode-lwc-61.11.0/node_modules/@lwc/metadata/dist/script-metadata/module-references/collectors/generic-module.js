'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('@lwc/errors');
var utils$1 = require('../../../shared/utils.js');
var errors$1 = require('../../../errors/errors.js');
var resolver = require('../../resolver.js');
var utils = require('./utils.js');

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
const VALID_LWC_IDENTIFIERS_FOR_PLATFORM = new Set([
    'api',
    'LightningElement',
    'track',
    'unwrap',
    'wire',
]);
const VALID_LWC_IDENTIFIERS_FOR_INTERNAL = new Set([
    ...VALID_LWC_IDENTIFIERS_FOR_PLATFORM,
    'buildCustomElementConstructor',
    'createContextProvider',
    'createElement',
    'dangerousObjectMutation',
    'getComponentConstructor',
    'getComponentDef',
    'isComponentConstructor',
    'readonly',
    'register',
]);
function validateLwcReferences(node, state) {
    const diagnostics = [];
    let importedName;
    let validLwcIdentifiers;
    const { fileName, bundleType } = state;
    for (const specifier of node.specifiers) {
        const { loc, start } = specifier;
        const { start: { line, column }, } = loc;
        const location = {
            line,
            column,
            start: start,
        };
        switch (specifier.type) {
            // No default exports from 'lwc' module
            // No aliasing of imported properties from 'lwc' modules
            case 'ImportDefaultSpecifier':
            case 'ImportNamespaceSpecifier':
                diagnostics.push(errors.generateCompilerDiagnostic(errors$1.Errors.INVALID_LWC_IMPORT, {
                    origin: {
                        filename: fileName,
                        location,
                    },
                }));
                break;
            // Validate imported properties against allowed list based on bundle type
            case 'ImportSpecifier':
                importedName = resolver.resolveImportSpecifierImported(specifier.imported);
                validLwcIdentifiers =
                    bundleType === 'platform'
                        ? VALID_LWC_IDENTIFIERS_FOR_PLATFORM
                        : VALID_LWC_IDENTIFIERS_FOR_INTERNAL;
                if (!validLwcIdentifiers.has(importedName)) {
                    diagnostics.push(errors.generateCompilerDiagnostic(errors$1.Errors.INVALID_LWC_IMPORT_IDENTIFIER, {
                        messageArgs: [importedName],
                        origin: {
                            filename: fileName,
                            location,
                        },
                    }));
                }
                break;
        }
    }
    if (!utils$1.isEmpty(diagnostics)) {
        throw new errors$1.MetadataCollectionError(diagnostics);
    }
}
const genericModulesCollector = {
    matches: (value) => !utils.isSalesforceImport(value) && !utils.isRelativeImport(value),
    collect(value, node, state) {
        const isLwcModuleSpecifier = utils.isLwcReference(value);
        // Validate what bindings are imported from 'lwc'
        if (isLwcModuleSpecifier && node.type === 'ImportDeclaration') {
            validateLwcReferences(node, state);
        }
        return utils.getModuleReference(value, node.source, state, isLwcModuleSpecifier ? 'lwc' : 'external');
    },
};

exports.default = genericModulesCollector;
//# sourceMappingURL=generic-module.js.map

'use strict';

var utils = require('../../shared/utils.js');

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
/**
 * Extract key value pairs from an object expressions
 * @param expression ObjectExpression node that represents an object
 * @param defaults default key value pairs to be returned if no value specified in expression
 * @param unresolvedValue value to be used to mark unresolved object values
 * @param qualifiedProperties a set of keys that are to be extracted. if not specified, all keys are collected
 */
function extractObjectValue(expression, defaults = {}, qualifiedProperties) {
    // If object has a complex type property like a SpreadElement or a computed property, they cannot be analyzed.
    // Also, they can override properties previously defined.
    // Return no metadata in such cases.
    if (expression.properties.some((prop) => prop.type !== 'ObjectProperty' || utils.isTrue(prop.computed))) {
        return {};
    }
    // copy over the defaults, as they might be mutated later based on static analysis
    const options = utils.assign({}, defaults);
    const collectAllProperties = utils.isUndefined(qualifiedProperties);
    expression.properties.forEach((prop) => {
        if (prop.type === 'ObjectProperty') {
            let objectKey;
            // Gather only string literals, boolean value, treat the rest as unresolved. Can be built out later
            let objectValue = 'unresolved';
            const { key, value } = prop;
            switch (key.type) {
                case 'Identifier':
                    objectKey = key.name;
                    break;
                case 'StringLiteral':
                    objectKey = key.value;
                    break;
            }
            // any non boolean or string literal value will be considered 'unresolved'
            if (value.type === 'BooleanLiteral' || value.type === 'StringLiteral') {
                objectValue = value.value;
            }
            if (!utils.isUndefined(objectKey) &&
                (collectAllProperties || qualifiedProperties.has(objectKey))) {
                options[objectKey] = objectValue;
            }
        }
    });
    return options;
}
function coerceObjectValuesToBoolean(source) {
    const ret = {};
    utils.keys(source).forEach((key) => {
        const value = source[key];
        // do not coerce unresolved values
        ret[key] = value === 'unresolved' ? value : !!value;
    });
    return ret;
}

exports.coerceObjectValuesToBoolean = coerceObjectValuesToBoolean;
exports.extractObjectValue = extractObjectValue;
//# sourceMappingURL=util.js.map

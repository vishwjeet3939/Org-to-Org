'use strict';

var t = require('@babel/types');
var errors$1 = require('@lwc/errors');
var sfdcCompilerUtils = require('@lwc/sfdc-compiler-utils');
var utils = require('../../../shared/utils.js');
var errors = require('../../../errors/errors.js');
var utils$1 = require('../../utils.js');

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
const SALESFORCE_PREFIX = '@salesforce';
// additional prefixes
const SLASH_LENGTH = 1;
function isValidImportForPrefix(prefix, source) {
    return source.startsWith(prefix + '/');
}
function isSalesforceImport(value) {
    return value.startsWith(SALESFORCE_PREFIX);
}
// known modules
const LWC_REFERENCE_VALUE = 'lwc';
function isLwcReference(value) {
    return value === LWC_REFERENCE_VALUE;
}
const RELATIVE_IMPORT = '.';
const BACK_REF_IMPORT = '..';
const isRelativeImport = (source) => isValidImportForPrefix(RELATIVE_IMPORT, source) ||
    isValidImportForPrefix(BACK_REF_IMPORT, source);
function createReferenceDiagnostic(sourceNode, fileName, errorInfo, messageArgs) {
    return errors$1.generateCompilerDiagnostic(errorInfo, {
        messageArgs,
        origin: {
            filename: fileName,
            location: {
                line: sourceNode.loc.start.line,
                column: sourceNode.loc.start.column,
                start: sourceNode.start,
                length: sourceNode.value?.length,
            },
        },
    });
}
function getModuleReference(moduleSpecifier, sourceNode, state, referenceType) {
    const { fileName, namespaceMapping } = state;
    if (utils.isEmpty(moduleSpecifier)) {
        throw new errors.MetadataCollectionError([
            createReferenceDiagnostic(sourceNode, fileName, errors.Errors.MISSING_RESOURCE_VALUE, [
                moduleSpecifier,
            ]),
        ]);
    }
    const ref = {
        name: moduleSpecifier,
        type: referenceType,
        locations: [utils$1.generateSourceLocation(sourceNode, utils$1.QUOTE_LENGTH, utils$1.QUOTE_LENGTH)],
        id: state.generateReferenceId('ModuleReference', moduleSpecifier),
    };
    const namespacedModuleSpecifier = !utils.isEmptyObject(namespaceMapping)
        ? sfdcCompilerUtils.getNamespacedIdForResource(moduleSpecifier, namespaceMapping)
        : undefined;
    if (!utils.isUndefined(namespacedModuleSpecifier)) {
        ref.namespacedName = namespacedModuleSpecifier;
    }
    return ref;
}
function assertOnlyDefaultImport(node, fileName, prefix) {
    const hasNamedImport = node.type === 'ImportDeclaration' &&
        node.specifiers.some((node) => !t__namespace.isImportDefaultSpecifier(node));
    const source = node.source;
    // generate error for imports only, as this is a valid scenario for re-export
    if (node.type === 'ImportDeclaration' && hasNamedImport) {
        throw new errors.MetadataCollectionError([
            errors$1.generateCompilerDiagnostic(errors.Errors.MODULES_ONLY_SUPPORT_DEFAULT_IMPORTS, {
                messageArgs: [prefix],
                origin: {
                    filename: fileName,
                    location: {
                        line: source.loc.start.line,
                        column: source.loc.start.column,
                        start: source.start,
                        length: source.value.length,
                    },
                },
            }),
        ]);
    }
}
function getId(prefix, moduleSpecifier) {
    return moduleSpecifier && moduleSpecifier.substring(prefix.length + SLASH_LENGTH);
}
function createNamespacedId(value, namespaceMapping) {
    let namespacedId = sfdcCompilerUtils.getNamespacedIdForResource(value, namespaceMapping);
    // @salesforce resources id is the the last part of the resource
    // @salesforce/label/c.key ---> c.key is the id
    if (value.startsWith(SALESFORCE_PREFIX) && namespacedId) {
        namespacedId = namespacedId.split('/').pop();
    }
    return namespacedId;
}
function generateSalesforceReference(sourceNode, moduleSpecifier, scoped, id, namespaceMapping, state) {
    const ref = {
        name: moduleSpecifier,
        type: '@salesforce',
        locations: [utils$1.generateSourceLocation(sourceNode, utils$1.QUOTE_LENGTH, utils$1.QUOTE_LENGTH)],
        id: state.generateReferenceId('ModuleReference', moduleSpecifier),
    };
    ref.sfdcResource = {
        scoped: scoped,
        id,
    };
    const namespacedId = createNamespacedId(moduleSpecifier, namespaceMapping);
    if (!utils.isUndefined(namespacedId)) {
        ref.sfdcResource.namespacedId = namespacedId;
    }
    return ref;
}
function createSalesforceModuleCollector(config) {
    const prefix = `@salesforce/${config.name}`;
    const allowedImports = config.allowlist
        ? new Set(config.allowlist.map((x) => `${prefix}/${x}`))
        : null;
    return {
        matches(value) {
            return value.startsWith(`${prefix}/`);
        },
        collect(value, node, state) {
            const source = node.source;
            const { fileName, namespaceMapping } = state;
            // Check if the import is part of the allow list (if provided).
            if (allowedImports && !allowedImports.has(value)) {
                throw new errors.MetadataCollectionError([
                    createReferenceDiagnostic(node.source, state.fileName, errors.Errors.INVALID_MODULE_ID, [value]),
                ]);
            }
            assertOnlyDefaultImport(node, fileName, prefix);
            const id = getId(prefix, value);
            if (utils.isEmpty(id)) {
                throw new errors.MetadataCollectionError([
                    createReferenceDiagnostic(source, fileName, errors.Errors.MISSING_RESOURCE_VALUE, [
                        value,
                    ]),
                ]);
            }
            return generateSalesforceReference(source, value, config.name, id, namespaceMapping, state);
        },
    };
}

exports.SALESFORCE_PREFIX = SALESFORCE_PREFIX;
exports.assertOnlyDefaultImport = assertOnlyDefaultImport;
exports.createReferenceDiagnostic = createReferenceDiagnostic;
exports.createSalesforceModuleCollector = createSalesforceModuleCollector;
exports.generateSalesforceReference = generateSalesforceReference;
exports.getId = getId;
exports.getModuleReference = getModuleReference;
exports.isLwcReference = isLwcReference;
exports.isRelativeImport = isRelativeImport;
exports.isSalesforceImport = isSalesforceImport;
exports.isValidImportForPrefix = isValidImportForPrefix;
//# sourceMappingURL=utils.js.map

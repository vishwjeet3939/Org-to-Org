import { Scope } from '@babel/traverse';
import * as t from '@babel/types';
import { UnresolvedValue, Value } from '../schema/typescript-types/script-metadata-types';
export declare function unresolved(): UnresolvedValue;
export declare function resolveImportSpecifierImported(imported: t.ImportSpecifier['imported']): string;
export declare function resolveExportSpecifierExported(imported: t.ExportSpecifier['exported']): string;
/**
 * Resolve an expression to a Value.
 * @param expression expression to resolve
 * @param scope scope in which the expression was found
 * @param unresolvedIdentifiers  To detect ciruclar reference in identifiers
 * @returns Resolved value
 */
export declare function resolveExpression(expression: t.Expression, scope: Scope, unresolvedIdentifiers?: Set<t.Identifier>): Value;
/**
 * Return value resolution will be returned only if the code block contains a single return statement
 * and no other statements, except for ExpressionStatement or declarations. Such limitation is
 * enforced to eliminate return value ambiguity in a multi-statement code blocks and reduce complexity.
 *
 * For ex, multiple return statements that are nested inside other statements, such as 'if', 'for',
 * etc, can be very difficult and non-performant to locate. Therefore, we look for a return
 * statement in the immediate scope and ensure no other statements exist.
 */
export declare function resolveMethodReturnValue(methodNode: t.ClassMethod, scope: Scope): Value;

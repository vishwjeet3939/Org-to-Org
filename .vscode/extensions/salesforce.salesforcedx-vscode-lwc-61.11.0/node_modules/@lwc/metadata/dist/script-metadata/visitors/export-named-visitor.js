'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors$1 = require('@lwc/errors');
var utils$1 = require('../utils.js');
var utils = require('../../shared/utils.js');
var reference = require('../module-references/reference.js');
var errors = require('../../errors/errors.js');
var resolver = require('../resolver.js');

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
function collectReexports(state, result, path) {
    const { node } = path;
    const source = node.source;
    const loc = node.loc;
    const { value: moduleSpecifier } = source;
    const moduleReference = reference.gatherModuleReference(node, state, result);
    const namedExports = node.specifiers.map((specifier) => {
        const { exported } = specifier;
        switch (specifier.type) {
            // export { default } from 'module-specifier';
            // export { name1, name2, name3 } from 'module-specifier'
            // export { name1, name2, name3 } from 'module-specifier'
            // export { default as tibuku } from 'module-specifier';
            case 'ExportSpecifier':
                return {
                    localName: specifier.local.name,
                    exportedName: resolver.resolveExportSpecifierExported(exported),
                    location: utils$1.generateSourceLocation(specifier),
                };
            // export * as baz from 'module-specifier';
            case 'ExportNamespaceSpecifier':
                return {
                    localName: '*',
                    exportedName: resolver.resolveExportSpecifierExported(exported),
                    location: utils$1.generateSourceLocation(specifier),
                };
            case 'ExportDefaultSpecifier':
                throw new errors.MetadataCollectionError([
                    errors$1.generateCompilerDiagnostic(errors.Errors.UNSUPPORTED_SCRIPT_SYNTAX, {
                        messageArgs: [state.fileName],
                        origin: {
                            filename: state.fileName,
                            location: {
                                line: loc.start.line,
                                column: loc.start.column,
                                start: node.start,
                            },
                        },
                    }),
                ]);
        }
    });
    result.exports.push({
        moduleSpecifier,
        refId: moduleReference.id,
        location: utils$1.generateSourceLocation(node),
        namedExports,
    });
}
function collectExports(result, node) {
    const { declaration, specifiers } = node;
    const namedExports = [];
    // Will only attempt to gather metadata about function declarations, class declarations and variables exported
    if (!utils.isEmpty(specifiers)) {
        // export { variable1 as name1, variable2 as name2, …, nameN };
        // export { name1, name2, …, nameN };
        specifiers.forEach((specifier) => {
            if (specifier.type === 'ExportSpecifier') {
                namedExports.push({
                    localName: specifier.local.name,
                    exportedName: resolver.resolveExportSpecifierExported(specifier.exported),
                    location: utils$1.generateSourceLocation(specifier),
                });
            }
        });
    }
    else if (!utils.isNull(declaration) && !utils.isUndefined(declaration)) {
        if (declaration.type === 'FunctionDeclaration') {
            namedExports.push({
                // A function declaration on a named export will always have an id
                exportedName: declaration.id.name,
                location: utils$1.generateSourceLocation(declaration),
            });
        }
        else if (declaration.type === 'ClassDeclaration') {
            namedExports.push({
                exportedName: declaration.id?.name,
                location: utils$1.generateSourceLocation(declaration),
            });
        }
        else if (declaration.type === 'VariableDeclaration') {
            const { declarations } = declaration;
            declarations.forEach((variableDeclaration) => {
                if (variableDeclaration.id.type === 'Identifier') {
                    namedExports.push({
                        exportedName: variableDeclaration.id.name,
                        location: utils$1.generateSourceLocation(declaration),
                    });
                }
            });
        }
    }
    result.exports.push({
        location: utils$1.generateSourceLocation(node),
        namedExports,
    });
}
function visitorFunction(state, result) {
    return function ExportNamedDeclarationVisitorFunction(path) {
        const { source } = path.node;
        // Exporting bindings which are local to the current module
        if (utils.isNull(source)) {
            collectExports(result, path.node);
        }
        else {
            // Exporting bindings from an external module
            collectReexports(state, result, path);
        }
    };
}

exports.default = visitorFunction;
//# sourceMappingURL=export-named-visitor.js.map

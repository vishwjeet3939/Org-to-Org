'use strict';

var t = require('@babel/types');
var errors$1 = require('@lwc/errors');
var errors = require('../../errors/errors.js');
var utils = require('../../shared/utils.js');
var resolver = require('../resolver.js');
var utils$1 = require('../utils.js');

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
const WIRE_REACTIVE_PROP_PREFIX = '$';
function gatherWireDecoratorMetadata(decoratorNode, scope, state) {
    const expression = decoratorNode.expression;
    const [adapter, adapterConfig] = expression.arguments;
    const wireDecoratorMeta = {
        type: 'Wire',
        location: utils$1.generateSourceLocation(decoratorNode),
        adapterId: {
            importedName: 'unresolved',
            localName: 'unresolved',
            location: utils$1.generateSourceLocation(adapter || decoratorNode),
        },
        adapterModule: 'unresolved',
    };
    if (t__namespace.isIdentifier(adapter)) {
        const binding = scope.getBinding(adapter.name);
        wireDecoratorMeta.adapterId.localName = adapter.name;
        if (!utils.isUndefined(binding)) {
            const path = binding.path;
            // binding identifier loc refers to original import not the adapterId
            if (t__namespace.isImportDeclaration(path.parent)) {
                if (t__namespace.isImportSpecifier(path.node)) {
                    // Gather the imported name of the import specifier and not the local name
                    // Example: import { getRecord as getRecordAlias } from 'lightning/uiRecordApi';
                    // adapterId will be 'getRecord'
                    wireDecoratorMeta.adapterId.importedName = resolver.resolveImportSpecifierImported(path.node.imported);
                    wireDecoratorMeta.adapterModule = path.parent.source.value;
                }
                else if (t__namespace.isImportDefaultSpecifier(path.node)) {
                    // Example: import getContactList from '@salesforce/apex/ContactController.getContactList';
                    //          @wire(getContactList)
                    wireDecoratorMeta.adapterId.importedName = 'default';
                    wireDecoratorMeta.adapterModule = path.parent.source.value;
                }
                // Adapter IDs cannot be a namespaced import
            }
        }
    }
    if (adapterConfig !== undefined) {
        if (t__namespace.isObjectExpression(adapterConfig)) {
            const reactiveProps = {};
            const staticProps = {};
            adapterConfig.properties.forEach((prop) => {
                if (!t__namespace.isObjectProperty(prop) || !t__namespace.isIdentifier(prop.key) || prop.computed) {
                    return;
                }
                const { key, value } = prop;
                const keyLoc = utils$1.generateSourceLocation(key);
                const valueLoc = utils$1.generateSourceLocation(value);
                // Only consider object property and when the property key is an identifier skip
                // spread element and object methods.
                if (t__namespace.isStringLiteral(value) && value.value.startsWith(WIRE_REACTIVE_PROP_PREFIX)) {
                    // Collect metadata about adapterConfig fields that are mapped to a reactive
                    // field - eg. @wire(getRecord, { recordId: '$recordId'})
                    reactiveProps[key.name] = {
                        keyLocation: keyLoc,
                        classProperty: value.value.slice(1),
                        valueLocation: valueLoc,
                    };
                }
                else if (t__namespace.isExpression(value)) {
                    staticProps[key.name] = {
                        keyLocation: keyLoc,
                        value: resolver.resolveExpression(value, scope),
                        valueLocation: valueLoc,
                    };
                }
            });
            wireDecoratorMeta.adapterConfig = {
                reactive: reactiveProps,
                static: staticProps,
            };
        }
        else {
            throw new errors.MetadataCollectionError([
                errors$1.generateCompilerDiagnostic(errors.Errors.INVALID_WIRE_CONFIG_USAGE, {
                    messageArgs: [],
                    origin: {
                        filename: state.fileName,
                        location: {
                            line: adapterConfig.loc.start.line,
                            column: adapterConfig.loc.start.column,
                            start: adapterConfig.start,
                        },
                    },
                }),
            ]);
        }
    }
    return wireDecoratorMeta;
}
function gatherDecoratorMetadata(classMember, scope, state) {
    const decoratorMeta = [];
    const decoratorNodes = classMember.decorators;
    if (!utils.isNull(decoratorNodes) && !utils.isUndefined(decoratorNodes)) {
        decoratorNodes.forEach((decorator) => {
            const { expression } = decorator;
            let name;
            if (t__namespace.isIdentifier(expression)) {
                name = expression.name;
            }
            else if (t__namespace.isCallExpression(expression) && t__namespace.isIdentifier(expression.callee)) {
                name = expression.callee.name;
            }
            switch (name) {
                case 'api':
                    if (!t__namespace.isIdentifier(expression)) {
                        throw generateDecoratorUsageError(decorator, errors.Errors.INVALID_API_USAGE, state);
                    }
                    decoratorMeta.push({
                        type: 'Api',
                        location: utils$1.generateSourceLocation(decorator),
                    });
                    break;
                case 'track':
                    if (!t__namespace.isIdentifier(expression)) {
                        throw generateDecoratorUsageError(decorator, errors.Errors.INVALID_TRACK_USAGE, state);
                    }
                    decoratorMeta.push({
                        type: 'Track',
                        location: utils$1.generateSourceLocation(decorator),
                    });
                    break;
                case 'wire':
                    if (!t__namespace.isCallExpression(expression)) {
                        throw generateDecoratorUsageError(decorator, errors.Errors.INVALID_WIRE_USAGE, state);
                    }
                    decoratorMeta.push(gatherWireDecoratorMetadata(decorator, scope, state));
                    break;
            }
        });
    }
    return decoratorMeta;
}
function generateDecoratorUsageError(decoratorNode, errorInfo, state) {
    return new errors.MetadataCollectionError([
        errors$1.generateCompilerDiagnostic(errorInfo, {
            messageArgs: [],
            origin: {
                filename: state.fileName,
                location: {
                    line: decoratorNode.loc.start.line,
                    column: decoratorNode.loc.start.column,
                    start: decoratorNode.start,
                },
            },
        }),
    ]);
}

exports.gatherDecoratorMetadata = gatherDecoratorMetadata;
//# sourceMappingURL=index.js.map

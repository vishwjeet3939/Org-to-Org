'use strict';

var sfdcCompilerUtils = require('@lwc/sfdc-compiler-utils');
var templateCompiler = require('@lwc/template-compiler');
var errors = require('@lwc/errors');
var errors$1 = require('../errors/errors.js');
var utils = require('../shared/utils.js');
require('@babel/types');
var analyzeTemplateFile = require('../dependency-analyzer/analyzeTemplateFile.js');

// Copyright (c) 2022, Salesforce, Inc.,
// All rights reserved.
// For full license text, see the LICENSE.txt file
// Template metadata collection should collect all possible metadata by enabling all available features.
// The lwc compiler will enforce whether a feature is to be enabled. That is not the perogative of the
// metadata collector.
const PARSE_DEFAULT_CONFIG = {
    // TODO W-12607866 - remove lwc:dynamic usage in 246
    experimentalDynamicDirective: true,
    enableDynamicComponents: true,
};
function generateEmptyResult(fileName) {
    return {
        fileType: 'html',
        fileName,
        componentReferences: [],
        diagnostics: [],
    };
}
function collectTemplateMetadataFromSource(fileName, source, config) {
    let parseResult;
    const emptyResult = generateEmptyResult(fileName);
    let parseWarnings;
    try {
        parseResult = templateCompiler.parse(source, {
            ...PARSE_DEFAULT_CONFIG,
            // Enabling template expressions changes AST shape due to usage to introduction of ComplexExpression nodes
            // Keeping it disabled by default
            experimentalComplexExpressions: config.experimentalComplexExpressions ?? false,
        });
        // Diagnostic from @lwc/template-compiler parse() does not have a filename
        parseWarnings = parseResult.warnings.map((warning) => {
            warning.filename = fileName;
            return warning;
        });
        // Produce empty result with diagnostics only if there are fatals and errors
        const hasParseErrors = parseWarnings.some((warning) => warning.level === errors.DiagnosticLevel.Fatal || warning.level === errors.DiagnosticLevel.Error);
        if (utils.isUndefined(parseResult.root) || hasParseErrors) {
            emptyResult.diagnostics = parseWarnings;
            return emptyResult;
        }
    }
    catch (e) {
        emptyResult.diagnostics.push(errors.generateCompilerDiagnostic(errors$1.Errors.SYNTAX_ERROR, {
            messageArgs: [fileName, e.message],
            origin: {
                filename: fileName,
            },
        }));
        return emptyResult;
    }
    const collectionResult = collectTemplateMetadataFromAST(fileName, parseResult.root, config.namespaceMapping);
    collectionResult.diagnostics.push(...parseWarnings);
    if (config.enableKomaci) {
        collectionResult.komaciDoc = analyzeTemplateFile.generateKomaciDocFromTemplate(collectionResult);
    }
    if (collectionResult.ast) {
        trimLocationFromAst(collectionResult.ast);
    }
    return collectionResult;
}
// Preorder traversal to strip location information from @lwc/template-compiler AST.
// This is needed for ADG only to reduce the memory footprint in prod.
// TODO: Once ADG has been replaced by Komaci remove trimLocationFromAst
function trimLocationFromAst(tmplAstNode) {
    // There is validation in the metadata-v2tov1-adapter which relies on location information
    // TODO: Once metadata v2 has replaced v1 isPreservedLocationNode should be removed.
    if (!isPreservedLocationNode(tmplAstNode)) {
        if (tmplAstNode.location) {
            // Set the location to undefined rather than use the delete operator as a JS optimization.
            tmplAstNode.location = undefined;
        }
        if (tmplAstNode.directiveLocation) {
            tmplAstNode.directiveLocation = undefined;
        }
    }
    for (const key of Object.keys(tmplAstNode)) {
        const value = tmplAstNode[key];
        if (value !== null && typeof value === 'object') {
            if (Array.isArray(value)) {
                for (const item of value) {
                    // With the introduction of ComplexExpression nodes for template expressions,
                    // item cannot be assumed to be a node, duck type to check if it looks like a base node
                    // for example, Acorn's MemberExpression.range is an array of integers
                    if (item !== null && typeof item === 'object' && 'type' in item) {
                        trimLocationFromAst(item);
                    }
                }
            }
            else {
                trimLocationFromAst(value);
            }
        }
    }
}
function isPreservedLocationNode(node) {
    if ('name' in node) {
        return (node.name === 'InnerHTML' || node.name === 'Dynamic' || node.name === 'lwc:component');
    }
    return false;
}
function isRenderModeDirective(directive) {
    return directive.name === 'RenderMode';
}
function collectTemplateMetadataFromAST(fileName, root, namespaceMapping) {
    const result = generateEmptyResult(fileName);
    const uniqueReferences = new Map();
    // Iterate over all the component references and deduplicate them. Add missing references to the
    // map. If the reference is already present in the map, append the location to the existing
    // entry.
    for (const reference of collectComponentReferences(root, namespaceMapping)) {
        const existingReference = uniqueReferences.get(reference.name);
        if (existingReference) {
            existingReference.locations.push(...reference.locations);
        }
        else {
            uniqueReferences.set(reference.name, reference);
        }
    }
    result.ast = root;
    result.componentReferences = Array.from(uniqueReferences.values());
    result.renderMode = root.directives.find(isRenderModeDirective)?.value.value ?? 'shadow';
    return result;
}
function* collectComponentReferences(node, namespaceMapping) {
    if (node.type === 'Component') {
        const ref = getComponentReference(node, namespaceMapping);
        if (ref) {
            yield ref;
        }
    }
    for (const child of node.children) {
        if (child.type !== 'Comment' && child.type !== 'Text') {
            yield* collectComponentReferences(child, namespaceMapping);
        }
    }
    // lwc:if and lwc:elseif have more nodes in their else branch
    if ((node.type === 'IfBlock' || node.type === 'ElseifBlock') && !utils.isUndefined(node.else)) {
        yield* collectComponentReferences(node.else, namespaceMapping);
    }
}
function getComponentReference(node, namespaceMapping) {
    const { name: tagName, directives, location: { startTag, endTag }, } = node;
    // TODO W-12607866 - remove lwc:dynamic usage in 246
    // Ignore dynamic components.
    if (directives.find((directive) => directive.name === 'Dynamic')) {
        return;
    }
    const name = utils.tagNameToComponentName(tagName);
    // The component reference location refers to the actual tag name string location in the
    // source and not the entire opening an closing tag location. In the opening tag location, we
    // need to add `1` account for the `<` and `2` for the `</` in the closing tag.
    //
    // Note: The compiler ensures that a component are not void elements, so such an element will
    // always have an `endTag`.
    const locations = [
        {
            start: startTag.start + 1,
            startLine: startTag.startLine,
            startColumn: startTag.startColumn + 1,
            end: startTag.end - 1,
            endLine: startTag.startLine,
            endColumn: startTag.startColumn + 1 + tagName.length,
        },
        {
            start: endTag.start + 2,
            startLine: endTag.startLine,
            startColumn: endTag.startColumn + 2,
            end: endTag.end - 1,
            endLine: endTag.startLine,
            endColumn: endTag.startColumn + 2 + tagName.length,
        },
    ];
    const ref = {
        type: 'external',
        name,
        tagName,
        locations,
    };
    const namespacedName = sfdcCompilerUtils.getNamespacedIdForResource(name, namespaceMapping);
    if (namespacedName) {
        ref.namespacedName = namespacedName;
    }
    return ref;
}

exports.collectTemplateMetadataFromSource = collectTemplateMetadataFromSource;
//# sourceMappingURL=index.js.map

/* proxy-compat-disable */
/**
 * Copyright (C) 2023 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('@lwc/errors');
var shared = require('@lwc/shared');
var parse5 = require('parse5');
var he = require('he');
var estreeWalker = require('estree-walker');
var acorn = require('acorn');
var Parser = require('parse5/lib/parser');
var Tokenizer = require('parse5/lib/tokenizer');
var astring = require('astring');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var parse5__namespace = /*#__PURE__*/_interopNamespaceDefault(parse5);
var he__namespace = /*#__PURE__*/_interopNamespaceDefault(he);
var astring__namespace = /*#__PURE__*/_interopNamespaceDefault(astring);

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
class State {
    constructor(config) {
        var _a;
        this.config = config;
        this.crElmToConfigMap = config.customRendererConfig
            ? Object.fromEntries(config.customRendererConfig.elements.map((element) => {
                const { tagName, attributes, namespace } = element;
                return [tagName, { namespace, attributes: new Set(attributes) }];
            }))
            : {};
        this.crDirectives = new Set((_a = config.customRendererConfig) === null || _a === void 0 ? void 0 : _a.directives);
        this.crCheckedElements = new Map();
    }
}

const SECURE_REGISTER_TEMPLATE_METHOD_NAME = 'registerTemplate';
const PARSE_FRAGMENT_METHOD_NAME = 'parseFragment';
const PARSE_SVG_FRAGMENT_METHOD_NAME = 'parseSVGFragment';
const RENDERER = 'renderer';
const LWC_MODULE_NAME = 'lwc';
const TEMPLATE_FUNCTION_NAME = 'tmpl';
const TEMPLATE_PARAMS = {
    INSTANCE: '$cmp',
    API: '$api',
    SLOT_SET: '$slotset',
    CONTEXT: '$ctx',
};
const DASHED_TAGNAME_ELEMENT_SET = new Set([
    'annotation-xml',
    'color-profile',
    'font-face',
    'font-face-src',
    'font-face-uri',
    'font-face-format',
    'font-face-name',
    'missing-glyph',
]);
// Subset of LWC template directives that can safely be statically optimized
const STATIC_SAFE_DIRECTIVES = new Set(['Ref']);

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function toPropertyName(attr) {
    let prop = '';
    let shouldUpperCaseNext = false;
    for (let i = 0; i < attr.length; i++) {
        const char = attr.charAt(i);
        if (char === '-') {
            shouldUpperCaseNext = true;
        }
        else {
            prop += shouldUpperCaseNext ? char.toUpperCase() : char;
            shouldUpperCaseNext = false;
        }
    }
    return prop;
}
/**
 * Test if given tag name is a custom element.
 * @param tagName element tag name to test
 * @returns true if given tag name represents a custom element, false otherwise.
 */
function isCustomElementTag(tagName) {
    return tagName.includes('-') && !DASHED_TAGNAME_ELEMENT_SET.has(tagName);
}
/**
 * Test if given tag name is a custom LWC tag denoted lwc:*.
 * @param tagName element tag name to test
 * @returns true if given tag name represents a custom LWC tag, false otherwise.
 */
function isLwcElementTag(tagName) {
    return tagName.startsWith('lwc:');
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const AVAILABLE_OPTION_NAMES = new Set([
    'customRendererConfig',
    'enableLwcSpread',
    'enableStaticContentOptimization',
    // TODO [#3370]: remove experimental template expression flag
    'experimentalComplexExpressions',
    'experimentalComputedMemberExpression',
    'experimentalDynamicDirective',
    'enableDynamicComponents',
    'preserveHtmlComments',
    'instrumentation',
]);
function normalizeCustomRendererConfig(config) {
    const tagNames = [];
    const normalizedConfig = {
        elements: config.elements.map((e) => {
            var _a, _b;
            const tagName = e.tagName.toLowerCase();
            // Custom element cannot be allowed to have a custom renderer hook
            // The renderer is cascaded down from the owner(custom element) to all its child nodes who
            // do not have a renderer specified.
            errors.invariant(!isCustomElementTag(tagName), errors.TemplateErrors.CUSTOM_ELEMENT_TAG_DISALLOWED, [
                e.tagName,
            ]);
            tagNames.push(tagName);
            return {
                tagName,
                namespace: (_a = e.namespace) === null || _a === void 0 ? void 0 : _a.toLowerCase(),
                attributes: (_b = e.attributes) === null || _b === void 0 ? void 0 : _b.map((a) => a.toLowerCase()),
            };
        }),
        directives: config.directives.map((d) => d.toLowerCase()),
    };
    // Check for duplicate tag names
    const dupTagNames = tagNames.filter((item, index) => index !== tagNames.indexOf(item));
    errors.invariant(dupTagNames.length == 0, errors.TemplateErrors.DUPLICATE_ELEMENT_ENTRY, [
        dupTagNames.join(', '),
    ]);
    return normalizedConfig;
}
function normalizeConfig(config) {
    errors.invariant(config !== undefined && typeof config === 'object', errors.TemplateErrors.OPTIONS_MUST_BE_OBJECT);
    const customRendererConfig = config.customRendererConfig
        ? normalizeCustomRendererConfig(config.customRendererConfig)
        : undefined;
    const instrumentation = config.instrumentation || undefined;
    for (const property in config) {
        if (!AVAILABLE_OPTION_NAMES.has(property) && shared.hasOwnProperty.call(config, property)) {
            throw errors.generateCompilerError(errors.TemplateErrors.UNKNOWN_OPTION_PROPERTY, {
                messageArgs: [property],
            });
        }
    }
    return Object.assign(Object.assign(Object.assign({ preserveHtmlComments: false, experimentalComputedMemberExpression: false, 
        // TODO [#3370]: remove experimental template expression flag
        experimentalComplexExpressions: false, experimentalDynamicDirective: false, enableDynamicComponents: false, enableStaticContentOptimization: true, enableLwcSpread: true }, config), { customRendererConfig }), { instrumentation });
}

function isIdentifier(node) {
    return node.type === 'Identifier';
}
function isMemberExpression(node) {
    return node.type === 'MemberExpression';
}
function isArrayExpression(node) {
    return node.type === 'ArrayExpression';
}
function isObjectExpression(node) {
    return node.type === 'ObjectExpression';
}
function isProperty$1(node) {
    return node.type === 'Property';
}
function isArrowFunctionExpression(node) {
    return node.type === 'ArrowFunctionExpression';
}
function isObjectPattern(node) {
    return node.type === 'ObjectPattern';
}
function isArrayPattern(node) {
    return node.type === 'ArrayPattern';
}
function isRestElement(node) {
    return node.type === 'RestElement';
}
function isAssignmentPattern(node) {
    return node.type === 'AssigmentPattern';
}
function isUnaryExpression(node) {
    return node.type === 'UnaryExpression';
}
function identifier(name, config) {
    return Object.assign({ type: 'Identifier', name }, config);
}
function isLiteral(node) {
    return node.type === 'Literal';
}
function memberExpression(object, property, config) {
    return Object.assign({ type: 'MemberExpression', object,
        property, computed: false, optional: false }, config);
}
function callExpression(callee, args, config) {
    return Object.assign({ type: 'CallExpression', callee, arguments: args, optional: false }, config);
}
function literal$1(value, config) {
    return Object.assign({ type: 'Literal', value }, config);
}
function conditionalExpression(test, consequent, alternate, config) {
    return Object.assign({ type: 'ConditionalExpression', test,
        consequent,
        alternate }, config);
}
function unaryExpression(operator, argument, config) {
    return Object.assign({ type: 'UnaryExpression', argument,
        operator, prefix: true }, config);
}
function binaryExpression(operator, left, right, config) {
    return Object.assign({ type: 'BinaryExpression', left,
        operator,
        right }, config);
}
function logicalExpression(operator, left, right, config) {
    return Object.assign({ type: 'LogicalExpression', operator,
        left,
        right }, config);
}
function assignmentExpression(operator, left, right, config) {
    return Object.assign({ type: 'AssignmentExpression', operator,
        left,
        right }, config);
}
function property$1(key, value, config) {
    return Object.assign({ type: 'Property', key,
        value, kind: 'init', computed: false, method: false, shorthand: false }, config);
}
function assignmentProperty(key, value, config) {
    return Object.assign({ type: 'Property', key,
        value, kind: 'init', computed: false, method: false, shorthand: false }, config);
}
function objectExpression(properties, config) {
    return Object.assign({ type: 'ObjectExpression', properties }, config);
}
function objectPattern(properties, config) {
    return Object.assign({ type: 'ObjectPattern', properties }, config);
}
function arrayExpression(elements, config) {
    return Object.assign({ type: 'ArrayExpression', elements }, config);
}
function expressionStatement(expression, config) {
    return Object.assign({ type: 'ExpressionStatement', expression }, config);
}
function taggedTemplateExpression(tag, quasi) {
    return {
        type: 'TaggedTemplateExpression',
        tag,
        quasi,
    };
}
function templateLiteral(quasis, expressions) {
    return {
        type: 'TemplateLiteral',
        quasis,
        expressions,
    };
}
function functionExpression(id, params, body, config) {
    return Object.assign({ type: 'FunctionExpression', id,
        params,
        body }, config);
}
function functionDeclaration(id, params, body, config) {
    return Object.assign({ type: 'FunctionDeclaration', id,
        params,
        body }, config);
}
function blockStatement(body, config) {
    return Object.assign({ type: 'BlockStatement', body }, config);
}
function returnStatement(argument, config) {
    return Object.assign({ type: 'ReturnStatement', argument }, config);
}
function variableDeclarator(id, init, config) {
    return Object.assign({ type: 'VariableDeclarator', id,
        init }, config);
}
function variableDeclaration(kind, declarations, config) {
    return Object.assign({ type: 'VariableDeclaration', kind,
        declarations }, config);
}
function importDeclaration(specifiers, source, config) {
    return Object.assign({ type: 'ImportDeclaration', specifiers,
        source }, config);
}
function importDefaultSpecifier(local, config) {
    return Object.assign({ type: 'ImportDefaultSpecifier', local }, config);
}
function importSpecifier(imported, local, config) {
    return Object.assign({ type: 'ImportSpecifier', imported,
        local }, config);
}
function exportDefaultDeclaration(declaration, config) {
    return Object.assign({ type: 'ExportDefaultDeclaration', declaration }, config);
}
function program(body, config) {
    return Object.assign({ type: 'Program', sourceType: 'module', body }, config);
}
function comment$1(content) {
    return {
        type: 'Block',
        value: content,
    };
}

function isElementNode(node) {
    return 'tagName' in node;
}
function isCommentNode(node) {
    return node.nodeName === '#comment';
}
function isTextNode(node) {
    return node.nodeName === '#text';
}
function getTemplateContent(templateElement) {
    return templateElement.content;
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function root(parse5ElmLocation) {
    return {
        type: 'Root',
        location: elementSourceLocation(parse5ElmLocation),
        directives: [],
        children: [],
    };
}
function element(tagName, namespaceURI, parse5ElmLocation) {
    return {
        type: 'Element',
        name: tagName,
        namespace: namespaceURI,
        location: elementSourceLocation(parse5ElmLocation),
        attributes: [],
        properties: [],
        directives: [],
        listeners: [],
        children: [],
    };
}
function externalComponent(tagName, parse5ElmLocation) {
    return {
        type: 'ExternalComponent',
        name: tagName,
        namespace: shared.HTML_NAMESPACE,
        location: elementSourceLocation(parse5ElmLocation),
        attributes: [],
        properties: [],
        directives: [],
        listeners: [],
        children: [],
    };
}
function component(tagName, parse5ElmLocation) {
    return {
        type: 'Component',
        name: tagName,
        namespace: shared.HTML_NAMESPACE,
        location: elementSourceLocation(parse5ElmLocation),
        attributes: [],
        properties: [],
        directives: [],
        listeners: [],
        children: [],
    };
}
function lwcComponent(tagName, parse5ElmLocation) {
    return {
        type: 'Lwc',
        name: tagName,
        namespace: shared.HTML_NAMESPACE,
        location: elementSourceLocation(parse5ElmLocation),
        attributes: [],
        properties: [],
        directives: [],
        listeners: [],
        children: [],
    };
}
function slot(slotName, parse5ElmLocation) {
    return {
        type: 'Slot',
        name: 'slot',
        namespace: shared.HTML_NAMESPACE,
        slotName,
        location: elementSourceLocation(parse5ElmLocation),
        attributes: [],
        properties: [],
        directives: [],
        listeners: [],
        children: [],
    };
}
function text(raw, 
// TODO [#3370]: remove experimental template expression flag
value, parse5Location) {
    return {
        type: 'Text',
        raw,
        value,
        location: sourceLocation(parse5Location),
    };
}
function comment(raw, value, parse5Location) {
    return {
        type: 'Comment',
        raw,
        value,
        location: sourceLocation(parse5Location),
    };
}
function elementSourceLocation(parse5ElmLocation) {
    const elementLocation = sourceLocation(parse5ElmLocation);
    const startTag = sourceLocation(parse5ElmLocation.startTag);
    // endTag must be optional because Parse5 currently fails to collect end tag location for element with a tag name
    // containing an upper case character (inikulin/parse5#352).
    const endTag = parse5ElmLocation.endTag
        ? sourceLocation(parse5ElmLocation.endTag)
        : parse5ElmLocation.endTag;
    return Object.assign(Object.assign({}, elementLocation), { startTag, endTag });
}
function sourceLocation(location) {
    return {
        startLine: location.startLine,
        startColumn: location.startCol,
        endLine: location.endLine,
        endColumn: location.endCol,
        start: location.startOffset,
        end: location.endOffset,
    };
}
function literal(value) {
    return {
        type: 'Literal',
        value,
    };
}
function forEach(expression, elementLocation, directiveLocation, item, index) {
    return {
        type: 'ForEach',
        expression,
        item,
        index,
        location: elementLocation,
        directiveLocation,
        children: [],
    };
}
function forOf(expression, iterator, elementLocation, directiveLocation) {
    return {
        type: 'ForOf',
        expression,
        iterator,
        location: elementLocation,
        directiveLocation,
        children: [],
    };
}
function scopedSlotFragment(identifier, elementLocation, directiveLocation, slotName) {
    return {
        type: 'ScopedSlotFragment',
        location: elementLocation,
        directiveLocation,
        children: [],
        slotData: slotDataDirective(identifier, directiveLocation),
        slotName: slotName,
    };
}
function ifNode(modifier, condition, elementLocation, directiveLocation) {
    return {
        type: 'If',
        modifier,
        condition,
        location: elementLocation,
        directiveLocation,
        children: [],
    };
}
function ifBlockNode(condition, elementLocation, directiveLocation) {
    return {
        type: 'IfBlock',
        condition,
        location: elementLocation,
        directiveLocation,
        children: [],
    };
}
function elseifBlockNode(condition, elementLocation, directiveLocation) {
    return {
        type: 'ElseifBlock',
        condition,
        location: elementLocation,
        directiveLocation,
        children: [],
    };
}
function elseBlockNode(elementLocation, directiveLocation) {
    return {
        type: 'ElseBlock',
        location: elementLocation,
        directiveLocation,
        children: [],
    };
}
function eventListener(name, handler, location) {
    return {
        type: 'EventListener',
        name,
        handler,
        location,
    };
}
function keyDirective(value, location) {
    return {
        type: 'Directive',
        name: 'Key',
        value,
        location,
    };
}
function dynamicDirective(value, location) {
    return {
        type: 'Directive',
        name: 'Dynamic',
        value,
        location,
    };
}
function lwcIsDirective(value, location) {
    return {
        type: 'Directive',
        name: 'Is',
        value,
        location,
    };
}
function spreadDirective(value, location) {
    return {
        type: 'Directive',
        name: 'Spread',
        value,
        location,
    };
}
function slotBindDirective(value, location) {
    return {
        type: 'Directive',
        name: 'SlotBind',
        value,
        location,
    };
}
function slotDataDirective(value, location) {
    return {
        type: 'Directive',
        name: 'SlotData',
        value,
        location,
    };
}
function domDirective(lwcDomAttr, location) {
    return {
        type: 'Directive',
        name: 'Dom',
        value: literal(lwcDomAttr),
        location,
    };
}
function innerHTMLDirective(value, location) {
    return {
        type: 'Directive',
        name: 'InnerHTML',
        value,
        location,
    };
}
function refDirective(value, location) {
    return {
        type: 'Directive',
        name: 'Ref',
        value,
        location,
    };
}
function preserveCommentsDirective(preserveComments, location) {
    return {
        type: 'Directive',
        name: 'PreserveComments',
        value: literal(preserveComments),
        location,
    };
}
function renderModeDirective(renderMode, location) {
    return {
        type: 'Directive',
        name: 'RenderMode',
        value: literal(renderMode),
        location,
    };
}
function attribute(name, value, location) {
    return {
        type: 'Attribute',
        name,
        value,
        location,
    };
}
function property(name, attributeName, value, location) {
    return {
        type: 'Property',
        name,
        attributeName,
        value,
        location,
    };
}
function isElement(node) {
    return node.type === 'Element';
}
function isRoot(node) {
    return node.type === 'Root';
}
function isExternalComponent(node) {
    return node.type === 'ExternalComponent';
}
function isComponent(node) {
    return node.type === 'Component';
}
function isSlot(node) {
    return node.type === 'Slot';
}
function isBaseElement(node) {
    return (isElement(node) ||
        isComponent(node) ||
        isSlot(node) ||
        isExternalComponent(node) ||
        isLwcComponent(node));
}
// BaseLwcElement represents special LWC tags denoted lwc:*
function isBaseLwcElement(node) {
    return node.type === 'Lwc';
}
// Represents the lwc:component tag
function isLwcComponent(node) {
    return isBaseLwcElement(node) && node.name === 'lwc:component';
}
function isText(node) {
    return node.type === 'Text';
}
function isComment(node) {
    return node.type === 'Comment';
}
function isExpression$1(node) {
    return node.type !== 'Literal';
}
function isStringLiteral(node) {
    return node.type === 'Literal' && typeof node.value === 'string';
}
function isBooleanLiteral(node) {
    return node.type === 'Literal' && typeof node.value === 'boolean';
}
function isForOf(node) {
    return node.type === 'ForOf';
}
function isForEach(node) {
    return node.type === 'ForEach';
}
function isForBlock(node) {
    return isForOf(node) || isForEach(node);
}
function isIf(node) {
    return node.type === 'If';
}
function isIfBlock(node) {
    return node.type === 'IfBlock';
}
function isElseifBlock(node) {
    return node.type === 'ElseifBlock';
}
function isElseBlock(node) {
    return node.type === 'ElseBlock';
}
function isConditionalParentBlock(node) {
    return isIfBlock(node) || isElseifBlock(node);
}
function isConditionalBlock(node) {
    return isIfBlock(node) || isElseifBlock(node) || isElseBlock(node);
}
function isElementDirective(node) {
    return isConditionalBlock(node) || isForBlock(node) || isIf(node) || isScopedSlotFragment(node);
}
function isParentNode(node) {
    return isBaseElement(node) || isRoot(node) || isForBlock(node) || isIf(node);
}
function isDynamicDirective(directive) {
    return directive.name === 'Dynamic';
}
function isLwcIsDirective(directive) {
    return directive.name === 'Is';
}
function isDomDirective(directive) {
    return directive.name === 'Dom';
}
function isSpreadDirective(directive) {
    return directive.name === 'Spread';
}
function isInnerHTMLDirective(directive) {
    return directive.name === 'InnerHTML';
}
function isRefDirective(directive) {
    return directive.name === 'Ref';
}
function isKeyDirective(directive) {
    return directive.name === 'Key';
}
function isSlotBindDirective(directive) {
    return directive.name === 'SlotBind';
}
function isRenderModeDirective(directive) {
    return directive.name === 'RenderMode';
}
function isPreserveCommentsDirective(directive) {
    return directive.name === 'PreserveComments';
}
function isProperty(node) {
    return node.type === 'Property';
}
function isScopedSlotFragment(node) {
    return node.type === 'ScopedSlotFragment';
}

exports.LWCDirectiveDomMode = void 0;
(function (LWCDirectiveDomMode) {
    LWCDirectiveDomMode["manual"] = "manual";
})(exports.LWCDirectiveDomMode || (exports.LWCDirectiveDomMode = {}));
exports.LWCDirectiveRenderMode = void 0;
(function (LWCDirectiveRenderMode) {
    LWCDirectiveRenderMode["shadow"] = "shadow";
    LWCDirectiveRenderMode["light"] = "light";
})(exports.LWCDirectiveRenderMode || (exports.LWCDirectiveRenderMode = {}));
/**
 * All supported special LWC tags, they should all begin with lwc:*
 */
exports.LwcTagName = void 0;
(function (LwcTagName) {
    LwcTagName["Component"] = "lwc:component";
})(exports.LwcTagName || (exports.LwcTagName = {}));
exports.TemplateDirectiveName = void 0;
(function (TemplateDirectiveName) {
    TemplateDirectiveName["If"] = "if:true";
    TemplateDirectiveName["IfBlock"] = "lwc:if";
    TemplateDirectiveName["ElseifBlock"] = "lwc:elseif";
    TemplateDirectiveName["ElseBlock"] = "lwc:else";
    TemplateDirectiveName["ForEach"] = "for:each";
    TemplateDirectiveName["ForOf"] = "for:of";
    TemplateDirectiveName["ScopedSlotFragment"] = "lwc:slot-data";
})(exports.TemplateDirectiveName || (exports.TemplateDirectiveName = {}));
exports.ElementDirectiveName = void 0;
(function (ElementDirectiveName) {
    ElementDirectiveName["Dom"] = "lwc:dom";
    // TODO [#3331]: remove usage of lwc:dynamic in 246
    ElementDirectiveName["Dynamic"] = "lwc:dynamic";
    ElementDirectiveName["Is"] = "lwc:is";
    ElementDirectiveName["External"] = "lwc:external";
    ElementDirectiveName["InnerHTML"] = "lwc:inner-html";
    ElementDirectiveName["Ref"] = "lwc:ref";
    ElementDirectiveName["SlotBind"] = "lwc:slot-bind";
    ElementDirectiveName["SlotData"] = "lwc:slot-data";
    ElementDirectiveName["Spread"] = "lwc:spread";
    ElementDirectiveName["Key"] = "key";
})(exports.ElementDirectiveName || (exports.ElementDirectiveName = {}));
exports.RootDirectiveName = void 0;
(function (RootDirectiveName) {
    RootDirectiveName["PreserveComments"] = "lwc:preserve-comments";
    RootDirectiveName["RenderMode"] = "lwc:render-mode";
})(exports.RootDirectiveName || (exports.RootDirectiveName = {}));

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/*
 * (The MIT License)
 *
 * Copyright (c) 2016 Titus Wormer <tituswormer@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
// This mapping is based on https://github.com/wooorm/html-element-attributes/blob/270d8ce/index.js
// TODO [#3019]: use the package directly instead of vendor'ing it
const HTML_ELEMENT_ATTRIBUTE_MAP = {
    '*': [
        'accesskey',
        'autocapitalize',
        'autofocus',
        'class',
        'contenteditable',
        'dir',
        'draggable',
        'enterkeyhint',
        'hidden',
        'id',
        'inputmode',
        'is',
        'itemid',
        'itemprop',
        'itemref',
        'itemscope',
        'itemtype',
        'lang',
        'nonce',
        'slot',
        'spellcheck',
        'style',
        'tabindex',
        'title',
        'translate',
    ],
    a: [
        'charset',
        'coords',
        'download',
        'href',
        'hreflang',
        'name',
        'ping',
        'referrerpolicy',
        'rel',
        'rev',
        'shape',
        'target',
        'type',
    ],
    applet: [
        'align',
        'alt',
        'archive',
        'code',
        'codebase',
        'height',
        'hspace',
        'name',
        'object',
        'vspace',
        'width',
    ],
    area: [
        'alt',
        'coords',
        'download',
        'href',
        'hreflang',
        'nohref',
        'ping',
        'referrerpolicy',
        'rel',
        'shape',
        'target',
        'type',
    ],
    audio: ['autoplay', 'controls', 'crossorigin', 'loop', 'muted', 'preload', 'src'],
    base: ['href', 'target'],
    basefont: ['color', 'face', 'size'],
    blockquote: ['cite'],
    body: ['alink', 'background', 'bgcolor', 'link', 'text', 'vlink'],
    br: ['clear'],
    button: [
        'disabled',
        'form',
        'formaction',
        'formenctype',
        'formmethod',
        'formnovalidate',
        'formtarget',
        'name',
        'type',
        'value',
    ],
    canvas: ['height', 'width'],
    caption: ['align'],
    col: ['align', 'char', 'charoff', 'span', 'valign', 'width'],
    colgroup: ['align', 'char', 'charoff', 'span', 'valign', 'width'],
    data: ['value'],
    del: ['cite', 'datetime'],
    details: ['open'],
    dialog: ['open'],
    dir: ['compact'],
    div: ['align'],
    dl: ['compact'],
    embed: ['height', 'src', 'type', 'width'],
    fieldset: ['disabled', 'form', 'name'],
    font: ['color', 'face', 'size'],
    form: [
        'accept',
        'accept-charset',
        'action',
        'autocomplete',
        'enctype',
        'method',
        'name',
        'novalidate',
        'target',
    ],
    frame: [
        'frameborder',
        'longdesc',
        'marginheight',
        'marginwidth',
        'name',
        'noresize',
        'scrolling',
        'src',
    ],
    frameset: ['cols', 'rows'],
    h1: ['align'],
    h2: ['align'],
    h3: ['align'],
    h4: ['align'],
    h5: ['align'],
    h6: ['align'],
    head: ['profile'],
    hr: ['align', 'noshade', 'size', 'width'],
    html: ['manifest', 'version'],
    iframe: [
        'align',
        'allow',
        'allowfullscreen',
        'allowpaymentrequest',
        'allowusermedia',
        'frameborder',
        'height',
        'loading',
        'longdesc',
        'marginheight',
        'marginwidth',
        'name',
        'referrerpolicy',
        'sandbox',
        'scrolling',
        'src',
        'srcdoc',
        'width',
    ],
    img: [
        'align',
        'alt',
        'border',
        'crossorigin',
        'decoding',
        'height',
        'hspace',
        'ismap',
        'loading',
        'longdesc',
        'name',
        'referrerpolicy',
        'sizes',
        'src',
        'srcset',
        'usemap',
        'vspace',
        'width',
    ],
    input: [
        'accept',
        'align',
        'alt',
        'autocomplete',
        'checked',
        'dirname',
        'disabled',
        'form',
        'formaction',
        'formenctype',
        'formmethod',
        'formnovalidate',
        'formtarget',
        'height',
        'ismap',
        'list',
        'max',
        'maxlength',
        'min',
        'minlength',
        'multiple',
        'name',
        'pattern',
        'placeholder',
        'readonly',
        'required',
        'size',
        'src',
        'step',
        'type',
        'usemap',
        'value',
        'width',
    ],
    ins: ['cite', 'datetime'],
    isindex: ['prompt'],
    label: ['for', 'form'],
    legend: ['align'],
    li: ['type', 'value'],
    link: [
        'as',
        'charset',
        'color',
        'crossorigin',
        'disabled',
        'href',
        'hreflang',
        'imagesizes',
        'imagesrcset',
        'integrity',
        'media',
        'referrerpolicy',
        'rel',
        'rev',
        'sizes',
        'target',
        'type',
    ],
    map: ['name'],
    menu: ['compact'],
    meta: ['charset', 'content', 'http-equiv', 'media', 'name', 'scheme'],
    meter: ['high', 'low', 'max', 'min', 'optimum', 'value'],
    object: [
        'align',
        'archive',
        'border',
        'classid',
        'codebase',
        'codetype',
        'data',
        'declare',
        'form',
        'height',
        'hspace',
        'name',
        'standby',
        'type',
        'typemustmatch',
        'usemap',
        'vspace',
        'width',
    ],
    ol: ['compact', 'reversed', 'start', 'type'],
    optgroup: ['disabled', 'label'],
    option: ['disabled', 'label', 'selected', 'value'],
    output: ['for', 'form', 'name'],
    p: ['align'],
    param: ['name', 'type', 'value', 'valuetype'],
    pre: ['width'],
    progress: ['max', 'value'],
    q: ['cite'],
    script: [
        'async',
        'charset',
        'crossorigin',
        'defer',
        'integrity',
        'language',
        'nomodule',
        'referrerpolicy',
        'src',
        'type',
    ],
    select: ['autocomplete', 'disabled', 'form', 'multiple', 'name', 'required', 'size'],
    slot: ['name'],
    source: ['height', 'media', 'sizes', 'src', 'srcset', 'type', 'width'],
    style: ['media', 'type'],
    table: [
        'align',
        'bgcolor',
        'border',
        'cellpadding',
        'cellspacing',
        'frame',
        'rules',
        'summary',
        'width',
    ],
    tbody: ['align', 'char', 'charoff', 'valign'],
    td: [
        'abbr',
        'align',
        'axis',
        'bgcolor',
        'char',
        'charoff',
        'colspan',
        'headers',
        'height',
        'nowrap',
        'rowspan',
        'scope',
        'valign',
        'width',
    ],
    textarea: [
        'autocomplete',
        'cols',
        'dirname',
        'disabled',
        'form',
        'maxlength',
        'minlength',
        'name',
        'placeholder',
        'readonly',
        'required',
        'rows',
        'wrap',
    ],
    tfoot: ['align', 'char', 'charoff', 'valign'],
    th: [
        'abbr',
        'align',
        'axis',
        'bgcolor',
        'char',
        'charoff',
        'colspan',
        'headers',
        'height',
        'nowrap',
        'rowspan',
        'scope',
        'valign',
        'width',
    ],
    thead: ['align', 'char', 'charoff', 'valign'],
    time: ['datetime'],
    tr: ['align', 'bgcolor', 'char', 'charoff', 'valign'],
    track: ['default', 'kind', 'label', 'src', 'srclang'],
    ul: ['compact', 'type'],
    video: [
        'autoplay',
        'controls',
        'crossorigin',
        'height',
        'loop',
        'muted',
        'playsinline',
        'poster',
        'preload',
        'src',
        'width',
    ],
};
const HTML_ATTRIBUTE_ELEMENT_MAP = Object.entries(HTML_ELEMENT_ATTRIBUTE_MAP).reduce((accumulator, entry) => {
    const element = entry[0];
    const attributes = entry[1];
    if (element !== '*') {
        attributes.forEach((attribute) => {
            if (!shared.hasOwnProperty.call(accumulator, attribute)) {
                accumulator[attribute] = [];
            }
            accumulator[attribute].push(element);
        });
    }
    return accumulator;
}, {});
Object.values(HTML_ELEMENT_ATTRIBUTE_MAP['*']).forEach((globalAttribute) => (HTML_ATTRIBUTE_ELEMENT_MAP[globalAttribute] = []));

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/*
 * MIT License
 *
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const HTML_ELEMENTS = [
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'keygen',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'math',
    'menu',
    'menuitem',
    'meta',
    'meter',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'rb',
    'rp',
    'rt',
    'rtc',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'slot',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'svg',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'u',
    'ul',
    'var',
    'video',
    'wbr',
];

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const SVG_ELEMENTS = [
    'circle',
    'ellipse',
    'feBlend',
    'feColorMatrix',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDropShadow',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feTile',
    'feTurbulence',
    'keygen',
    'line',
    'menuitem',
    'param',
    'path',
    'rect',
];

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const EXPRESSION_RE = /(\{(?:.)+?\})/g;
const IF_RE = /^if:/;
const LWC_RE = /^lwc:/;
const VALID_IF_MODIFIER = new Set(['true', 'false', 'strict-true']);
const ITERATOR_RE = /^iterator:.*$/;
const EVENT_HANDLER_RE = /^on/;
const EVENT_HANDLER_NAME_RE = /^on[a-z][a-z0-9_]*$/;
const LWC_DIRECTIVE_SET = new Set(Object.values(exports.ElementDirectiveName));
const ATTRIBUTE_NAME_CHAR = [
    ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-',
    '\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD',
    '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
].join('');
// eslint-disable-next-line no-misleading-character-class
const DATA_RE = new RegExp('^(data)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
const SUPPORTED_SVG_TAGS = new Set([
    'svg',
    'a',
    'altGlyph',
    'altglyphDef',
    'altGlyphItem',
    'animate',
    'animateColor',
    'animateMotion',
    'animateTransform',
    'audio',
    'canvas',
    'circle',
    'clipPath',
    'defs',
    'desc',
    'ellipse',
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feFuncR',
    'feFuncG',
    'feFuncB',
    'feFuncA',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDropShadow',
    'feFlood',
    'feGaussianBlur',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'feSpecularLighting',
    'feTile',
    'feTurbulence',
    'fePointLight',
    'filter',
    'font',
    'foreignObject',
    'g',
    'glyph',
    'glyphRef',
    'hkern',
    'image',
    'line',
    'linearGradient',
    'marker',
    'mask',
    'mpath',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'stop',
    'switch',
    'symbol',
    'text',
    'textPath',
    'title',
    'tref',
    'tspan',
    'video',
    'view',
    'vkern',
    'use',
]);
const DISALLOWED_MATHML_TAGS = new Set([
    'script',
    'link',
    'base',
    'object',
    'embed',
    'meta',
]);
const ATTRS_PROPS_TRANFORMS = Object.assign({ accesskey: 'accessKey', readonly: 'readOnly', tabindex: 'tabIndex', bgcolor: 'bgColor', colspan: 'colSpan', rowspan: 'rowSpan', contenteditable: 'contentEditable', crossorigin: 'crossOrigin', datetime: 'dateTime', formaction: 'formAction', ismap: 'isMap', maxlength: 'maxLength', minlength: 'minLength', novalidate: 'noValidate', usemap: 'useMap', for: 'htmlFor' }, shared.AriaAttrNameToPropNameMap);
const DISALLOWED_HTML_TAGS = new Set(['base', 'link', 'meta', 'script', 'title']);
const HTML_ATTRIBUTES_REVERSE_LOOKUP = HTML_ATTRIBUTE_ELEMENT_MAP;
const KNOWN_HTML_AND_SVG_ELEMENTS = new Set([...HTML_ELEMENTS, ...SVG_ELEMENTS]);
const HTML_TAG = {
    A: 'a',
    AREA: 'area',
    BODY: 'body',
    CAPTION: 'caption',
    COL: 'col',
    COLGROUP: 'colgroup',
    HEAD: 'head',
    HTML: 'html',
    TBODY: 'tbody',
    TD: 'td',
    TFOOT: 'tfoot',
    TH: 'th',
    THEAD: 'thead',
    TR: 'tr',
    USE: 'use',
};
const ATTR_NAME = {
    HREF: 'href',
    XLINK_HREF: 'xlink:href',
};
const TEMPLATE_DIRECTIVES = [/^key$/, /^lwc:*/, /^if:*/, /^for:*/, /^iterator:*/];
// TODO [#3370]: remove experimental template expression flag
const TMPL_EXPR_ECMASCRIPT_EDITION = 2022;

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function normalizeLocation(location) {
    let line = 0;
    let column = 0;
    let length = 0;
    let start = 0;
    if (location) {
        line = location.startLine;
        column = location.startColumn;
        length = location.end - location.start;
        start = location.start;
    }
    return { line, column, start, length };
}
class ParserCtx {
    constructor(source, config) {
        this.warnings = [];
        this.seenIds = new Set();
        this.seenSlots = new Set();
        /**
         * This set is not aware of if-elseif-else blocks.
         */
        this.seenScopedSlots = new Set();
        /**
         * 'elementScopes' keeps track of the hierarchy of ParentNodes as the parser
         * traverses the parse5 AST. Each 'elementScope' is an array where each node in
         * the array corresponds to either an IfBlock, ElseifBlock, ElseBlock, ForEach, ForOf, If, Element, Component, or Slot.
         *
         * Currently, each elementScope has a hierarchy of IfBlock > ForBlock > If > Element | Component | Slot.
         * Note: Not all elementScopes will have all the nodes listed above, but when they do, they will appear in this order.
         * We do not keep track of template nodes.
         *
         * Each scope corresponds to the original parse5.Element node.
         */
        this.elementScopes = [];
        /**
         * 'siblingScopes' keeps track of the context from one sibling node to another.
         * This holds the info needed to properly parse lwc:if, lwc:elseif, and lwc:else directives.
         */
        this.siblingScopes = [];
        this.source = source;
        this.config = config;
        this.renderMode = exports.LWCDirectiveRenderMode.shadow;
        this.preserveComments = config.preserveHtmlComments;
        // TODO [#3370]: remove experimental template expression flag
        if (config.experimentalComplexExpressions) {
            this.preparsedJsExpressions = new Map();
        }
        this.ecmaVersion = config.experimentalComplexExpressions
            ? TMPL_EXPR_ECMASCRIPT_EDITION
            : 2020;
        this.instrumentation = config.instrumentation;
    }
    getSource(start, end) {
        return this.source.slice(start, end);
    }
    setRootDirective(root) {
        var _a, _b, _c;
        this.renderMode =
            (_b = (_a = root.directives.find(isRenderModeDirective)) === null || _a === void 0 ? void 0 : _a.value.value) !== null && _b !== void 0 ? _b : this.renderMode;
        this.preserveComments =
            ((_c = root.directives.find(isPreserveCommentsDirective)) === null || _c === void 0 ? void 0 : _c.value.value) || this.preserveComments;
    }
    /**
     * This method flattens the scopes into a single array for traversal.
     */
    *ancestors(element) {
        const ancestors = this.elementScopes.flat();
        const start = element ? ancestors.indexOf(element) : ancestors.length - 1;
        for (let i = start; i >= 0; i--) {
            yield { current: ancestors[i], parent: ancestors[i - 1] };
        }
    }
    /**
     * This method returns an iterator over ancestor nodes, starting at the parent and ending at the root node.
     *
     * Note: There are instances when we want to terminate the traversal early, such as searching for a ForBlock parent.
     *
     * @param {ParentNode} startNode - Starting node to begin search, defaults to the tail of the current scope.
     * @param {function} predicate - This callback is called once for each ancestor until it finds one where predicate returns true.
     * @param {function} traversalCond - This callback is called after predicate and will terminate the traversal if it returns false.
     * traversalCond is ignored if no value is provided.
     */
    findAncestor(predicate, traversalCond = () => true, startNode) {
        for (const { current, parent } of this.ancestors(startNode)) {
            if (predicate(current)) {
                return current;
            }
            if (!traversalCond({ current, parent })) {
                break;
            }
        }
        return null;
    }
    /**
     * This method searchs the current scope and returns the value that satisfies the predicate.
     *
     * @param {function} predicate - This callback is called once for each sibling in the current scope
     * until it finds one where predicate returns true.
     */
    findInCurrentElementScope(predicate) {
        const currentScope = this.currentElementScope() || [];
        return currentScope.find(predicate) || null;
    }
    beginElementScope() {
        this.elementScopes.push([]);
    }
    endElementScope() {
        const scope = this.elementScopes.pop();
        return scope ? scope[0] : undefined;
    }
    addNodeCurrentElementScope(node) {
        const currentScope = this.currentElementScope();
        /* istanbul ignore if */
        if (!currentScope) {
            throw new Error("Can't invoke addNodeCurrentElementScope if there is no current scope");
        }
        currentScope.push(node);
    }
    hasSeenSlot(name) {
        return this.seenSlotsFromAncestorIfTree().has(name);
    }
    addSeenSlot(name) {
        const currentSeenSlots = this.seenSlotsFromAncestorIfTree();
        if (currentSeenSlots) {
            currentSeenSlots.add(name);
        }
        else {
            this.seenSlots.add(name);
        }
    }
    currentElementScope() {
        return this.elementScopes[this.elementScopes.length - 1];
    }
    beginSiblingScope() {
        this.siblingScopes.push({
            ancestorIfContext: this.currentIfContext() || this.ancestorIfContext(),
        });
    }
    endSiblingScope() {
        this.siblingScopes.pop();
    }
    beginIfChain(node) {
        const currentSiblingContext = this.currentSiblingContext();
        if (!currentSiblingContext) {
            throw new Error('Cannot invoke beginIfChain if there is currently no sibling context');
        }
        const currentIfContext = this.currentIfContext();
        if (currentIfContext) {
            throw new Error('Should not invoke beginIfChain if an if context already exists. First end the current chain before starting a new one.');
        }
        const previouslySeenSlots = this.seenSlotsFromAncestorIfTree();
        currentSiblingContext.ifContext = {
            currentNode: node,
            seenSlots: [new Set(previouslySeenSlots)],
        };
    }
    appendToIfChain(node) {
        const currentIfContext = this.currentIfContext();
        if (!currentIfContext) {
            throw new Error('Cannot invoke appendToIfChain without first setting the if context.');
        }
        currentIfContext.currentNode = node;
        const previouslySeenSlots = this.seenSlotsFromAncestorIfTree();
        currentIfContext.seenSlots.push(new Set(previouslySeenSlots));
    }
    endIfChain() {
        const currentIfContext = this.currentIfContext();
        if (!currentIfContext) {
            throw new Error('Cannot invoke endIfChain if there is currently no if context');
        }
        // Merge seen slot names from the current if chain into the parent scope.
        const seenSlotsInAncestorIfTree = this.seenSlotsFromAncestorIfTree();
        for (const seenSlots of currentIfContext.seenSlots) {
            for (const name of seenSlots) {
                seenSlotsInAncestorIfTree.add(name);
            }
        }
        const currentSiblingContext = this.currentSiblingContext();
        if (currentSiblingContext) {
            currentSiblingContext.ifContext = undefined;
        }
    }
    getSiblingIfNode() {
        var _a;
        return (_a = this.currentIfContext()) === null || _a === void 0 ? void 0 : _a.currentNode;
    }
    isParsingSiblingIfBlock() {
        return !!this.currentIfContext();
    }
    currentSiblingContext() {
        return this.siblingScopes[this.siblingScopes.length - 1];
    }
    currentIfContext() {
        var _a;
        return (_a = this.currentSiblingContext()) === null || _a === void 0 ? void 0 : _a.ifContext;
    }
    ancestorIfContext() {
        var _a;
        return (_a = this.currentSiblingContext()) === null || _a === void 0 ? void 0 : _a.ancestorIfContext;
    }
    seenSlotsFromAncestorIfTree() {
        const ancestorIfContext = this.ancestorIfContext();
        if (ancestorIfContext) {
            return ancestorIfContext.seenSlots[ancestorIfContext.seenSlots.length - 1];
        }
        return this.seenSlots;
    }
    /**
     * This method recovers from diagnostic errors that are encountered when fn is invoked.
     * All other errors are considered compiler errors and can not be recovered from.
     *
     * @param fn - method to be invoked.
     */
    withErrorRecovery(fn) {
        try {
            return fn();
        }
        catch (error) {
            /* istanbul ignore else */
            if (error instanceof errors.CompilerError) {
                // Diagnostic error
                this.addDiagnostic(error.toDiagnostic());
            }
            else {
                // Compiler error
                throw error;
            }
        }
    }
    withErrorWrapping(fn, errorInfo, location, msgFormatter) {
        try {
            return fn();
        }
        catch (error) {
            if (msgFormatter) {
                error.message = msgFormatter(error);
            }
            this.throwOnError(errorInfo, error, location);
        }
    }
    throwOnError(errorInfo, error, location) {
        const diagnostic = errors.normalizeToDiagnostic(errorInfo, error, {
            location: normalizeLocation(location),
        });
        throw errors.CompilerError.from(diagnostic);
    }
    /**
     * This method throws a diagnostic error with the node's location.
     */
    throwOnNode(errorInfo, node, messageArgs) {
        this.throw(errorInfo, messageArgs, node.location);
    }
    /**
     * This method throws a diagnostic error with location information.
     */
    throwAtLocation(errorInfo, location, messageArgs) {
        this.throw(errorInfo, messageArgs, location);
    }
    /**
     * This method throws a diagnostic error and will immediately exit the current routine.
     */
    throw(errorInfo, messageArgs, location) {
        throw errors.generateCompilerError(errorInfo, {
            messageArgs,
            origin: {
                location: normalizeLocation(location),
            },
        });
    }
    /**
     * This method logs a diagnostic warning with the node's location.
     */
    warnOnNode(errorInfo, node, messageArgs) {
        this.warn(errorInfo, messageArgs, node.location);
    }
    /**
     * This method logs a diagnostic warning with location information.
     */
    warnAtLocation(errorInfo, location, messageArgs) {
        this.warn(errorInfo, messageArgs, location);
    }
    /**
     * This method logs a diagnostic warning and will continue execution of the current routine.
     */
    warn(errorInfo, messageArgs, location) {
        this.addDiagnostic(errors.generateCompilerDiagnostic(errorInfo, {
            messageArgs,
            origin: {
                location: normalizeLocation(location),
            },
        }));
    }
    addDiagnostic(diagnostic) {
        this.warnings.push(diagnostic);
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// For the full list of parse5 error codes, see:
// https://github.com/inikulin/parse5/blob/ad2148d/packages/parse5/lib/common/error-codes.js
const errorCodesToErrorOn = new Set([
    'control-character-in-input-stream',
    'noncharacter-in-input-stream',
    'surrogate-in-input-stream',
    'non-void-html-element-start-tag-with-trailing-solidus',
    'end-tag-with-attributes',
    'end-tag-with-trailing-solidus',
    'unexpected-solidus-in-tag',
    'unexpected-null-character',
    'unexpected-question-mark-instead-of-tag-name',
    'invalid-first-character-of-tag-name',
    'unexpected-equals-sign-before-attribute-name',
    'missing-end-tag-name',
    'unexpected-character-in-attribute-name',
    'unknown-named-character-reference',
    'missing-semicolon-after-character-reference',
    'unexpected-character-after-doctype-system-identifier',
    'unexpected-character-in-unquoted-attribute-value',
    'eof-before-tag-name',
    'eof-in-tag',
    'missing-attribute-value',
    'missing-whitespace-between-attributes',
    'missing-whitespace-after-doctype-public-keyword',
    'missing-whitespace-between-doctype-public-and-system-identifiers',
    'missing-whitespace-after-doctype-system-keyword',
    'missing-quote-before-doctype-public-identifier',
    'missing-quote-before-doctype-system-identifier',
    'missing-doctype-public-identifier',
    'missing-doctype-system-identifier',
    'abrupt-doctype-public-identifier',
    'abrupt-doctype-system-identifier',
    'cdata-in-html-content',
    'incorrectly-opened-comment',
    'eof-in-script-html-comment-like-text',
    'eof-in-doctype',
    'nested-comment',
    'abrupt-closing-of-empty-comment',
    'eof-in-comment',
    'incorrectly-closed-comment',
    'eof-in-cdata',
    'absence-of-digits-in-numeric-character-reference',
    'null-character-reference',
    'surrogate-character-reference',
    'character-reference-outside-unicode-range',
    'control-character-reference',
    'noncharacter-character-reference',
    'missing-whitespace-before-doctype-name',
    'missing-doctype-name',
    'invalid-character-sequence-after-doctype-name',
    'duplicate-attribute',
]);
// These were added between parse5-with-errors v4.0.4 and parse5 v6.0.1
const errorCodesToWarnOn = new Set([
    'non-conforming-doctype',
    'missing-doctype',
    'misplaced-doctype',
    'end-tag-without-matching-open-element',
    'closing-of-element-with-open-child-elements',
    'disallowed-content-in-noscript-in-head',
    'open-elements-left-after-eof',
    'abandoned-head-element-child',
    'misplaced-start-tag-for-head-element',
    'nested-noscript-in-head',
    'eof-in-element-that-can-contain-only-text',
]);

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const ALWAYS_INVALID_TYPES = new Map(Object.entries({
    AwaitExpression: 'await expressions',
    ClassExpression: 'classes',
    FunctionExpression: 'function expressions',
    ImportExpression: 'imports',
    MetaProperty: 'import.meta',
    NewExpression: 'object instantiation',
    RegExpLiteral: 'regular expression literals',
    SequenceExpression: 'comma operators',
    Super: '`super`',
    ThisExpression: '`this`',
    YieldExpression: '`yield`',
}));
const STATEMENT_TYPES = new Set([
    'BlockStatement',
    'BreakStatement',
    'ClassDeclaration',
    'ContinueStatement',
    'DebuggerStatement',
    'DeclareClass',
    'DeclareExportAllDeclaration',
    'DeclareExportDeclaration',
    'DeclareFunction',
    'DeclareInterface',
    'DeclareModule',
    'DeclareModuleExports',
    'DeclareOpaqueType',
    'DeclareTypeAlias',
    'DeclareVariable',
    'DoWhileStatement',
    'EmptyStatement',
    'ExportAllDeclaration',
    'ExportDefaultDeclaration',
    'ExportNamedDeclaration',
    'ExpressionStatement',
    'ForInStatement',
    'ForOfStatement',
    'ForStatement',
    'FunctionDeclaration',
    'IfStatement',
    'ImportDeclaration',
    'LabeledStatement',
    'ReturnStatement',
    'Statement',
    'SwitchStatement',
    'ThrowStatement',
    'TryStatement',
    'VariableDeclaration',
    'WhileStatement',
    'WithStatement',
]);
const MUTATION_TYPES = new Set(['AssignmentExpression', 'UpdateExpression']);
function validateArrowFunction(node) {
    errors.invariant(node.body.type !== 'BlockStatement', errors.ParserDiagnostics.INVALID_EXPR_ARROW_FN_BODY);
    errors.invariant(!node.async, errors.ParserDiagnostics.INVALID_EXPR_ARROW_FN_KIND, ['async']);
    // This condition should never occur, unless the spec changes. However, it is
    // permitted by the ESTree representation, so we'll check for it just in case.
    errors.invariant(!node.generator, errors.ParserDiagnostics.INVALID_EXPR_ARROW_FN_KIND, ['generators']);
}
function validateUnaryExpression(node) {
    errors.invariant(node.operator !== 'delete', errors.ParserDiagnostics.INVALID_EXPR_DELETE_OP);
}
function validateLiteral(node) {
    // Because there may be a need for a polyfill in older browsers, and because there
    // isn't an obvious need for their inclusion, big ints are disallowed in template
    // expressions.
    errors.invariant(node.bigint === undefined, errors.ParserDiagnostics.INVALID_EXPR_PROHIBITED_NODE_TYPE, ['BigInts']);
    // Regular expression literals are difficult to visually parse, and
    // may be difficult to programatically parse with future parsing methods. For those
    // reasons, they are also disallowed.
    errors.invariant(node.regex === undefined, errors.ParserDiagnostics.INVALID_EXPR_PROHIBITED_NODE_TYPE, ['regular expression literals']);
}
function validateNode(node, _parent, isWithinArrowFn) {
    var _a, _b;
    errors.invariant(!((_a = node.leadingComments) === null || _a === void 0 ? void 0 : _a.length) && !((_b = node.trailingComments) === null || _b === void 0 ? void 0 : _b.length), errors.ParserDiagnostics.INVALID_EXPR_COMMENTS_DISALLOWED);
    errors.invariant(!STATEMENT_TYPES.has(node.type), errors.ParserDiagnostics.INVALID_EXPR_STATEMENTS_PROHIBITED);
    errors.invariant(!(MUTATION_TYPES.has(node.type) && !isWithinArrowFn), errors.ParserDiagnostics.INVALID_EXPR_MUTATION_OUTSIDE_ARROW);
    errors.invariant(!ALWAYS_INVALID_TYPES.has(node.type), errors.ParserDiagnostics.INVALID_EXPR_PROHIBITED_NODE_TYPE, [ALWAYS_INVALID_TYPES.get(node.type)]);
    if (isArrowFunctionExpression(node)) {
        validateArrowFunction(node);
    }
    else if (isUnaryExpression(node)) {
        validateUnaryExpression(node);
    }
    else if (isLiteral(node)) {
        validateLiteral(node);
    }
}
function validateExpressionAst(rootNode) {
    let arrowFnScopeDepth = 0;
    estreeWalker.walk(rootNode, {
        enter(node, parent) {
            validateNode(node, parent, !!arrowFnScopeDepth);
            if (isArrowFunctionExpression(node)) {
                arrowFnScopeDepth++;
            }
        },
        leave(node) {
            if (isArrowFunctionExpression(node)) {
                arrowFnScopeDepth--;
            }
        },
    });
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const OPENING_CURLY_LEN = 1;
const CLOSING_CURLY_LEN = 1;
const OPENING_CURLY_BRACKET = 0x7b;
const CLOSING_CURLY_BRACKET = 0x7d;
const WHITESPACE = /\s*/;
const TRAILING_SPACES_AND_PARENS = /[\s)]*/;
function getWhitespaceLen(str) {
    return WHITESPACE.exec(str)[0].length;
}
function getTrailingChars(str) {
    return TRAILING_SPACES_AND_PARENS.exec(str)[0];
}
/**
 * This function checks for "unbalanced" extraneous parentheses surrounding the expression.
 *
 * Examples of balanced extraneous parentheses (validation passes):
 *   {(foo.bar)}        <-- the MemberExpressions does not account for the surrounding parens
 *   {(foo())}          <-- the CallExpression does not account for the surrounding parens
 *   {((foo ?? bar)())} <-- the CallExpression does not account for the surrounding parens
 *
 * Examples of unbalanced extraneous parentheses (validation fails):
 *   {(foo.bar))}       <-- there is an extraneous trailing paren
 *   {foo())}           <-- there is an extraneous trailing paren
 *
 * Examples of no extraneous parentheses (validation passes):
 *   {foo()}            <-- the CallExpression accounts for the trailing paren
 *   {(foo ?? bar).baz} <-- the outer MemberExpression accounts for the leading paren
 *   {(foo).bar}        <-- the outer MemberExpression accounts for the leading paren
 *
 * Notably, no examples of extraneous leading parens could be found - these result in a
 * parsing error in Acorn. However, this function still checks, in case there is an
 * unknown expression that would parse with an extraneous leading paren.
 */
function validateMatchingExtraParens(leadingChars, trailingChars) {
    const numLeadingParens = leadingChars.split('(').length - 1;
    const numTrailingParens = trailingChars.split(')').length - 1;
    errors.invariant(numLeadingParens === numTrailingParens, errors.ParserDiagnostics.TEMPLATE_EXPRESSION_PARSING_ERROR, ['expression must have balanced parentheses.']);
}
/**
 * This class extends `parse5`'s internal tokenizer.
 *
 * Its behavior diverges from that specified in the WHATWG HTML spec
 * in two places:
 *   - 13.2.5.38 - unquoted attribute values
 *   - 13.2.5.1 - the "data" state, which corresponds to parsing outside of tags
 *
 * Specifically, this tokenizer defers to Acorn's JavaScript parser when
 * encountering a `{` character for an attribute value or within a text
 * node. Acorn parses the expression, and the tokenizer continues its work
 * following the closing `}`.
 *
 * The tokenizer itself is a massive state machine - code points are consumed one at
 * a time and, when certain conditions are met, sequences of those code points are
 * emitted as tokens. The tokenizer will also transition to new states, under conditions
 * specified by the HTML spec.
 */
class TemplateHtmlTokenizer extends Tokenizer {
    constructor(parser) {
        super();
        // We track which attribute values are in-progess so that we can defer
        // to the default tokenizer's behavior after the first character of
        // an unquoted attr value has been checked for an opening curly brace.
        this.checkedAttrs = new WeakSet();
        this.parser = parser;
    }
    // Move the lexer's cursor forward by the indicated number of positions. This
    // mechanism is superior to setting `this.preprocessor.pos` because it allows
    // parse5's location mixin to count new lines and columns, resulting in correct
    // AST location information.
    advanceBy(numChars) {
        for (let i = 0; i < numChars; i++) {
            this.preprocessor.advance();
        }
    }
    parseTemplateExpression() {
        const expressionStart = this.preprocessor.pos;
        const html = this.preprocessor.html;
        const leadingWhitespaceLen = getWhitespaceLen(html.slice(expressionStart + 1));
        const javascriptExprStart = expressionStart + leadingWhitespaceLen + OPENING_CURLY_LEN;
        // Start parsing after the opening curly brace and any leading whitespace.
        const estreeNode = acorn.parseExpressionAt(html, javascriptExprStart, {
            ecmaVersion: TMPL_EXPR_ECMASCRIPT_EDITION,
            allowAwaitOutsideFunction: true,
            locations: true,
            ranges: true,
            onComment: () => errors.invariant(false, errors.ParserDiagnostics.INVALID_EXPR_COMMENTS_DISALLOWED),
        });
        const leadingChars = html.slice(expressionStart + 1, estreeNode.start);
        const trailingChars = getTrailingChars(html.slice(estreeNode.end));
        validateMatchingExtraParens(leadingChars, trailingChars);
        const idxOfClosingBracket = estreeNode.end + trailingChars.length;
        // Capture text content between the outer curly braces, inclusive.
        const expressionTextNodeValue = html.slice(expressionStart, idxOfClosingBracket + CLOSING_CURLY_LEN);
        errors.invariant(html.codePointAt(idxOfClosingBracket) === CLOSING_CURLY_BRACKET, errors.ParserDiagnostics.TEMPLATE_EXPRESSION_PARSING_ERROR, ['expression must end with curly brace.']);
        this.advanceBy(expressionTextNodeValue.length);
        // Parsed expressions that are cached here will be later retrieved when the
        // LWC template AST is being constructed.
        this.parser.preparsedJsExpressions.set(expressionStart, estreeNode);
        return expressionTextNodeValue;
    }
    // ATTRIBUTE_VALUE_UNQUOTED_STATE is entered when an opening tag is being parsed,
    // after an attribute name is parsed, and after the `=` character is parsed. The
    // next character determines whether the lexer enters the ATTRIBUTE_VALUE_QUOTED_STATE
    // or ATTRIBUTE_VALUE_UNQUOTED_STATE. Customizations required to support template
    // expressions are only in effect when parsing an unquoted attribute value.
    ATTRIBUTE_VALUE_UNQUOTED_STATE(codePoint) {
        if (codePoint === OPENING_CURLY_BRACKET && !this.checkedAttrs.has(this.currentAttr)) {
            this.checkedAttrs.add(this.currentAttr);
            this.currentAttr.value = this.parseTemplateExpression();
            // Moving the cursor back by one allows the state machine to correctly detect
            // the state into which it should next transition.
            this._unconsume();
        }
        else {
            // If the first character in an unquoted-attr-value is not an opening
            // curly brace, it isn't a template expression. Opening curly braces
            // coming later in an unquoted attr value should not be considered
            // the beginning of a template expression.
            this.checkedAttrs.add(this.currentAttr);
            super.ATTRIBUTE_VALUE_UNQUOTED_STATE(codePoint);
        }
    }
    // DATA_STATE is the initial & default state of the lexer. It can be thought of as the
    // state when the cursor is outside of an (opening or closing) tag, and outside of
    // special parts of an HTML document like the contents of a <style> or <script> tag.
    // In other words, we're parsing a text node when in DATA_STATE.
    DATA_STATE(codePoint) {
        if (codePoint === OPENING_CURLY_BRACKET) {
            // An opening curly brace may be the first character in a text node.
            // If that is not the case, we need to emit the text node characters
            // that come before the curly brace.
            if (this.currentCharacterToken) {
                // Emit the text segment preceding the curly brace.
                this._emitCurrentCharacterToken();
            }
            const expressionTextNodeValue = this.parseTemplateExpression();
            // Create a new text-node token to contain our `{expression}`
            this._createCharacterToken(Tokenizer.CHARACTER_TOKEN, expressionTextNodeValue);
            // Emit the text node token containing the `{expression}`
            this._emitCurrentCharacterToken();
            // Moving the cursor back by one allows the state machine to correctly detect
            // the state into which it should next transition.
            this._unconsume();
        }
        else {
            super.DATA_STATE(codePoint);
        }
    }
}
/**
 * This class extends `parse5`'s internal parser. The heavy lifting is
 * done in the tokenizer. This class is only present to facilitate use
 * of that tokenizer when parsing expressions.
 */
class TemplateHtmlParser extends Parser {
    constructor(_options) {
        const { preparsedJsExpressions } = _options, options = __rest(_options, ["preparsedJsExpressions"]);
        super(options);
        this.preparsedJsExpressions = preparsedJsExpressions;
    }
    _bootstrap(document, fragmentContext) {
        super._bootstrap(document, fragmentContext);
        // The default `_bootstrap` method creates a new Tokenizer; here, we ensure that our
        // customized tokenizer is used.
        this.tokenizer = new TemplateHtmlTokenizer(this);
    }
    // The parser will try to concatenate adjacent text tokens into a single
    // text node. Template expressions should be encapsulated in their own
    // text node, and not combined with adjacent text or whitespace. To avoid
    // that, we create a new text node for the template expression rather than
    // allowing the concatenation to proceed.
    _insertCharacters(token) {
        if (token.chars[0] !== '{') {
            return super._insertCharacters(token);
        }
        const parentNode = this.openElements.current;
        const textNode = {
            nodeName: '#text',
            value: token.chars,
            sourceCodeLocation: token.location,
            parentNode,
        };
        parentNode.childNodes.push(textNode);
    }
}
/**
 * Parse the LWC template using a customized parser & lexer that allow
 * for template expressions to be parsed correctly.
 *
 * @param      {string}               source  raw template markup
 * @param      {ParseFragmentConfig}  config
 *
 * @return     {DocumentFragment}     the parsed document
 */
function parseFragment(source, config) {
    const { ctx, sourceCodeLocationInfo = true, onParseError } = config;
    const parser = new TemplateHtmlParser({
        sourceCodeLocationInfo,
        onParseError,
        preparsedJsExpressions: ctx.preparsedJsExpressions,
    });
    return parser.parseFragment(source);
}

function getLwcErrorFromParse5Error(code) {
    /* istanbul ignore else */
    if (errorCodesToErrorOn.has(code)) {
        return errors.ParserDiagnostics.INVALID_HTML_SYNTAX;
    }
    else if (errorCodesToWarnOn.has(code)) {
        return errors.ParserDiagnostics.INVALID_HTML_SYNTAX_WARNING;
    }
    else {
        // It should be impossible to reach here; we have a test in parser.spec.ts to ensure
        // all error codes are accounted for. But just to be safe, make it a warning.
        // TODO [#2650]: better system for handling unexpected parse5 errors
        // eslint-disable-next-line no-console
        console.warn('Found a Parse5 error that we do not know how to handle:', code);
        return errors.ParserDiagnostics.INVALID_HTML_SYNTAX_WARNING;
    }
}
function parseHTML(ctx, source) {
    const onParseError = (err) => {
        const { code } = err, location = __rest(err, ["code"]);
        const lwcError = getLwcErrorFromParse5Error(code);
        ctx.warnAtLocation(lwcError, sourceLocation(location), [code]);
    };
    // TODO [#3370]: remove experimental template expression flag
    if (ctx.config.experimentalComplexExpressions) {
        return parseFragment(source, {
            ctx,
            sourceCodeLocationInfo: true,
            onParseError,
        });
    }
    return parse5__namespace.parseFragment(source, {
        sourceCodeLocationInfo: true,
        onParseError,
    });
}
// https://github.com/babel/babel/blob/d33d02359474296402b1577ef53f20d94e9085c4/packages/babel-types/src/react.js#L9-L55
function cleanTextNode(value) {
    const lines = value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(/[^ \t]/)) {
            lastNonEmptyLine = i;
        }
    }
    let str = '';
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, ' ');
        if (!isFirstLine) {
            trimmedLine = trimmedLine.replace(/^[ ]+/, '');
        }
        if (!isLastLine) {
            trimmedLine = trimmedLine.replace(/[ ]+$/, '');
        }
        if (trimmedLine) {
            if (!isLastNonEmptyLine) {
                trimmedLine += ' ';
            }
            str += trimmedLine;
        }
    }
    return str;
}
function decodeTextContent(source) {
    return he__namespace.decode(source);
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// https://262.ecma-international.org/12.0/#sec-keywords-and-reserved-words
// prettier-ignore
const REVERSED_KEYWORDS = new Set([
    // Reserved keywords
    'await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete',
    'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'import',
    'in', 'instanceof', 'new', 'null', 'return', 'super', 'switch', 'this', 'throw', 'true', 'try',
    'typeof', 'var', 'void', 'while', 'with', 'yield',
    // Strict mode only reserved keywords
    'let', 'static', 'implements', 'interface', 'package', 'private', 'protected', 'public'
]);
function isReservedES6Keyword(str) {
    return REVERSED_KEYWORDS.has(str);
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const EXPRESSION_SYMBOL_START = '{';
const EXPRESSION_SYMBOL_END = '}';
const POTENTIAL_EXPRESSION_RE = /^.?{.+}.*$/;
const WHITESPACES_RE = /\s/;
function isExpression(source) {
    // Issue #3418: Legacy behavior, previous regex treated "{}" attribute value as non expression
    return source[0] === '{' && source.slice(-1) === '}' && source.length > 2;
}
function isPotentialExpression(source) {
    return !!source.match(POTENTIAL_EXPRESSION_RE);
}
function validateExpression(node, config) {
    // TODO [#3370]: remove experimental template expression flag
    if (config.experimentalComplexExpressions) {
        return validateExpressionAst(node);
    }
    const isValidNode = isIdentifier(node) || isMemberExpression(node);
    errors.invariant(isValidNode, errors.ParserDiagnostics.INVALID_NODE, [node.type]);
    if (isMemberExpression(node)) {
        errors.invariant(config.experimentalComputedMemberExpression || !node.computed, errors.ParserDiagnostics.COMPUTED_PROPERTY_ACCESS_NOT_ALLOWED);
        const { object, property } = node;
        if (!isIdentifier(object)) {
            validateExpression(object, config);
        }
        if (!isIdentifier(property)) {
            validateExpression(property, config);
        }
    }
}
function validateSourceIsParsedExpression(source, parsedExpression) {
    if (parsedExpression.end === source.length - 1) {
        return;
    }
    let unclosedParenthesisCount = 0;
    for (let i = 0, n = parsedExpression.start; i < n; i++) {
        if (source[i] === '(') {
            unclosedParenthesisCount++;
        }
    }
    // source[source.length - 1] === '}', n = source.length - 1 is to avoid processing '}'.
    for (let i = parsedExpression.end, n = source.length - 1; i < n; i++) {
        const character = source[i];
        if (character === ')') {
            unclosedParenthesisCount--;
        }
        else if (character === ';') {
            // acorn parseExpressionAt will stop at the first ";", it may be that the expression is not
            // a multiple expression ({foo;}), but this is a case that we explicitly do not want to support.
            // in such case, let's fail with the same error as if it were a multiple expression.
            errors.invariant(false, errors.ParserDiagnostics.MULTIPLE_EXPRESSIONS);
        }
        else {
            errors.invariant(WHITESPACES_RE.test(character), errors.ParserDiagnostics.TEMPLATE_EXPRESSION_PARSING_ERROR, ['Unexpected end of expression']);
        }
    }
    errors.invariant(unclosedParenthesisCount === 0, errors.ParserDiagnostics.TEMPLATE_EXPRESSION_PARSING_ERROR, [
        'Unexpected end of expression',
    ]);
}
function parseExpression(ctx, source, location) {
    const { ecmaVersion } = ctx;
    return ctx.withErrorWrapping(() => {
        const parsed = acorn.parseExpressionAt(source, 1, {
            ecmaVersion,
            // TODO [#3370]: remove experimental template expression flag
            allowAwaitOutsideFunction: ctx.config.experimentalComplexExpressions,
        });
        validateSourceIsParsedExpression(source, parsed);
        validateExpression(parsed, ctx.config);
        return Object.assign(Object.assign({}, parsed), { location });
    }, errors.ParserDiagnostics.TEMPLATE_EXPRESSION_PARSING_ERROR, location, (err) => `Invalid expression ${source} - ${err.message}`);
}
function parseIdentifier(ctx, source, location) {
    let isValid = true;
    isValid = acorn.isIdentifierStart(source.charCodeAt(0));
    for (let i = 1; i < source.length && isValid; i++) {
        isValid = acorn.isIdentifierChar(source.charCodeAt(i));
    }
    if (isValid && !isReservedES6Keyword(source)) {
        return Object.assign(Object.assign({}, identifier(source)), { location });
    }
    else {
        ctx.throwAtLocation(errors.ParserDiagnostics.INVALID_IDENTIFIER, location, [source]);
    }
}

function isQuotedAttribute(attrVal) {
    return attrVal && attrVal.startsWith('"') && attrVal.endsWith('"');
}
function isEscapedAttribute(attrVal) {
    return !attrVal || !(attrVal.includes('{') && attrVal.includes('}'));
}
function isIdReferencingAttribute(attrName) {
    return shared.ID_REFERENCING_ATTRIBUTES_SET.has(attrName);
}
// http://www.w3.org/1999/xhtml namespace idref elements for which we
// allow id references.
function isAllowedFragOnlyUrlsXHTML(tagName, attrName, namespaceURI) {
    const allowed = [HTML_TAG.A, HTML_TAG.AREA];
    return (attrName === ATTR_NAME.HREF && allowed.includes(tagName) && namespaceURI === shared.HTML_NAMESPACE);
}
// Identifies `href/xlink:href` attributes on `use` elements in the
// http://www.w3.org/2000/svg namespace
function isSvgUseHref(tagName, attrName, namespaceURI) {
    return (
    // xlink:href is a deprecated attribute included for backwards compatibility
    [ATTR_NAME.HREF, ATTR_NAME.XLINK_HREF].includes(attrName) &&
        tagName === HTML_TAG.USE &&
        namespaceURI === shared.SVG_NAMESPACE);
}
function isFragmentOnlyUrl(url) {
    return /^#/.test(url);
}
function normalizeAttributeValue(ctx, raw, tag, attr, location) {
    const { name, value } = attr;
    if (shared.isBooleanAttribute(name, tag)) {
        if (value === 'true') {
            ctx.throwAtLocation(errors.ParserDiagnostics.BOOLEAN_ATTRIBUTE_TRUE, location, [
                tag,
                name,
                value,
            ]);
        }
        else if (value === 'false') {
            ctx.throwAtLocation(errors.ParserDiagnostics.BOOLEAN_ATTRIBUTE_FALSE, location, [
                tag,
                name,
                value,
            ]);
        }
    }
    const rawAttrVal = raw.slice(raw.indexOf('=') + 1);
    const isQuoted = isQuotedAttribute(rawAttrVal);
    const isEscaped = isEscapedAttribute(rawAttrVal);
    if (!isEscaped && isExpression(value)) {
        if (isQuoted) {
            // <input value="{myValue}" />
            // -> ambiguity if the attribute value is a template identifier or a string literal.
            const unquoted = raw.replace(/"/g, '');
            const escaped = raw.replace('"{', '"\\{');
            ctx.throwAtLocation(errors.ParserDiagnostics.AMBIGUOUS_ATTRIBUTE_VALUE, location, [
                raw,
                unquoted,
                escaped,
            ]);
        }
        // <input value={myValue} />
        // -> Valid identifier.
        return { value, escapedExpression: false };
    }
    else if (!isEscaped && isPotentialExpression(value)) {
        const isExpressionEscaped = value.startsWith(`\\${EXPRESSION_SYMBOL_START}`);
        const isExpressionNextToSelfClosing = value.startsWith(EXPRESSION_SYMBOL_START) &&
            value.endsWith(`${EXPRESSION_SYMBOL_END}/`) &&
            !isQuoted;
        if (isExpressionNextToSelfClosing) {
            // <input value={myValue}/>
            // -> By design the html parser consider the / as the last character of the attribute value.
            //    Make sure to remove strip the trailing / for self closing elements.
            return { value: value.slice(0, -1), escapedExpression: false };
        }
        else if (isExpressionEscaped) {
            // <input value="\{myValue}"/>
            // -> Valid escaped string literal
            return { value: value.slice(1), escapedExpression: true };
        }
        let escaped = raw.replace(/="?/, '="\\');
        escaped += escaped.endsWith('"') ? '' : '"';
        // Throw if the attribute value looks like an expression, but it can't be resolved by the compiler.
        ctx.throwAtLocation(errors.ParserDiagnostics.AMBIGUOUS_ATTRIBUTE_VALUE_STRING, location, [
            raw,
            escaped,
        ]);
    }
    // <input value="myValue"/>
    // -> Valid string literal.
    return { value, escapedExpression: false };
}
function attributeName(attr) {
    const { prefix, name } = attr;
    return prefix ? `${prefix}:${name}` : name;
}
function isProhibitedIsAttribute(attrName) {
    return attrName === 'is';
}
function isTabIndexAttribute(attrName) {
    return attrName === 'tabindex';
}
function isValidTabIndexAttributeValue(value) {
    // object means it is a Node representing the expression
    return value === '0' || value === '-1';
}
function isAriaOrDataOrFrameworkAttribute(attrName) {
    return shared.isAriaAttribute(attrName) || isFrameworkAttribute(attrName) || isDataAttribute(attrName);
}
function isDataAttribute(attrName) {
    return !!attrName.match(DATA_RE);
}
function isFrameworkAttribute(attrName) {
    // 'key' is currently the only LWC framework-specific attribute that doesn't start with "lwc:"
    return attrName === 'key';
}
function isAttribute(element, attrName) {
    // lwc:component will resolve to an LWC custom element at runtime
    if (isComponent(element) || isLwcComponent(element)) {
        return (attrName === 'style' ||
            attrName === 'class' ||
            attrName === 'key' ||
            attrName === 'slot' ||
            // `exportparts` is only valid on a shadow host, and only available as an attribute, not a property
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/exportparts
            attrName === 'exportparts' ||
            !!attrName.match(DATA_RE));
    }
    // External custom elements default to setting data as attributes. These might be set as
    // properties during runtime, depending on runtime heuristics.
    if (isExternalComponent(element)) {
        return true;
    }
    // Handle input tag value="" and checked attributes that are only used for state initialization.
    // Because .setAttribute() won't update the value, those attributes should be considered as props.
    if (element.name === 'input' && (attrName === 'value' || attrName === 'checked')) {
        return false;
    }
    // Handle global attrs (common to all tags) and special attribute (role, aria, key, is, data-).
    // Handle general case where only standard element have attribute value.
    return true;
}
function isValidHTMLAttribute(tagName, attrName) {
    if (shared.isGlobalHtmlAttribute(attrName) ||
        isAriaOrDataOrFrameworkAttribute(attrName) ||
        isTemplateDirective(attrName) ||
        SUPPORTED_SVG_TAGS.has(tagName) ||
        DASHED_TAGNAME_ELEMENT_SET.has(tagName) ||
        !KNOWN_HTML_AND_SVG_ELEMENTS.has(tagName)) {
        return true;
    }
    const validElements = HTML_ATTRIBUTES_REVERSE_LOOKUP[attrName];
    return !!validElements && (!validElements.length || validElements.includes(tagName));
}
function isTemplateDirective(attrName) {
    return TEMPLATE_DIRECTIVES.some((directive) => {
        return directive.test(attrName);
    });
}
/**
 * Convert attribute name from kebab case to camel case property name
 */
function attributeToPropertyName(attrName) {
    return ATTRS_PROPS_TRANFORMS[attrName] || toPropertyName(attrName);
}
class ParsedAttribute {
    constructor() {
        this.attributes = new Map();
    }
    append(attr) {
        this.attributes.set(attr.name, attr);
    }
    get(pattern) {
        const key = this.getKey(pattern);
        if (key) {
            return this.attributes.get(key);
        }
    }
    getAll(pattern) {
        return this.getKeys(pattern).map((key) => this.attributes.get(key));
    }
    pick(pattern) {
        const attr = this.get(pattern);
        if (attr) {
            this.attributes.delete(attr.name);
        }
        return attr;
    }
    pickAll(pattern) {
        const attrs = this.getAll(pattern);
        for (const attr of attrs) {
            this.attributes.delete(attr.name);
        }
        return attrs;
    }
    getKey(pattern) {
        let match;
        if (typeof pattern === 'string') {
            match = pattern;
        }
        else {
            match = Array.from(this.attributes.keys()).find((name) => !!name.match(pattern));
        }
        return match;
    }
    getKeys(pattern) {
        return Array.from(this.attributes.keys()).filter((name) => !!name.match(pattern));
    }
    getAttributes() {
        return Array.from(this.attributes.values());
    }
}

function attributeExpressionReferencesForOfIndex(attribute, forOf) {
    const { value } = attribute;
    // if not an expression, it is not referencing iterator index
    if (!isMemberExpression(value)) {
        return false;
    }
    const { object, property } = value;
    if (!isIdentifier(object) || !isIdentifier(property)) {
        return false;
    }
    if (forOf.iterator.name !== object.name) {
        return false;
    }
    return property.name === 'index';
}
function attributeExpressionReferencesForEachIndex(attribute, forEach) {
    const { index } = forEach;
    const { value } = attribute;
    // No index defined on foreach
    if (!index || !isIdentifier(index) || !isIdentifier(value)) {
        return false;
    }
    return index.name === value.name;
}
function parse$1(source, state) {
    const ctx = new ParserCtx(source, state.config);
    const fragment = parseHTML(ctx, source);
    if (ctx.warnings.some((_) => _.level === errors.DiagnosticLevel.Error)) {
        return { warnings: ctx.warnings };
    }
    const root = ctx.withErrorRecovery(() => {
        const templateRoot = getTemplateRoot(ctx, fragment);
        return parseRoot(ctx, templateRoot);
    });
    return { root, warnings: ctx.warnings };
}
function parseRoot(ctx, parse5Elm) {
    const { sourceCodeLocation: rootLocation } = parse5Elm;
    /* istanbul ignore if */
    if (!rootLocation) {
        // Parse5 will recover from invalid HTML. When this happens the node's sourceCodeLocation will be undefined.
        // https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/options/parser-options.md#sourcecodelocationinfo
        // This is a defensive check as this should never happen for the root template.
        throw new Error('An internal parsing error occurred during node creation; the root template node does not have a sourceCodeLocation.');
    }
    if (parse5Elm.tagName !== 'template') {
        ctx.throw(errors.ParserDiagnostics.ROOT_TAG_SHOULD_BE_TEMPLATE, [parse5Elm.tagName], sourceLocation(rootLocation));
    }
    const parsedAttr = parseAttributes(ctx, parse5Elm, rootLocation);
    const root$1 = root(rootLocation);
    applyRootLwcDirectives(ctx, parsedAttr, root$1);
    ctx.setRootDirective(root$1);
    validateRoot(ctx, parsedAttr, root$1);
    parseChildren(ctx, parse5Elm, root$1, rootLocation);
    return root$1;
}
/**
 * This function will create LWC AST nodes from an HTML element.
 * A node is generated for each LWC HTML template directive attached to the
 * element as well as the element itself (excluding template tag elements).
 *
 * The hierarchy of nodes created is as follows:
 *
 * For/Iterator -> If -> Element/Component/Slot
 *
 * For each node that's created, the parent will be the most recently
 * created node otherwise it will be parentNode.
 *
 * Note: Not every node in the hierarchy is guaranteed to be created, for example,
 * <div></div> will only create an Element node.
 */
function parseElement(ctx, parse5Elm, parentNode, parse5ParentLocation) {
    const parse5ElmLocation = parseElementLocation(ctx, parse5Elm, parse5ParentLocation);
    const parsedAttr = parseAttributes(ctx, parse5Elm, parse5ElmLocation);
    // Create an AST node for each LWC template directive and chain them into a parent child hierarchy
    const directive = parseElementDirectives(ctx, parse5Elm, parse5ElmLocation, parentNode, parsedAttr);
    // Create an AST node for the HTML element (excluding template tag elements) and add as child to parent
    const element = parseBaseElement(ctx, parsedAttr, parse5Elm, directive !== null && directive !== void 0 ? directive : parentNode, parse5ElmLocation);
    if (element) {
        applyHandlers(ctx, parsedAttr, element);
        applyKey(ctx, parsedAttr, element);
        applyLwcDirectives(ctx, parsedAttr, element);
        applyAttributes(ctx, parsedAttr, element);
        validateElement(ctx, element, parse5Elm);
        validateAttributes(ctx, parsedAttr, element);
        validateProperties(ctx, element);
    }
    else {
        // parseBaseElement will always return an element EXCEPT when processing a <template>
        validateTemplate(ctx, parsedAttr, parse5Elm, parse5ElmLocation);
    }
    const currentNode = element !== null && element !== void 0 ? element : directive;
    if (currentNode) {
        parseChildren(ctx, parse5Elm, currentNode, parse5ElmLocation);
        validateChildren(ctx, element, directive);
    }
    else {
        // The only scenario where currentNode can be undefined is when there are only invalid attributes on a template element.
        // For example, <template class='slds-hello-world'>, these template elements and their children will not be rendered.
        ctx.warnAtLocation(errors.ParserDiagnostics.INVALID_TEMPLATE_WARNING, sourceLocation(parse5ElmLocation));
    }
}
function parseElementLocation(ctx, parse5Elm, parse5ParentLocation) {
    var _a;
    let location = parse5Elm.sourceCodeLocation;
    // AST hierarchy is ForBlock > If > BaseElement, if immediate parent is not a BaseElement it is a template.
    const parentNode = ctx.findAncestor(isBaseElement, () => false);
    if (!location) {
        // Parse5 will recover from invalid HTML. When this happens the element's sourceCodeLocation will be undefined.
        // https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/options/parser-options.md#sourcecodelocationinfo
        ctx.warn(errors.ParserDiagnostics.INVALID_HTML_RECOVERY, [
            parse5Elm.tagName,
            (_a = parentNode === null || parentNode === void 0 ? void 0 : parentNode.name) !== null && _a !== void 0 ? _a : 'template',
        ]);
    }
    // With parse5 automatically recovering from invalid HTML, some AST nodes might not have
    // location information. For example when a <table> element has a <tr> child element, parse5
    // creates a <tbody> element in the middle without location information. In this case, we
    // can safely skip the closing tag validation.
    let current = parse5Elm;
    while (!location && isElementNode(current.parentNode)) {
        current = current.parentNode;
        location = current.sourceCodeLocation;
    }
    return location !== null && location !== void 0 ? location : parse5ParentLocation;
}
const DIRECTIVE_PARSERS = [
    parseIfBlock,
    parseElseifBlock,
    parseElseBlock,
    parseForEach,
    parseForOf,
    parseIf,
    parseScopedSlotFragment,
];
function parseElementDirectives(ctx, parse5Elm, parse5ElmLocation, parent, parsedAttr) {
    let current;
    for (const parser of DIRECTIVE_PARSERS) {
        const prev = current || parent;
        const node = parser(ctx, parse5Elm, parse5ElmLocation, prev, parsedAttr);
        if (node) {
            current = node;
        }
    }
    return current;
}
function parseBaseElement(ctx, parsedAttr, parse5Elm, parent, parse5ElmLocation) {
    const { tagName: tag, namespaceURI } = parse5Elm;
    let element$1;
    if (tag === 'slot') {
        element$1 = parseSlot(ctx, parsedAttr, parse5ElmLocation);
        // Skip creating template nodes
    }
    else if (tag !== 'template') {
        // Check if the element tag is a valid custom element name and is not part of known standard
        // element name containing a dash.
        if (isCustomElementTag(tag)) {
            if (parsedAttr.get(exports.ElementDirectiveName.External)) {
                element$1 = externalComponent(tag, parse5ElmLocation);
            }
            else {
                element$1 = component(tag, parse5ElmLocation);
            }
        }
        else if (isLwcElementTag(tag)) {
            // Special tag names that begin with lwc:*
            element$1 = parseLwcElement(ctx, parse5Elm, parsedAttr, parse5ElmLocation);
        }
        else {
            // Built-in HTML elements
            element$1 = element(tag, namespaceURI, parse5ElmLocation);
        }
    }
    if (element$1) {
        ctx.addNodeCurrentElementScope(element$1);
        parent.children.push(element$1);
    }
    return element$1;
}
function parseLwcElement(ctx, parse5Elm, parsedAttr, parse5ElmLocation) {
    let lwcElementParser;
    switch (parse5Elm.tagName) {
        case exports.LwcTagName.Component:
            lwcElementParser = parseLwcComponent;
            break;
        default:
            lwcElementParser = parseLwcElementAsBuiltIn;
    }
    return lwcElementParser(ctx, parse5Elm, parsedAttr, parse5ElmLocation);
}
function parseLwcComponent(ctx, parse5Elm, parsedAttr, parse5ElmLocation) {
    if (!ctx.config.enableDynamicComponents) {
        ctx.throwAtLocation(errors.ParserDiagnostics.INVALID_OPTS_LWC_ENABLE_DYNAMIC_COMPONENTS, sourceLocation(parse5ElmLocation));
    }
    // <lwc:component> must be used with lwc:is directive
    if (!parsedAttr.get(exports.ElementDirectiveName.Is)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.LWC_COMPONENT_TAG_WITHOUT_IS_DIRECTIVE, sourceLocation(parse5ElmLocation));
    }
    return lwcComponent(parse5Elm.tagName, parse5ElmLocation);
}
function parseLwcElementAsBuiltIn(ctx, parse5Elm, _parsedAttr, parse5ElmLocation) {
    const { tagName: tag, namespaceURI } = parse5Elm;
    // Certain tag names that start with lwc:* are signals to the compiler for special behavior.
    // These tag names are listed in LwcTagNames in types.ts.
    // Issue a warning when component authors use an unrecognized lwc:* tag.
    ctx.warnAtLocation(errors.ParserDiagnostics.UNSUPPORTED_LWC_TAG_NAME, sourceLocation(parse5ElmLocation), [tag]);
    return element(tag, namespaceURI, parse5ElmLocation);
}
function parseChildren(ctx, parse5Parent, parent, parse5ParentLocation) {
    var _a;
    const children = ((_a = getTemplateContent(parse5Parent)) !== null && _a !== void 0 ? _a : parse5Parent).childNodes;
    ctx.beginSiblingScope();
    for (const child of children) {
        ctx.withErrorRecovery(() => {
            if (isElementNode(child)) {
                ctx.beginElementScope();
                parseElement(ctx, child, parent, parse5ParentLocation);
                // If we're parsing a chain of if/elseif/else nodes, any node other than
                // an else-if node ends the chain.
                const node = ctx.endElementScope();
                if (node &&
                    ctx.isParsingSiblingIfBlock() &&
                    !isIfBlock(node) &&
                    !isElseifBlock(node)) {
                    ctx.endIfChain();
                }
            }
            else if (isTextNode(child)) {
                const textNodes = parseText(ctx, child);
                parent.children.push(...textNodes);
                // Non whitespace text nodes end any if chain we may be parsing
                if (ctx.isParsingSiblingIfBlock() && textNodes.length > 0) {
                    ctx.endIfChain();
                }
            }
            else if (isCommentNode(child)) {
                const commentNode = parseComment(child);
                parent.children.push(commentNode);
                // If preserveComments is enabled, comments become syntactically meaningful and
                // end any if chain we may be parsing
                if (ctx.isParsingSiblingIfBlock() && ctx.preserveComments) {
                    ctx.endIfChain();
                }
            }
        });
    }
    ctx.endSiblingScope();
}
function parseText(ctx, parse5Text) {
    const parsedTextNodes = [];
    const location = parse5Text.sourceCodeLocation;
    /* istanbul ignore if */
    if (!location) {
        // Parse5 will recover from invalid HTML. When this happens the node's sourceCodeLocation will be undefined.
        // https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/options/parser-options.md#sourcecodelocationinfo
        // This is a defensive check as this should never happen for TextNode.
        throw new Error('An internal parsing error occurred during node creation; a text node was found without a sourceCodeLocation.');
    }
    // Extract the raw source to avoid HTML entity decoding done by parse5
    const rawText = cleanTextNode(ctx.getSource(location.startOffset, location.endOffset));
    if (!rawText.trim().length) {
        return parsedTextNodes;
    }
    // TODO [#3370]: remove experimental template expression flag
    if (ctx.config.experimentalComplexExpressions && isExpression(rawText)) {
        // Implementation of the lexer ensures that each text-node template expression
        // will be contained in its own text node. Adjacent static text will be in
        // separate text nodes.
        const preparsedExpression = ctx.preparsedJsExpressions.get(location.startOffset);
        if (!preparsedExpression) {
            throw new Error('Implementation error: cannot find preparsed template expression');
        }
        const value = Object.assign(Object.assign({}, preparsedExpression), { location: sourceLocation(location) });
        return [text(rawText, value, location)];
    }
    // Split the text node content arround expression and create node for each
    const tokenizedContent = rawText.split(EXPRESSION_RE);
    for (const token of tokenizedContent) {
        // Don't create nodes for emtpy strings
        if (!token.length) {
            continue;
        }
        let value;
        if (isExpression(token)) {
            value = parseExpression(ctx, token, sourceLocation(location));
        }
        else {
            value = literal(decodeTextContent(token));
        }
        parsedTextNodes.push(text(token, value, location));
    }
    return parsedTextNodes;
}
function parseComment(parse5Comment) {
    const location = parse5Comment.sourceCodeLocation;
    /* istanbul ignore if */
    if (!location) {
        // Parse5 will recover from invalid HTML. When this happens the node's sourceCodeLocation will be undefined.
        // https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/options/parser-options.md#sourcecodelocationinfo
        // This is a defensive check as this should never happen for CommentNode.
        throw new Error('An internal parsing error occurred during node creation; a comment node was found without a sourceCodeLocation.');
    }
    return comment(parse5Comment.data, decodeTextContent(parse5Comment.data), location);
}
function getTemplateRoot(ctx, documentFragment) {
    // Filter all the empty text nodes
    const validRoots = documentFragment.childNodes.filter((child) => isElementNode(child) ||
        (isTextNode(child) && child.value.trim().length));
    if (validRoots.length > 1) {
        const duplicateRoot = validRoots[1].sourceCodeLocation;
        ctx.throw(errors.ParserDiagnostics.MULTIPLE_ROOTS_FOUND, [], duplicateRoot ? sourceLocation(duplicateRoot) : duplicateRoot);
    }
    const [root] = validRoots;
    if (!root || !isElementNode(root)) {
        ctx.throw(errors.ParserDiagnostics.MISSING_ROOT_TEMPLATE_TAG);
    }
    return root;
}
function applyHandlers(ctx, parsedAttr, element) {
    let eventHandlerAttribute;
    while ((eventHandlerAttribute = parsedAttr.pick(EVENT_HANDLER_RE))) {
        const { name } = eventHandlerAttribute;
        if (!isExpression$1(eventHandlerAttribute.value)) {
            ctx.throwOnNode(errors.ParserDiagnostics.EVENT_HANDLER_SHOULD_BE_EXPRESSION, eventHandlerAttribute);
        }
        if (!name.match(EVENT_HANDLER_NAME_RE)) {
            ctx.throwOnNode(errors.ParserDiagnostics.INVALID_EVENT_NAME, eventHandlerAttribute, [name]);
        }
        // Strip the `on` prefix from the event handler name
        const eventName = name.slice(2);
        const listener = eventListener(eventName, eventHandlerAttribute.value, eventHandlerAttribute.location);
        element.listeners.push(listener);
    }
}
function parseIf(ctx, parse5Elm, parse5ElmLocation, parent, parsedAttr) {
    const ifAttributes = parsedAttr.pickAll(IF_RE);
    if (ifAttributes.length === 0) {
        return;
    }
    for (let i = 1; i < ifAttributes.length; i++) {
        ctx.warnAtLocation(errors.ParserDiagnostics.SINGLE_IF_DIRECTIVE_ALLOWED, sourceLocation(parse5ElmLocation), [parse5Elm.tagName]);
    }
    const ifAttribute = ifAttributes[0];
    // if:true cannot be used with lwc:if, lwc:elseif, lwc:else
    const incompatibleDirective = ctx.findInCurrentElementScope(isConditionalBlock);
    if (incompatibleDirective) {
        ctx.throwAtLocation(errors.ParserDiagnostics.LWC_IF_CANNOT_BE_USED_WITH_IF_DIRECTIVE, sourceLocation(parse5ElmLocation), [ifAttribute.name]);
    }
    if (!isExpression$1(ifAttribute.value)) {
        ctx.throwOnNode(errors.ParserDiagnostics.IF_DIRECTIVE_SHOULD_BE_EXPRESSION, ifAttribute);
    }
    const [, modifier] = ifAttribute.name.split(':');
    if (!VALID_IF_MODIFIER.has(modifier)) {
        ctx.throwOnNode(errors.ParserDiagnostics.UNEXPECTED_IF_MODIFIER, ifAttribute, [modifier]);
    }
    const node = ifNode(modifier, ifAttribute.value, sourceLocation(parse5ElmLocation), ifAttribute.location);
    ctx.addNodeCurrentElementScope(node);
    parent.children.push(node);
    return node;
}
function parseIfBlock(ctx, _parse5Elm, parse5ElmLocation, parent, parsedAttr) {
    const ifBlockAttribute = parsedAttr.pick('lwc:if');
    if (!ifBlockAttribute) {
        return;
    }
    if (!isExpression$1(ifBlockAttribute.value)) {
        ctx.throwOnNode(errors.ParserDiagnostics.IF_BLOCK_DIRECTIVE_SHOULD_BE_EXPRESSION, ifBlockAttribute);
    }
    // An if block always starts a new chain.
    if (ctx.isParsingSiblingIfBlock()) {
        ctx.endIfChain();
    }
    const ifNode = ifBlockNode(ifBlockAttribute.value, sourceLocation(parse5ElmLocation), ifBlockAttribute.location);
    ctx.addNodeCurrentElementScope(ifNode);
    ctx.beginIfChain(ifNode);
    parent.children.push(ifNode);
    return ifNode;
}
function parseElseifBlock(ctx, _parse5Elm, parse5ElmLocation, _parent, parsedAttr) {
    const elseifBlockAttribute = parsedAttr.pick('lwc:elseif');
    if (!elseifBlockAttribute) {
        return;
    }
    const hasIfBlock = ctx.findInCurrentElementScope(isIfBlock);
    if (hasIfBlock) {
        ctx.throwAtLocation(errors.ParserDiagnostics.INVALID_IF_BLOCK_DIRECTIVE_WITH_CONDITIONAL, sourceLocation(parse5ElmLocation), [elseifBlockAttribute.name]);
    }
    if (!isExpression$1(elseifBlockAttribute.value)) {
        ctx.throwOnNode(errors.ParserDiagnostics.ELSEIF_BLOCK_DIRECTIVE_SHOULD_BE_EXPRESSION, elseifBlockAttribute);
    }
    const conditionalParent = ctx.getSiblingIfNode();
    if (!conditionalParent || !isConditionalParentBlock(conditionalParent)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.LWC_IF_SCOPE_NOT_FOUND, sourceLocation(parse5ElmLocation), [elseifBlockAttribute.name]);
    }
    const elseifNode = elseifBlockNode(elseifBlockAttribute.value, sourceLocation(parse5ElmLocation), elseifBlockAttribute.location);
    // Attach the node as a child of the preceding IfBlock
    ctx.addNodeCurrentElementScope(elseifNode);
    ctx.appendToIfChain(elseifNode);
    conditionalParent.else = elseifNode;
    return elseifNode;
}
function parseElseBlock(ctx, _parse5Elm, parse5ElmLocation, _parent, parsedAttr) {
    const elseBlockAttribute = parsedAttr.pick('lwc:else');
    if (!elseBlockAttribute) {
        return;
    }
    // Cannot be used with lwc:if on the same element
    const hasIfBlock = ctx.findInCurrentElementScope(isIfBlock);
    if (hasIfBlock) {
        ctx.throwAtLocation(errors.ParserDiagnostics.INVALID_IF_BLOCK_DIRECTIVE_WITH_CONDITIONAL, sourceLocation(parse5ElmLocation), [elseBlockAttribute.name]);
    }
    // Cannot be used with lwc:elseif on the same element
    const hasElseifBlock = ctx.findInCurrentElementScope(isElseifBlock);
    if (hasElseifBlock) {
        ctx.throwAtLocation(errors.ParserDiagnostics.INVALID_ELSEIF_BLOCK_DIRECTIVE_WITH_CONDITIONAL, sourceLocation(parse5ElmLocation), [elseBlockAttribute.name]);
    }
    // Must be used immediately after an lwc:if or lwc:elseif
    const conditionalParent = ctx.getSiblingIfNode();
    if (!conditionalParent || !isConditionalParentBlock(conditionalParent)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.LWC_IF_SCOPE_NOT_FOUND, sourceLocation(parse5ElmLocation), [elseBlockAttribute.name]);
    }
    // Must not have a value
    if (!isBooleanLiteral(elseBlockAttribute.value)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.ELSE_BLOCK_DIRECTIVE_CANNOT_HAVE_VALUE, sourceLocation(parse5ElmLocation));
    }
    const elseNode = elseBlockNode(sourceLocation(parse5ElmLocation), elseBlockAttribute.location);
    // Attach the node as a child of the preceding IfBlock
    ctx.addNodeCurrentElementScope(elseNode);
    // Avoid ending the if-chain until we finish parsing all children
    ctx.appendToIfChain(elseNode);
    conditionalParent.else = elseNode;
    return elseNode;
}
function applyRootLwcDirectives(ctx, parsedAttr, root) {
    const lwcAttribute = parsedAttr.get(LWC_RE);
    if (!lwcAttribute) {
        return;
    }
    applyLwcRenderModeDirective(ctx, parsedAttr, root);
    applyLwcPreserveCommentsDirective(ctx, parsedAttr, root);
}
function applyLwcRenderModeDirective(ctx, parsedAttr, root) {
    var _a;
    const lwcRenderModeAttribute = parsedAttr.pick(exports.RootDirectiveName.RenderMode);
    if (!lwcRenderModeAttribute) {
        return;
    }
    const { value: renderDomAttr } = lwcRenderModeAttribute;
    if (!isStringLiteral(renderDomAttr) ||
        (renderDomAttr.value !== exports.LWCDirectiveRenderMode.shadow &&
            renderDomAttr.value !== exports.LWCDirectiveRenderMode.light)) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_RENDER_MODE_INVALID_VALUE, root);
    }
    root.directives.push(renderModeDirective(renderDomAttr.value, lwcRenderModeAttribute.location));
    (_a = ctx.instrumentation) === null || _a === void 0 ? void 0 : _a.incrementCounter(errors.CompilerMetrics.LWCRenderModeDirective);
}
function applyLwcPreserveCommentsDirective(ctx, parsedAttr, root) {
    const lwcPreserveCommentAttribute = parsedAttr.pick(exports.RootDirectiveName.PreserveComments);
    if (!lwcPreserveCommentAttribute) {
        return;
    }
    const { value: lwcPreserveCommentsAttr } = lwcPreserveCommentAttribute;
    if (!isBooleanLiteral(lwcPreserveCommentsAttr)) {
        ctx.throwOnNode(errors.ParserDiagnostics.PRESERVE_COMMENTS_MUST_BE_BOOLEAN, root);
    }
    root.directives.push(preserveCommentsDirective(lwcPreserveCommentsAttr.value, lwcPreserveCommentAttribute.location));
}
const LWC_DIRECTIVE_PROCESSORS = [
    applyLwcExternalDirective,
    applyLwcDynamicDirective,
    applyLwcIsDirective,
    applyLwcDomDirective,
    applyLwcInnerHtmlDirective,
    applyRefDirective,
    applyLwcSpreadDirective,
    applyLwcSlotBindDirective,
];
function applyLwcDirectives(ctx, parsedAttr, element) {
    const lwcAttribute = parsedAttr.get(LWC_RE);
    if (!lwcAttribute) {
        return;
    }
    if (!LWC_DIRECTIVE_SET.has(lwcAttribute.name)) {
        ctx.throwOnNode(errors.ParserDiagnostics.UNKNOWN_LWC_DIRECTIVE, element, [
            lwcAttribute.name,
            `<${element.name}>`,
        ]);
    }
    // Should not allow render mode or preserve comments on non root nodes
    if (parsedAttr.get(exports.RootDirectiveName.RenderMode)) {
        ctx.throwOnNode(errors.ParserDiagnostics.UNKNOWN_LWC_DIRECTIVE, element, [
            exports.RootDirectiveName.RenderMode,
            `<${element.name}>`,
        ]);
    }
    if (parsedAttr.get(exports.RootDirectiveName.PreserveComments)) {
        ctx.throwOnNode(errors.ParserDiagnostics.UNKNOWN_LWC_DIRECTIVE, element, [
            exports.RootDirectiveName.PreserveComments,
            `<${element.name}>`,
        ]);
    }
    // Bind LWC directives to element
    for (const matchAndApply of LWC_DIRECTIVE_PROCESSORS) {
        matchAndApply(ctx, parsedAttr, element);
    }
}
function applyLwcSlotBindDirective(ctx, parsedAttr, element) {
    const { name: tag } = element;
    const slotBindAttribute = parsedAttr.pick(exports.ElementDirectiveName.SlotBind);
    if (!slotBindAttribute) {
        return;
    }
    if (!isSlot(element)) {
        ctx.throwOnNode(errors.ParserDiagnostics.INVALID_LWC_SLOT_BIND_NON_SLOT_ELEMENT, element, [
            `<${tag}>`,
        ]);
    }
    const { value: slotBindValue } = slotBindAttribute;
    if (!isExpression$1(slotBindValue)) {
        ctx.throwOnNode(errors.ParserDiagnostics.INVALID_LWC_SLOT_BIND_LITERAL_PROP, element, [
            `<${tag}>`,
        ]);
    }
    element.directives.push(slotBindDirective(slotBindValue, slotBindAttribute.location));
}
function applyLwcSpreadDirective(ctx, parsedAttr, element) {
    const { name: tag } = element;
    const lwcSpread = parsedAttr.pick(exports.ElementDirectiveName.Spread);
    if (!lwcSpread) {
        return;
    }
    const { value: lwcSpreadAttr } = lwcSpread;
    if (!isExpression$1(lwcSpreadAttr)) {
        ctx.throwOnNode(errors.ParserDiagnostics.INVALID_LWC_SPREAD_LITERAL_PROP, element, [`<${tag}>`]);
    }
    element.directives.push(spreadDirective(lwcSpreadAttr, lwcSpread.location));
}
function applyLwcExternalDirective(ctx, parsedAttr, element) {
    const lwcExternalAttribute = parsedAttr.pick(exports.ElementDirectiveName.External);
    if (!lwcExternalAttribute) {
        return;
    }
    if (!isExternalComponent(element)) {
        ctx.throwOnNode(errors.ParserDiagnostics.INVALID_LWC_EXTERNAL_ON_NON_CUSTOM_ELEMENT, element, [
            `<${element.name}>`,
        ]);
    }
    if (!isBooleanLiteral(lwcExternalAttribute.value)) {
        ctx.throwOnNode(errors.ParserDiagnostics.INVALID_LWC_EXTERNAL_VALUE, element, [
            `<${element.name}>`,
        ]);
    }
}
function applyLwcDynamicDirective(ctx, parsedAttr, element) {
    var _a;
    const { name: tag } = element;
    const lwcDynamicAttribute = parsedAttr.pick(exports.ElementDirectiveName.Dynamic);
    if (!lwcDynamicAttribute) {
        return;
    }
    if (!ctx.config.experimentalDynamicDirective) {
        ctx.throwOnNode(errors.ParserDiagnostics.INVALID_OPTS_LWC_DYNAMIC, element);
    }
    if (!isComponent(element)) {
        ctx.throwOnNode(errors.ParserDiagnostics.INVALID_LWC_DYNAMIC_ON_NATIVE_ELEMENT, element, [
            `<${tag}>`,
        ]);
    }
    const { value: lwcDynamicAttr, location } = lwcDynamicAttribute;
    if (!isExpression$1(lwcDynamicAttr)) {
        ctx.throwOnNode(errors.ParserDiagnostics.INVALID_LWC_DYNAMIC_LITERAL_PROP, element, [`<${tag}>`]);
    }
    // lwc:dynamic will be deprecated in 246, issue a warning when usage is detected.
    ctx.warnOnNode(errors.ParserDiagnostics.DEPRECATED_LWC_DYNAMIC_ATTRIBUTE, element);
    (_a = ctx.instrumentation) === null || _a === void 0 ? void 0 : _a.incrementCounter(errors.CompilerMetrics.LWCDynamicDirective);
    element.directives.push(dynamicDirective(lwcDynamicAttr, location));
}
function applyLwcIsDirective(ctx, parsedAttr, element) {
    const { name: tag } = element;
    const lwcIsAttribute = parsedAttr.pick(exports.ElementDirectiveName.Is);
    if (!lwcIsAttribute) {
        return;
    }
    if (!isLwcComponent(element)) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_IS_INVALID_ELEMENT, element, [`<${tag}>`]);
    }
    const { value: lwcIsAttrValue, location } = lwcIsAttribute;
    if (!isExpression$1(lwcIsAttrValue)) {
        ctx.throwOnNode(errors.ParserDiagnostics.INVALID_LWC_IS_DIRECTIVE_VALUE, element, [
            lwcIsAttrValue.value,
        ]);
    }
    element.directives.push(lwcIsDirective(lwcIsAttrValue, location));
}
function applyLwcDomDirective(ctx, parsedAttr, element) {
    const { name: tag } = element;
    const lwcDomAttribute = parsedAttr.pick('lwc:dom');
    if (!lwcDomAttribute) {
        return;
    }
    if (ctx.renderMode === exports.LWCDirectiveRenderMode.light) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_DOM_INVALID_IN_LIGHT_DOM, element, [`<${tag}>`]);
    }
    if (isComponent(element)) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_DOM_INVALID_CUSTOM_ELEMENT, element, [`<${tag}>`]);
    }
    if (isSlot(element)) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_DOM_INVALID_SLOT_ELEMENT, element);
    }
    const { value: lwcDomAttr } = lwcDomAttribute;
    if (!isStringLiteral(lwcDomAttr) || lwcDomAttr.value !== exports.LWCDirectiveDomMode.manual) {
        const possibleValues = Object.keys(exports.LWCDirectiveDomMode)
            .map((value) => `"${value}"`)
            .join(', or ');
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_DOM_INVALID_VALUE, element, [possibleValues]);
    }
    element.directives.push(domDirective(lwcDomAttr.value, lwcDomAttribute.location));
}
function applyLwcInnerHtmlDirective(ctx, parsedAttr, element) {
    const lwcInnerHtmlDirective = parsedAttr.pick(exports.ElementDirectiveName.InnerHTML);
    if (!lwcInnerHtmlDirective) {
        return;
    }
    if (isComponent(element) || isLwcComponent(element)) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_INNER_HTML_INVALID_CUSTOM_ELEMENT, element, [
            `<${element.name}>`,
        ]);
    }
    if (isSlot(element)) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_INNER_HTML_INVALID_ELEMENT, element, [
            `<${element.name}>`,
        ]);
    }
    const { value: innerHTMLVal } = lwcInnerHtmlDirective;
    if (!isStringLiteral(innerHTMLVal) && !isExpression$1(innerHTMLVal)) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_INNER_HTML_INVALID_VALUE, element, [
            `<${element.name}>`,
        ]);
    }
    element.directives.push(innerHTMLDirective(innerHTMLVal, lwcInnerHtmlDirective.location));
}
function applyRefDirective(ctx, parsedAttr, element) {
    const lwcRefDirective = parsedAttr.pick(exports.ElementDirectiveName.Ref);
    if (!lwcRefDirective) {
        return;
    }
    if (isSlot(element)) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_REF_INVALID_ELEMENT, element, [`<${element.name}>`]);
    }
    if (isInIteration(ctx)) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_REF_INVALID_LOCATION_INSIDE_ITERATION, element, [
            `<${element.name}>`,
        ]);
    }
    const { value: refName } = lwcRefDirective;
    if (!isStringLiteral(refName) || refName.value.length === 0) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_REF_INVALID_VALUE, element, [`<${element.name}>`]);
    }
    element.directives.push(refDirective(refName, lwcRefDirective.location));
}
function parseForEach(ctx, _parse5Elm, parse5ElmLocation, parent, parsedAttr) {
    const forEachAttribute = parsedAttr.pick('for:each');
    const forItemAttribute = parsedAttr.pick('for:item');
    const forIndex = parsedAttr.pick('for:index');
    if (forEachAttribute && forItemAttribute) {
        if (!isExpression$1(forEachAttribute.value)) {
            ctx.throwOnNode(errors.ParserDiagnostics.FOR_EACH_DIRECTIVE_SHOULD_BE_EXPRESSION, forEachAttribute);
        }
        const forItemValue = forItemAttribute.value;
        if (!isStringLiteral(forItemValue)) {
            ctx.throwOnNode(errors.ParserDiagnostics.FOR_ITEM_DIRECTIVE_SHOULD_BE_STRING, forItemAttribute);
        }
        const item = parseIdentifier(ctx, forItemValue.value, forItemAttribute.location);
        let index;
        if (forIndex) {
            const forIndexValue = forIndex.value;
            if (!isStringLiteral(forIndexValue)) {
                ctx.throwOnNode(errors.ParserDiagnostics.FOR_INDEX_DIRECTIVE_SHOULD_BE_STRING, forIndex);
            }
            index = parseIdentifier(ctx, forIndexValue.value, forIndex.location);
        }
        const node = forEach(forEachAttribute.value, sourceLocation(parse5ElmLocation), forEachAttribute.location, item, index);
        ctx.addNodeCurrentElementScope(node);
        parent.children.push(node);
        return node;
    }
    else if (forEachAttribute || forItemAttribute) {
        ctx.throwAtLocation(errors.ParserDiagnostics.FOR_EACH_AND_FOR_ITEM_DIRECTIVES_SHOULD_BE_TOGETHER, sourceLocation(parse5ElmLocation));
    }
}
function parseForOf(ctx, _parse5Elm, parse5ElmLocation, parent, parsedAttr) {
    const iteratorExpression = parsedAttr.pick(ITERATOR_RE);
    if (!iteratorExpression) {
        return;
    }
    const hasForEach = ctx.findInCurrentElementScope(isForEach);
    if (hasForEach) {
        ctx.throwAtLocation(errors.ParserDiagnostics.INVALID_FOR_EACH_WITH_ITERATOR, sourceLocation(parse5ElmLocation), [iteratorExpression.name]);
    }
    const iteratorAttributeName = iteratorExpression.name;
    const [, iteratorName] = iteratorAttributeName.split(':');
    if (!isExpression$1(iteratorExpression.value)) {
        ctx.throwOnNode(errors.ParserDiagnostics.DIRECTIVE_SHOULD_BE_EXPRESSION, iteratorExpression, [
            iteratorExpression.name,
        ]);
    }
    const iterator = parseIdentifier(ctx, iteratorName, iteratorExpression.location);
    const node = forOf(iteratorExpression.value, iterator, sourceLocation(parse5ElmLocation), iteratorExpression.location);
    ctx.addNodeCurrentElementScope(node);
    parent.children.push(node);
    return node;
}
function parseScopedSlotFragment(ctx, parse5Elm, parse5ElmLocation, parent, parsedAttr) {
    const slotDataAttr = parsedAttr.pick(exports.ElementDirectiveName.SlotData);
    if (!slotDataAttr) {
        return;
    }
    if (parse5Elm.tagName !== 'template') {
        ctx.throwOnNode(errors.ParserDiagnostics.SCOPED_SLOT_DATA_ON_TEMPLATE_ONLY, slotDataAttr);
    }
    // 'lwc:slot-data' cannot be combined with other directives on the same <template> tag
    if (ctx.findInCurrentElementScope(isElementDirective)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.SCOPED_SLOTDATA_CANNOT_BE_COMBINED_WITH_OTHER_DIRECTIVE, sourceLocation(parse5ElmLocation));
    }
    // <template lwc:slot-data> element should always be the direct child of a custom element
    // The only exception is, a conditional block as parent
    const parentCmp = ctx.findAncestor(isComponent, ({ current }) => current && isConditionalBlock(current));
    if (!parentCmp) {
        ctx.throwAtLocation(errors.ParserDiagnostics.INVALID_PARENT_OF_LWC_SLOT_DATA, sourceLocation(parse5ElmLocation));
    }
    const slotDataAttrValue = slotDataAttr.value;
    if (!isStringLiteral(slotDataAttrValue)) {
        ctx.throwOnNode(errors.ParserDiagnostics.SLOT_DATA_VALUE_SHOULD_BE_STRING, slotDataAttr);
    }
    // Extract name (literal or bound) of slot if in case it's a named slot
    const slotAttr = parsedAttr.pick('slot');
    let slotName;
    if (slotAttr) {
        slotName = slotAttr.value;
    }
    const identifier = parseIdentifier(ctx, slotDataAttrValue.value, slotDataAttr.location);
    const node = scopedSlotFragment(identifier, sourceLocation(parse5ElmLocation), slotDataAttr.location, slotName !== null && slotName !== void 0 ? slotName : literal(''));
    ctx.addNodeCurrentElementScope(node);
    parent.children.push(node);
    return node;
}
function applyKey(ctx, parsedAttr, element) {
    const { name: tag } = element;
    const keyAttribute = parsedAttr.pick(exports.ElementDirectiveName.Key);
    if (keyAttribute) {
        if (!isExpression$1(keyAttribute.value)) {
            ctx.throwOnNode(errors.ParserDiagnostics.KEY_ATTRIBUTE_SHOULD_BE_EXPRESSION, keyAttribute);
        }
        const forOfParent = getForOfParent(ctx);
        const forEachParent = getForEachParent(ctx);
        if (forOfParent) {
            if (attributeExpressionReferencesForOfIndex(keyAttribute, forOfParent)) {
                ctx.throwOnNode(errors.ParserDiagnostics.KEY_SHOULDNT_REFERENCE_ITERATOR_INDEX, keyAttribute, [tag]);
            }
        }
        else if (forEachParent) {
            if (attributeExpressionReferencesForEachIndex(keyAttribute, forEachParent)) {
                const name = 'name' in keyAttribute.value && keyAttribute.value.name;
                ctx.throwOnNode(errors.ParserDiagnostics.KEY_SHOULDNT_REFERENCE_FOR_EACH_INDEX, keyAttribute, [tag, name]);
            }
        }
        if (forOfParent || forEachParent) {
            element.directives.push(keyDirective(keyAttribute.value, keyAttribute.location));
        }
        else {
            ctx.warnOnNode(errors.ParserDiagnostics.KEY_SHOULD_BE_IN_ITERATION, keyAttribute, [tag]);
        }
    }
    else if (isInIteratorElement(ctx)) {
        ctx.throwOnNode(errors.ParserDiagnostics.MISSING_KEY_IN_ITERATOR, element, [tag]);
    }
}
const RESTRICTED_DIRECTIVES_ON_SLOT = Object.values(exports.TemplateDirectiveName).join(', ');
const ALLOWED_SLOT_ATTRIBUTES = [
    exports.ElementDirectiveName.Key,
    exports.ElementDirectiveName.SlotBind,
    'name',
    'slot',
];
const ALLOWED_SLOT_ATTRIBUTES_SET = new Set(ALLOWED_SLOT_ATTRIBUTES);
function parseSlot(ctx, parsedAttr, parse5ElmLocation) {
    const location = sourceLocation(parse5ElmLocation);
    const isScopedSlot = !shared.isUndefined(parsedAttr.get(exports.ElementDirectiveName.SlotBind));
    if (isScopedSlot && ctx.renderMode !== exports.LWCDirectiveRenderMode.light) {
        ctx.throwAtLocation(errors.ParserDiagnostics.SCOPED_SLOT_BIND_IN_LIGHT_DOM_ONLY, location);
    }
    // Restrict specific template directives on <slot> element
    const hasDirectives = ctx.findInCurrentElementScope(isElementDirective);
    if (hasDirectives) {
        ctx.throwAtLocation(errors.ParserDiagnostics.SLOT_TAG_CANNOT_HAVE_DIRECTIVES, location, [
            RESTRICTED_DIRECTIVES_ON_SLOT,
        ]);
    }
    // Can't handle slots in applySlot because it would be too late for class and style attrs
    if (ctx.renderMode === exports.LWCDirectiveRenderMode.light) {
        const invalidAttrs = parsedAttr
            .getAttributes()
            .filter(({ name }) => !ALLOWED_SLOT_ATTRIBUTES_SET.has(name))
            .map(({ name }) => name);
        if (invalidAttrs.length) {
            // Light DOM slots cannot have events because there's no actual `<slot>` element
            const eventHandler = invalidAttrs.find((name) => name.match(EVENT_HANDLER_NAME_RE));
            if (eventHandler) {
                ctx.throwAtLocation(errors.ParserDiagnostics.LWC_LIGHT_SLOT_INVALID_EVENT_LISTENER, location, [eventHandler]);
            }
            ctx.throwAtLocation(errors.ParserDiagnostics.LWC_LIGHT_SLOT_INVALID_ATTRIBUTES, location, [
                invalidAttrs.join(','),
                ALLOWED_SLOT_ATTRIBUTES.join(', '),
            ]);
        }
    }
    // Default slot have empty string name
    let name = '';
    const nameAttribute = parsedAttr.get('name');
    if (nameAttribute) {
        if (isExpression$1(nameAttribute.value)) {
            ctx.throwOnNode(errors.ParserDiagnostics.NAME_ON_SLOT_CANNOT_BE_EXPRESSION, nameAttribute);
        }
        else if (isStringLiteral(nameAttribute.value)) {
            name = nameAttribute.value.value;
        }
    }
    const seenInContext = ctx.hasSeenSlot(name);
    ctx.addSeenSlot(name);
    if (seenInContext) {
        // Scoped slots do not allow duplicate or mixed slots
        // https://rfcs.lwc.dev/rfcs/lwc/0118-scoped-slots-light-dom#restricting-ambigious-bindings
        // https://rfcs.lwc.dev/rfcs/lwc/0118-scoped-slots-light-dom#invalid-usages
        // Note: ctx.seenScopedSlots is not "if" context aware and it does not need to be.
        //   It is only responsible to determine if a scoped slot with the same name has been seen prior.
        if (ctx.seenScopedSlots.has(name)) {
            // Differentiate between mixed type or duplicate scoped slot
            const errorInfo = isScopedSlot
                ? errors.ParserDiagnostics.NO_DUPLICATE_SCOPED_SLOT // error
                : errors.ParserDiagnostics.NO_MIXED_SLOT_TYPES; // error
            ctx.throwAtLocation(errorInfo, location, [name === '' ? 'default' : `name="${name}"`]);
        }
        else {
            // Differentiate between mixed type or duplicate standard slot
            const errorInfo = isScopedSlot
                ? errors.ParserDiagnostics.NO_MIXED_SLOT_TYPES // error
                : errors.ParserDiagnostics.NO_DUPLICATE_SLOTS; // warning
            // for standard slots, preserve old behavior of warnings
            ctx.warnAtLocation(errorInfo, location, [name === '' ? 'default' : `name="${name}"`]);
        }
    }
    else if (!isScopedSlot && isInIteration(ctx)) {
        // Scoped slots are allowed to be placed in iteration blocks
        ctx.warnAtLocation(errors.ParserDiagnostics.NO_SLOTS_IN_ITERATOR, location, [
            name === '' ? 'default' : `name="${name}"`,
        ]);
    }
    if (isScopedSlot) {
        ctx.seenScopedSlots.add(name);
    }
    return slot(name, parse5ElmLocation);
}
function applyAttributes(ctx, parsedAttr, element) {
    const { name: tag } = element;
    const attributes = parsedAttr.getAttributes();
    const properties = new Map();
    for (const attr of attributes) {
        const { name } = attr;
        if (!isValidHTMLAttribute(tag, name)) {
            ctx.warnOnNode(errors.ParserDiagnostics.INVALID_HTML_ATTRIBUTE, attr, [name, tag]);
        }
        if (name.match(/[^a-z0-9]$/)) {
            ctx.throwOnNode(errors.ParserDiagnostics.ATTRIBUTE_NAME_MUST_END_WITH_ALPHA_NUMERIC_CHARACTER, attr, [name, tag]);
        }
        // The leading '-' is necessary to preserve attribute to property reflection as the '-' is a signal
        // to the compiler to convert the first character following it to an uppercase.
        // This is needed for property names with an @api annotation because they can begin with an upper case character.
        if (!/^-*[a-z]|^[_$]/.test(name)) {
            ctx.throwOnNode(errors.ParserDiagnostics.ATTRIBUTE_NAME_STARTS_WITH_INVALID_CHARACTER, attr, [
                name,
                tag,
            ]);
        }
        if (isStringLiteral(attr.value)) {
            if (name === 'id') {
                const { value } = attr.value;
                if (/\s+/.test(value)) {
                    ctx.throwOnNode(errors.ParserDiagnostics.INVALID_ID_ATTRIBUTE, attr, [value]);
                }
                if (isInIteration(ctx)) {
                    ctx.warnOnNode(errors.ParserDiagnostics.INVALID_STATIC_ID_IN_ITERATION, attr);
                }
                if (ctx.seenIds.has(value)) {
                    ctx.throwOnNode(errors.ParserDiagnostics.DUPLICATE_ID_FOUND, attr, [value]);
                }
                else {
                    ctx.seenIds.add(value);
                }
            }
        }
        // the if branch handles
        // 1. All attributes for standard elements except 1 case are handled as attributes
        // 2. For custom elements, only key, slot and data are handled as attributes, rest as properties
        if (isAttribute(element, name)) {
            element.attributes.push(attr);
        }
        else {
            const propName = attributeToPropertyName(name);
            const existingProp = properties.get(propName);
            if (existingProp) {
                ctx.warnOnNode(errors.ParserDiagnostics.DUPLICATE_ATTR_PROP_TRANSFORM, attr, [
                    existingProp.attributeName,
                    name,
                    propName,
                ]);
            }
            properties.set(propName, property(propName, name, attr.value, attr.location));
            parsedAttr.pick(name);
        }
    }
    element.properties.push(...properties.values());
}
function validateRoot(ctx, parsedAttr, root) {
    const rootAttrs = parsedAttr.getAttributes();
    if (rootAttrs.length) {
        ctx.throwOnNode(errors.ParserDiagnostics.ROOT_TEMPLATE_HAS_UNKNOWN_ATTRIBUTES, root, [
            rootAttrs.map(({ name }) => name).join(','),
        ]);
    }
    if (!root.location.endTag) {
        ctx.throwOnNode(errors.ParserDiagnostics.NO_MATCHING_CLOSING_TAGS, root, ['template']);
    }
}
function validateElement(ctx, element, parse5Elm) {
    const { tagName: tag, namespaceURI: namespace } = parse5Elm;
    // Check if a non-void element has a matching closing tag.
    //
    // Note: Parse5 currently fails to collect end tag location for element with a tag name
    // containing an upper case character (inikulin/parse5#352).
    const hasClosingTag = Boolean(element.location.endTag);
    if (!shared.isVoidElement(tag, namespace) &&
        !hasClosingTag &&
        tag === tag.toLocaleLowerCase() &&
        namespace === shared.HTML_NAMESPACE) {
        ctx.throwOnNode(errors.ParserDiagnostics.NO_MATCHING_CLOSING_TAGS, element, [tag]);
    }
    if (tag === 'style' && namespace === shared.HTML_NAMESPACE) {
        ctx.throwOnNode(errors.ParserDiagnostics.STYLE_TAG_NOT_ALLOWED_IN_TEMPLATE, element);
    }
    else {
        const isNotAllowedHtmlTag = DISALLOWED_HTML_TAGS.has(tag);
        if (namespace === shared.HTML_NAMESPACE && isNotAllowedHtmlTag) {
            ctx.throwOnNode(errors.ParserDiagnostics.FORBIDDEN_TAG_ON_TEMPLATE, element, [tag]);
        }
        const isNotAllowedSvgTag = !SUPPORTED_SVG_TAGS.has(tag);
        if (namespace === shared.SVG_NAMESPACE && isNotAllowedSvgTag) {
            ctx.throwOnNode(errors.ParserDiagnostics.FORBIDDEN_SVG_NAMESPACE_IN_TEMPLATE, element, [tag]);
        }
        const isNotAllowedMathMlTag = DISALLOWED_MATHML_TAGS.has(tag);
        if (namespace === shared.MATHML_NAMESPACE && isNotAllowedMathMlTag) {
            ctx.throwOnNode(errors.ParserDiagnostics.FORBIDDEN_MATHML_NAMESPACE_IN_TEMPLATE, element, [
                tag,
            ]);
        }
        const isKnownTag = isComponent(element) ||
            isExternalComponent(element) ||
            isBaseLwcElement(element) ||
            KNOWN_HTML_AND_SVG_ELEMENTS.has(tag) ||
            SUPPORTED_SVG_TAGS.has(tag) ||
            DASHED_TAGNAME_ELEMENT_SET.has(tag);
        if (!isKnownTag) {
            ctx.warnOnNode(errors.ParserDiagnostics.UNKNOWN_HTML_TAG_IN_TEMPLATE, element, [tag]);
        }
    }
}
function validateTemplate(ctx, parsedAttr, template, parse5ElmLocation) {
    const location = sourceLocation(parse5ElmLocation);
    // Empty templates not allowed outside of root
    if (!template.attrs.length) {
        ctx.throwAtLocation(errors.ParserDiagnostics.NO_DIRECTIVE_FOUND_ON_TEMPLATE, location);
    }
    if (parsedAttr.get(exports.ElementDirectiveName.External)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.INVALID_LWC_EXTERNAL_ON_NON_CUSTOM_ELEMENT, location, ['<template>']);
    }
    if (parsedAttr.get(exports.ElementDirectiveName.InnerHTML)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.LWC_INNER_HTML_INVALID_ELEMENT, location, [
            '<template>',
        ]);
    }
    if (parsedAttr.get(exports.ElementDirectiveName.Ref)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.LWC_REF_INVALID_ELEMENT, location, ['<template>']);
    }
    if (parsedAttr.get(exports.ElementDirectiveName.Is)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.LWC_IS_INVALID_ELEMENT, location, ['<template>']);
    }
    // At this point in the parsing all supported attributes from a non root template element
    // should have been removed from ParsedAttribute and all other attributes will be ignored.
    const invalidTemplateAttributes = parsedAttr.getAttributes();
    if (invalidTemplateAttributes.length) {
        ctx.warnAtLocation(errors.ParserDiagnostics.INVALID_TEMPLATE_ATTRIBUTE, location, [
            invalidTemplateAttributes.map((attr) => attr.name).join(', '),
        ]);
    }
}
function validateChildren(ctx, element, directive) {
    if (directive) {
        // Find a scoped slot fragment node if it exists
        const slotFragment = ctx.findAncestor(isScopedSlotFragment, ({ current }) => current && isComponent, directive);
        // If the current directive is a slotFragment or the descendent of a slotFragment, additional
        // validations are required
        if (!shared.isNull(slotFragment)) {
            /*
             * A slot fragment cannot contain comment or text node as children.
             * Comment and Text nodes are always slotted to the default slot, in other words these
             * nodes cannot be assigned to a named slot. This restriction is in place to ensure that
             * in the future if slotting is done via slot assignment API, we won't have named scoped
             * slot usecase that cannot be supported.
             */
            directive.children.forEach((child) => {
                if ((ctx.preserveComments && isComment(child)) || isText(child)) {
                    ctx.throwOnNode(errors.ParserDiagnostics.NON_ELEMENT_SCOPED_SLOT_CONTENT, child);
                }
            });
        }
    }
    if (!element) {
        return;
    }
    const effectiveChildren = ctx.preserveComments
        ? element.children
        : element.children.filter((child) => !isComment(child));
    const hasDomDirective = element.directives.find(isDomDirective);
    if (hasDomDirective && effectiveChildren.length) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_DOM_INVALID_CONTENTS, element);
    }
    // prevents lwc:inner-html to be used in an element with content
    if (element.directives.find(isInnerHTMLDirective) && effectiveChildren.length) {
        ctx.throwOnNode(errors.ParserDiagnostics.LWC_INNER_HTML_INVALID_CONTENTS, element, [
            `<${element.name}>`,
        ]);
    }
}
function validateAttributes(ctx, parsedAttr, element) {
    const { name: tag } = element;
    const attributes = parsedAttr.getAttributes();
    for (const attr of attributes) {
        const { name: attrName, value: attrVal } = attr;
        if (isProhibitedIsAttribute(attrName)) {
            ctx.throwOnNode(errors.ParserDiagnostics.IS_ATTRIBUTE_NOT_SUPPORTED, element);
        }
        if (isTabIndexAttribute(attrName)) {
            if (!isExpression$1(attrVal) && !isValidTabIndexAttributeValue(attrVal.value)) {
                ctx.throwOnNode(errors.ParserDiagnostics.INVALID_TABINDEX_ATTRIBUTE, element);
            }
        }
        // TODO [#1136]: once the template compiler emits the element namespace information to the engine we should
        // restrict the validation of the "srcdoc" attribute on the "iframe" element only if this element is
        // part of the HTML namespace.
        if (tag === 'iframe' && attrName === 'srcdoc') {
            ctx.throwOnNode(errors.ParserDiagnostics.FORBIDDEN_IFRAME_SRCDOC_ATTRIBUTE, element);
        }
    }
}
function validateProperties(ctx, element) {
    for (const prop of element.properties) {
        const { attributeName: attrName, value } = prop;
        if (isProhibitedIsAttribute(attrName)) {
            ctx.throwOnNode(errors.ParserDiagnostics.IS_ATTRIBUTE_NOT_SUPPORTED, element);
        }
        if (
        // tabindex is transformed to tabIndex for properties
        isTabIndexAttribute(attrName) &&
            !isExpression$1(value) &&
            !isValidTabIndexAttributeValue(value.value)) {
            ctx.throwOnNode(errors.ParserDiagnostics.INVALID_TABINDEX_ATTRIBUTE, element);
        }
    }
}
function parseAttributes(ctx, parse5Elm, parse5ElmLocation) {
    const parsedAttrs = new ParsedAttribute();
    const { attrs: attributes, tagName } = parse5Elm;
    const { attrs: attrLocations } = parse5ElmLocation;
    for (const attr of attributes) {
        const attrLocation = attrLocations === null || attrLocations === void 0 ? void 0 : attrLocations[attributeName(attr).toLowerCase()];
        /* istanbul ignore if */
        if (!attrLocation) {
            throw new Error('An internal parsing error occurred while parsing attributes; attributes were found without a location.');
        }
        parsedAttrs.append(getTemplateAttribute(ctx, tagName, attr, attrLocation));
    }
    return parsedAttrs;
}
function getTemplateAttribute(ctx, tag, attribute$1, attributeLocation) {
    // Convert attribute name to lowercase because the location map keys follow the algorithm defined in the spec
    // https://wicg.github.io/controls-list/html-output/multipage/syntax.html#attribute-name-state
    const rawAttribute = ctx.getSource(attributeLocation.startOffset, attributeLocation.endOffset);
    const location = sourceLocation(attributeLocation);
    // parse5 automatically converts the casing from camel case to all lowercase. If the attribute name
    // is not the same before and after the parsing, then the attribute name contains capital letters
    const attrName = attributeName(attribute$1);
    if (!rawAttribute.startsWith(attrName)) {
        ctx.throwAtLocation(errors.ParserDiagnostics.INVALID_ATTRIBUTE_CASE, location, [
            rawAttribute,
            tag,
        ]);
    }
    const isBooleanAttribute = !rawAttribute.includes('=');
    const { value, escapedExpression } = normalizeAttributeValue(ctx, rawAttribute, tag, attribute$1, location);
    let attrValue;
    // TODO [#3370]: If complex template expressions are adopted, `preparsedJsExpressions`
    // should be checked. However, to avoid significant complications in the internal types,
    // arising from supporting both implementations simultaneously, we will re-parse the
    // expression here when `ctx.config.experimentalComplexExpressions` is true.
    if (isExpression(value) && !escapedExpression) {
        attrValue = parseExpression(ctx, value, location);
    }
    else if (isBooleanAttribute) {
        attrValue = literal(true);
    }
    else {
        attrValue = literal(value);
    }
    return attribute(attrName, attrValue, location);
}
function isInIteration(ctx) {
    return !!ctx.findAncestor(isForBlock);
}
function getForOfParent(ctx) {
    return ctx.findAncestor(isForOf, ({ parent }) => parent && !isBaseElement(parent));
}
function getForEachParent(ctx) {
    return ctx.findAncestor(isForEach, ({ parent }) => parent && !isBaseElement(parent));
}
function isInIteratorElement(ctx) {
    return !!(getForOfParent(ctx) || getForEachParent(ctx));
}

function shouldAddCustomRenderer(element, state) {
    // Elements of type `ExternalComponent` (e.g., elements with the lwc:external directive)
    if (state.crDirectives.has('lwc:external') && element.type === 'ExternalComponent') {
        return true;
    }
    // Elements of type `Component` are not allowed to have custom renderer hooks.
    // The renderer is cascaded down from the owner(custom element) to all its child nodes who
    // do not have a renderer specified.
    // lwc:component will resolve to a custom element at runtime.
    if (element.type === 'Component' || element.name === 'lwc:component') {
        return false;
    }
    const { attributes, directives } = element;
    if (directives.length) {
        let directiveMatched = false;
        // If any directives require custom renderer
        directiveMatched = directives.some((dir) => {
            return state.crDirectives.has(exports.ElementDirectiveName[dir.name]);
        });
        if (directiveMatched) {
            return true;
        }
    }
    const elementConfig = state.crElmToConfigMap[element.name];
    // If element requires custom renderer
    if (elementConfig) {
        const { namespace, attributes: attrConfig } = elementConfig;
        // if element config has namespace, then namespace has to be a match
        if (namespace && element.namespace !== namespace) {
            return false;
        }
        // If no attributes are specified, then consider the element requires custom renderer
        if (attrConfig.size === 0 ||
            attributes.some((attribute) => attrConfig.has(attribute.name))) {
            return true;
        }
    }
    return false;
}
function isCustomRendererHookRequired(element, state) {
    let addCustomRenderer = false;
    if (state.config.customRendererConfig) {
        const cachedResult = state.crCheckedElements.get(element);
        if (cachedResult !== undefined) {
            return cachedResult;
        }
        else {
            addCustomRenderer = shouldAddCustomRenderer(element, state);
            state.crCheckedElements.set(element, addCustomRenderer);
        }
    }
    return addCustomRenderer;
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function identifierFromComponentName(name) {
    return identifier(`_${toPropertyName(name)}`);
}
function getMemberExpressionRoot(expression) {
    let current = expression;
    while (isMemberExpression(current)) {
        current = current.object;
    }
    return current;
}
function objectToAST(obj, valueMapper) {
    return objectExpression(Object.keys(obj).map((key) => property$1(literal$1(key), valueMapper(key))));
}
/**
 * Returns true if the children should be flattened.
 *
 * This function searches through the children to determine if flattening needs to occur in the runtime.
 * Children should be flattened if they contain an iterator, a dynamic directive or a slot inside a light dom element.
 */
function shouldFlatten(codeGen, children) {
    return children.some((child) => {
        return (
        // ForBlock will generate a list of iterable vnodes
        isForBlock(child) ||
            // light DOM slots
            (isSlot(child) && codeGen.renderMode === exports.LWCDirectiveRenderMode.light) ||
            // If node is only a control flow node and does not map to a stand alone element.
            // Search children to determine if it should be flattened.
            (isIf(child) && shouldFlatten(codeGen, child.children)));
    });
}
/**
 * Returns true if the AST element or any of its descendants use an id attribute.
 */
function hasIdAttribute(node) {
    if (isBaseElement(node)) {
        const hasIdAttr = [...node.attributes, ...node.properties].some(({ name }) => name === 'id');
        if (hasIdAttr) {
            return true;
        }
    }
    if (isParentNode(node)) {
        return node.children.some((child) => hasIdAttribute(child));
    }
    return false;
}
function memorizeHandler(codeGen, componentHandler, handler) {
    // #439 - The handler can only be memorized if it is bound to component instance
    const id = getMemberExpressionRoot(componentHandler);
    const shouldMemorizeHandler = !codeGen.isLocalIdentifier(id);
    // Apply memorization if the handler is memorizable.
    //   $cmp.handlePress -> _m1 || ($ctx._m1 = b($cmp.handlePress))
    if (shouldMemorizeHandler) {
        const memorizedId = codeGen.getMemorizationId();
        const memorization = assignmentExpression('=', memberExpression(identifier(TEMPLATE_PARAMS.CONTEXT), memorizedId), handler);
        handler = logicalExpression('||', memorizedId, memorization);
    }
    return handler;
}
function generateTemplateMetadata(codeGen) {
    const metadataExpressions = [];
    if (codeGen.slotNames.size) {
        const slotsProperty = memberExpression(identifier(TEMPLATE_FUNCTION_NAME), identifier('slots'));
        const slotsArray = arrayExpression(Array.from(codeGen.slotNames)
            .sort()
            .map((slot) => literal$1(slot)));
        const slotsMetadata = assignmentExpression('=', slotsProperty, slotsArray);
        metadataExpressions.push(expressionStatement(slotsMetadata));
    }
    const stylesheetsMetadata = assignmentExpression('=', memberExpression(identifier(TEMPLATE_FUNCTION_NAME), identifier('stylesheets')), arrayExpression([]));
    metadataExpressions.push(expressionStatement(stylesheetsMetadata));
    // ignore when shadow because we don't want to modify template unnecessarily
    if (codeGen.renderMode === exports.LWCDirectiveRenderMode.light) {
        const renderModeMetadata = assignmentExpression('=', memberExpression(identifier(TEMPLATE_FUNCTION_NAME), identifier('renderMode')), literal$1('light'));
        metadataExpressions.push(expressionStatement(renderModeMetadata));
    }
    if (codeGen.hasRefs) {
        const refsMetadata = assignmentExpression('=', memberExpression(identifier(TEMPLATE_FUNCTION_NAME), identifier('hasRefs')), literal$1(true));
        metadataExpressions.push(expressionStatement(refsMetadata));
    }
    return metadataExpressions;
}
const DECLARATION_DELIMITER = /;(?![^(]*\))/g;
const PROPERTY_DELIMITER = /:(.+)/;
// Borrowed from Vue template compiler.
// https://github.com/vuejs/vue/blob/531371b818b0e31a989a06df43789728f23dc4e8/src/platforms/web/util/style.js#L5-L16
function parseStyleText(cssText) {
    const styleMap = {};
    const declarations = cssText.split(DECLARATION_DELIMITER);
    for (const declaration of declarations) {
        if (declaration) {
            const [prop, value] = declaration.split(PROPERTY_DELIMITER);
            if (prop !== undefined && value !== undefined) {
                styleMap[prop.trim()] = value.trim();
            }
        }
    }
    return styleMap;
}
// Given a map of CSS property keys to values, return an array AST like:
// ['color', 'blue', false]    // { color: 'blue' }
// ['background', 'red', true] // { background: 'red !important' }
function styleMapToStyleDeclsAST(styleMap) {
    const styles = Object.entries(styleMap).map(([key, value]) => {
        const important = value.endsWith('!important');
        if (important) {
            // trim off the trailing "!important" (10 chars)
            value = value.substring(0, value.length - 10).trim();
        }
        return [key, value, important];
    });
    return arrayExpression(styles.map((arr) => arrayExpression(arr.map((val) => literal$1(val)))));
}
const CLASSNAME_DELIMITER = /\s+/;
function parseClassNames(classNames) {
    return classNames
        .split(CLASSNAME_DELIMITER)
        .map((className) => className.trim())
        .filter((className) => className.length);
}
function isStaticNode(node) {
    let result = true;
    const { name: nodeName, namespace = '', attributes, directives, properties } = node;
    if (namespace !== shared.HTML_NAMESPACE) {
        // TODO [#3313]: re-enable static optimization for SVGs once scope token is always lowercase
        return false;
    }
    // it is an element
    result && (result = isElement(node));
    // all attrs are static-safe
    result && (result = attributes.every(({ name, value }) => {
        return (isLiteral(value) &&
            name !== 'slot' &&
            // check for ScopedId
            name !== 'id' &&
            name !== 'spellcheck' && // spellcheck is specially handled by the vnodes.
            !isIdReferencingAttribute(name) &&
            // svg href needs sanitization.
            !isSvgUseHref(nodeName, name, namespace) &&
            // Check for ScopedFragId
            !(isAllowedFragOnlyUrlsXHTML(nodeName, name, namespace) &&
                isFragmentOnlyUrl(value.value)));
    }));
    // all directives are static-safe
    result && (result = !directives.some((directive) => !STATIC_SAFE_DIRECTIVES.has(directive.name)));
    // all properties are static
    result && (result = properties.every((prop) => isLiteral(prop.value)));
    return result;
}
function isSafeStaticChild(childNode) {
    if (!isBaseElement(childNode)) {
        // don't need to check non-base-element nodes, because they don't have listeners/directives
        return true;
    }
    // Bail out if any children have event listeners or directives. These are only allowed at the top level of a
    // static fragment, because the engine currently cannot set listeners/refs/etc. on nodes inside a static fragment.
    return childNode.listeners.length === 0 && childNode.directives.length === 0;
}
function collectStaticNodes(node, staticNodes, state) {
    let childrenAreStatic = true;
    let nodeIsStatic;
    if (isText(node)) {
        nodeIsStatic = isLiteral(node.value);
    }
    else if (isComment(node)) {
        nodeIsStatic = true;
    }
    else {
        // it is ElseBlock | ForBlock | If | BaseElement
        node.children.forEach((childNode) => {
            collectStaticNodes(childNode, staticNodes, state);
            childrenAreStatic && (childrenAreStatic = staticNodes.has(childNode));
            childrenAreStatic && (childrenAreStatic = isSafeStaticChild(childNode));
        });
        // for IfBlock and ElseifBlock, traverse down the else branch
        if (isConditionalParentBlock(node) && node.else) {
            collectStaticNodes(node.else, staticNodes, state);
        }
        nodeIsStatic =
            isBaseElement(node) && !isCustomRendererHookRequired(node, state) && isStaticNode(node);
    }
    if (nodeIsStatic && childrenAreStatic) {
        staticNodes.add(node);
    }
}
function getStaticNodes(root, state) {
    const staticNodes = new Set();
    root.children.forEach((childNode) => {
        collectStaticNodes(childNode, staticNodes, state);
    });
    return staticNodes;
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// Implementation based on the parse5 serializer: https://github.com/inikulin/parse5/blob/master/packages/parse5/lib/serializer/index.ts
// Text nodes child of these tags should not be escaped (https://html.spec.whatwg.org/#serialising-html-fragments).
const rawContentElements = new Set([
    'STYLE',
    'SCRIPT',
    'XMP',
    'IFRAME',
    'NOEMBED',
    'NOFRAMES',
    'PLAINTEXT',
]);
/**
 * Escape all the characters that could break a JavaScript template string literal: "`" (backtick),
 * "${" (dollar + open curly) and "\" (backslash).
 */
function templateStringEscape(str) {
    return str.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$\{/g, '\\${');
}
function serializeAttrs(element) {
    /**
     * 0: styleToken in existing class attr
     * 1: styleToken for added class attr
     * 2: styleToken as attr
     */
    const attrs = [];
    let hasClassAttr = false;
    const collector = ({ name, value }) => {
        let v = typeof value === 'string' ? templateStringEscape(value) : value;
        if (name === 'class') {
            hasClassAttr = true;
            v += '${0}';
        }
        if (typeof v === 'string') {
            attrs.push(`${name}="${shared.htmlEscape(v, true)}"`);
        }
        else {
            attrs.push(name);
        }
    };
    element.attributes
        .map((attr) => {
        return {
            name: attr.name,
            value: attr.value.value,
        };
    })
        .forEach(collector);
    // This is tightly coupled with the logic in the parser that decides when an attribute should be
    // a property: https://github.com/salesforce/lwc/blob/master/packages/%40lwc/template-compiler/src/parser/attribute.ts#L198-L218
    // Because a component can't be a static element, we only look in the property bag on value and checked attribute
    // from the input.
    element.properties
        .map((prop) => {
        return {
            name: prop.attributeName,
            value: prop.value.value,
        };
    })
        .forEach(collector);
    return (attrs.length > 0 ? ' ' : '') + attrs.join(' ') + (hasClassAttr ? '${2}' : '${3}');
}
function serializeChildren(children, parentTagName, preserveComments) {
    let html = '';
    children.forEach((child) => {
        /* istanbul ignore else  */
        if (isElement(child)) {
            html += serializeStaticElement(child, preserveComments);
        }
        else if (isText(child)) {
            html += serializeTextNode(child, rawContentElements.has(parentTagName.toUpperCase()));
        }
        else if (isComment(child)) {
            html += serializeCommentNode(child, preserveComments);
        }
        else {
            throw new TypeError('Unknown node found while serializing static content. Allowed nodes types are: Element, Text and Comment.');
        }
    });
    return html;
}
function serializeCommentNode(comment, preserveComment) {
    return preserveComment ? `<!--${shared.htmlEscape(templateStringEscape(comment.value))}-->` : '';
}
function serializeTextNode(text, useRawContent) {
    let content;
    if (useRawContent) {
        content = text.raw;
    }
    else {
        content = shared.htmlEscape(text.value.value);
    }
    return templateStringEscape(content);
}
function serializeStaticElement(element, preserveComments) {
    const { name: tagName, namespace } = element;
    const isForeignElement = namespace !== shared.HTML_NAMESPACE;
    const hasChildren = element.children.length > 0;
    let html = `<${tagName}${serializeAttrs(element)}`;
    if (isForeignElement && !hasChildren) {
        html += '/>';
        return html;
    }
    html += '>';
    html += serializeChildren(element.children, tagName, preserveComments);
    if (!shared.isVoidElement(tagName, namespace) || hasChildren) {
        html += `</${tagName}>`;
    }
    return html;
}

/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Bind the passed expression to the component instance. It applies the following
 * transformation to the expression:
 *    {value} --> {$cmp.value}
 *    {value[index]} --> {$cmp.value[$cmp.index]}
 *    {foo ?? bar} --> {$cmp.foo ?? $cmp.bar}
 *    {foo?.bar} --> {$cmp.foo?.bar}
 *
 * However, parameter variables are not be transformed in this way. For example,
 * the following transformations do not happen:
 *    {(foo) => foo && bar} -> {(foo) => $cmp.foo && $cmp.bar}
 *    {(foo) => foo && bar} -> {($cmp.foo) => foo && $cmp.bar}
 *    {(foo) => foo && bar} -> {($cmp.foo) => $cmp.foo && $cmp.bar}
 *
 * Instead, the scopes are respected:
 *    {(foo) => foo && $cmp.bar}
 *
 * Similar checks occur for local identifiers introduced via for:each or similar.
 */
function bindComplexExpression(expression, codeGen) {
    const expressionScopes = new ExpressionScopes();
    estreeWalker.walk(expression, {
        enter(node, _parent) {
            // Function and class expressions are not permitted in template expressions,
            // only arrow function expressions.
            if (isArrowFunctionExpression(node)) {
                expressionScopes.enterScope(node);
            }
        },
        leave(node, parent) {
            if (isArrowFunctionExpression(node)) {
                expressionScopes.exitScope(node);
            }
            else if (parent !== null &&
                isIdentifier(node) &&
                // Acorn parses `undefined` as an Identifier.
                node.name !== 'undefined' &&
                !(isMemberExpression(parent) && parent.property === node) &&
                !(isProperty$1(parent) && parent.key === node) &&
                !codeGen.isLocalIdentifier(node) &&
                !expressionScopes.isScopedToExpression(node)) {
                this.replace(memberExpression(identifier(TEMPLATE_PARAMS.INSTANCE), node));
            }
        },
    });
    return expression;
}
/**
 * Track the variables that come in and out of scope in various parts of a
 * template expression. Arrow functions can return arrow functions, which can lead to
 * variable shadowing, which needs to be handled correctly.
 */
class ExpressionScopes {
    constructor() {
        this.variableShadowingCount = new Map();
        this.arrowFnVariables = new Map();
    }
    enterScope(node) {
        var _a;
        const variableNamesIntroduced = new Set();
        for (const param of node.params) {
            collectParams(param, variableNamesIntroduced);
        }
        for (const varName of variableNamesIntroduced) {
            this.variableShadowingCount.set(varName, ((_a = this.variableShadowingCount.get(varName)) !== null && _a !== void 0 ? _a : 0) + 1);
        }
        this.arrowFnVariables.set(node, variableNamesIntroduced);
    }
    exitScope(node) {
        const varNames = this.arrowFnVariables.get(node);
        if (varNames) {
            for (const varName of varNames) {
                this.variableShadowingCount.set(varName, this.variableShadowingCount.get(varName) - 1);
            }
        }
    }
    // If a variable was introduced as an arrow function parameter and is still
    // in scope, return true. Otherwise, return false.
    isScopedToExpression(node) {
        return !!this.variableShadowingCount.get(node.name);
    }
}
function collectParams(node, vars) {
    if (isIdentifier(node)) {
        collectParamsFromIdentifier(node, vars);
    }
    else if (isObjectPattern(node)) {
        collectParamsFromObjectPattern(node, vars);
    }
    else if (isProperty$1(node)) {
        collectParamsFromProperty(node, vars);
    }
    else if (isArrayPattern(node)) {
        collectParamsFromArrayPattern(node, vars);
    }
    else if (isRestElement(node)) {
        collectParamsFromRestElement(node, vars);
    }
    else if (isAssignmentPattern(node)) {
        collectParamsFromAssignmentPattern();
    }
    else if (isMemberExpression(node)) {
        collectParamsFromMemberExpression();
    }
    else {
        errors.invariant(false, errors.ParserDiagnostics.INVALID_EXPR_ARROW_FN_PARAM, [node.type]);
    }
}
function collectParamsFromIdentifier(node, vars) {
    vars.add(node.name);
}
function collectParamsFromObjectPattern(node, vars) {
    for (const property of node.properties) {
        collectParams(property, vars);
    }
}
function collectParamsFromProperty(node, vars) {
    collectParams(node.value, vars);
}
function collectParamsFromArrayPattern(node, vars) {
    for (const element of node.elements) {
        // Elements of an array pattern can be null.
        if (element) {
            collectParams(element, vars);
        }
    }
}
function collectParamsFromRestElement(node, vars) {
    collectParams(node.argument, vars);
}
function collectParamsFromAssignmentPattern(_node, _vars) {
    errors.invariant(false, errors.ParserDiagnostics.INVALID_EXPR_ARROW_FN_PARAM, ['default parameters']);
}
function collectParamsFromMemberExpression(_node, _vars) {
    // It is unclear how this condition could ever be reached. But because it is allowed by
    // the AST, we'll validate anyway.
    errors.invariant(false, errors.ParserDiagnostics.INVALID_EXPR_ARROW_FN_PARAM, ['member expressions']);
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const RENDER_APIS = {
    iterator: { name: 'i', alias: 'api_iterator' },
    flatten: { name: 'f', alias: 'api_flatten' },
    element: { name: 'h', alias: 'api_element' },
    slot: { name: 's', alias: 'api_slot' },
    customElement: { name: 'c', alias: 'api_custom_element' },
    dynamicCtor: { name: 'dc', alias: 'api_dynamic_component' },
    // TODO [#3331]: remove usage of lwc:dynamic in 246
    deprecatedDynamicCtor: { name: 'ddc', alias: 'api_deprecated_dynamic_component' },
    bind: { name: 'b', alias: 'api_bind' },
    text: { name: 't', alias: 'api_text' },
    dynamicText: { name: 'd', alias: 'api_dynamic_text' },
    key: { name: 'k', alias: 'api_key' },
    tabindex: { name: 'ti', alias: 'api_tab_index' },
    scopedId: { name: 'gid', alias: 'api_scoped_id' },
    scopedFragId: { name: 'fid', alias: 'api_scoped_frag_id' },
    comment: { name: 'co', alias: 'api_comment' },
    sanitizeHtmlContent: { name: 'shc', alias: 'api_sanitize_html_content' },
    fragment: { name: 'fr', alias: 'api_fragment' },
    staticFragment: { name: 'st', alias: 'api_static_fragment' },
    scopedSlotFactory: { name: 'ssf', alias: 'api_scoped_slot_factory' },
};
class CodeGen {
    constructor({ root, state, scopeFragmentId, }) {
        var _a, _b, _c, _d;
        this.staticNodes = new Set();
        this.hoistedNodes = [];
        /** True if this template contains the lwc:ref directive */
        this.hasRefs = false;
        this.currentId = 0;
        this.currentKey = 0;
        this.innerHtmlInstances = 0;
        this.usedApis = {};
        this.usedLwcApis = new Set();
        this.slotNames = new Set();
        this.memorizedIds = [];
        this.referencedComponents = new Set();
        this.root = root;
        if (state.config.enableStaticContentOptimization) {
            this.staticNodes = getStaticNodes(root, state);
        }
        this.renderMode =
            (_b = (_a = root.directives.find(isRenderModeDirective)) === null || _a === void 0 ? void 0 : _a.value.value) !== null && _b !== void 0 ? _b : exports.LWCDirectiveRenderMode.shadow;
        this.preserveComments =
            (_d = (_c = root.directives.find(isPreserveCommentsDirective)) === null || _c === void 0 ? void 0 : _c.value.value) !== null && _d !== void 0 ? _d : state.config.preserveHtmlComments;
        this.scopeFragmentId = scopeFragmentId;
        this.scope = this.createScope();
        this.state = state;
    }
    generateKey() {
        return this.currentKey++;
    }
    genElement(tagName, data, children) {
        const args = [literal$1(tagName), data];
        if (!isArrayExpression(children) || children.elements.length > 0) {
            args.push(children); // only generate children if non-empty
        }
        return this._renderApiCall(RENDER_APIS.element, args);
    }
    genCustomElement(tagName, componentClass, data, children) {
        this.referencedComponents.add(tagName);
        const args = [literal$1(tagName), componentClass, data];
        if (!isArrayExpression(children) || children.elements.length > 0) {
            args.push(children); // only generate children if non-empty
        }
        return this._renderApiCall(RENDER_APIS.customElement, args);
    }
    genDynamicElement(ctor, data, children) {
        const args = [ctor, data];
        if (!isArrayExpression(children) || children.elements.length > 0) {
            args.push(children); // only generate children if non-empty
        }
        return this._renderApiCall(RENDER_APIS.dynamicCtor, args);
    }
    genDeprecatedDynamicElement(tagName, ctor, data, children) {
        const args = [literal$1(tagName), ctor, data];
        if (!isArrayExpression(children) || children.elements.length > 0) {
            args.push(children); // only generate children if non-empty
        }
        return this._renderApiCall(RENDER_APIS.deprecatedDynamicCtor, args);
    }
    genText(value) {
        const mappedValues = value.map((v) => {
            return typeof v === 'string'
                ? literal$1(v)
                : this._renderApiCall(RENDER_APIS.dynamicText, [v]);
        });
        let textConcatenation = mappedValues[0];
        for (let i = 1, n = mappedValues.length; i < n; i++) {
            textConcatenation = binaryExpression('+', textConcatenation, mappedValues[i]);
        }
        return this._renderApiCall(RENDER_APIS.text, [textConcatenation]);
    }
    genComment(value) {
        return this._renderApiCall(RENDER_APIS.comment, [literal$1(value)]);
    }
    genSanitizeHtmlContent(content) {
        return this._renderApiCall(RENDER_APIS.sanitizeHtmlContent, [content]);
    }
    genFragment(key, children, stable = false) {
        const isStable = stable ? literal$1(1) : literal$1(0);
        return this._renderApiCall(RENDER_APIS.fragment, [key, children, isStable]);
    }
    genIterator(iterable, callback) {
        return this._renderApiCall(RENDER_APIS.iterator, [iterable, callback]);
    }
    genBind(handler) {
        return this._renderApiCall(RENDER_APIS.bind, [handler]);
    }
    genFlatten(children) {
        return this._renderApiCall(RENDER_APIS.flatten, children);
    }
    genKey(compilerKey, value) {
        return this._renderApiCall(RENDER_APIS.key, [compilerKey, value]);
    }
    genScopedId(id) {
        if (typeof id === 'string') {
            return this._renderApiCall(RENDER_APIS.scopedId, [literal$1(id)]);
        }
        return this._renderApiCall(RENDER_APIS.scopedId, [id]);
    }
    genScopedFragId(id) {
        if (typeof id === 'string') {
            return this._renderApiCall(RENDER_APIS.scopedFragId, [literal$1(id)]);
        }
        return this._renderApiCall(RENDER_APIS.scopedFragId, [id]);
    }
    /**
     * Generates childs vnodes when slot content is static.
     */
    getSlot(slotName, data, children) {
        this.slotNames.add(slotName);
        return this._renderApiCall(RENDER_APIS.slot, [
            literal$1(slotName),
            data,
            children,
            identifier('$slotset'),
        ]);
    }
    /**
     * Generates a factory function that inturn generates child vnodes for scoped slot content.
     */
    getScopedSlotFactory(callback, slotName) {
        return this._renderApiCall(RENDER_APIS.scopedSlotFactory, [slotName, callback]);
    }
    genTabIndex(children) {
        return this._renderApiCall(RENDER_APIS.tabindex, children);
    }
    getMemorizationId() {
        const currentId = this.currentId++;
        const memorizationId = identifier(`_m${currentId}`);
        this.memorizedIds.push(memorizationId);
        return memorizationId;
    }
    genBooleanAttributeExpr(bindExpr) {
        return conditionalExpression(bindExpr, literal$1(''), literal$1(null));
    }
    genEventListeners(listeners) {
        const listenerObj = Object.fromEntries(listeners.map((listener) => [listener.name, listener]));
        const listenerObjectAST = objectToAST(listenerObj, (key) => {
            const componentHandler = this.bindExpression(listenerObj[key].handler);
            const handler = this.genBind(componentHandler);
            return memorizeHandler(this, componentHandler, handler);
        });
        return property$1(identifier('on'), listenerObjectAST);
    }
    genRef(ref) {
        this.hasRefs = true;
        return property$1(identifier('ref'), ref.value);
    }
    /**
     * This routine generates an expression that avoids
     * computing the sanitized html of a raw html if it does not change
     * between renders.
     *
     * @param expr
     * @returns sanitizedHtmlExpr
     */
    genSanitizedHtmlExpr(expr) {
        const instance = this.innerHtmlInstances++;
        // Optimization for static html.
        // Example input: <div lwc:inner-html="foo">
        // Output: $ctx._sanitizedHtml$0 || ($ctx._sanitizedHtml$0 = api_sanitize_html_content("foo"))
        if (isLiteral(expr)) {
            return logicalExpression('||', memberExpression(identifier(TEMPLATE_PARAMS.CONTEXT), identifier(`_sanitizedHtml$${instance}`)), assignmentExpression('=', memberExpression(identifier(TEMPLATE_PARAMS.CONTEXT), identifier(`_sanitizedHtml$${instance}`)), this.genSanitizeHtmlContent(expr)));
        }
        // Example input: <div lwc:inner-html={foo}>
        // Output: $ctx._rawHtml$0 !== ($ctx._rawHtml$0 = $cmp.foo)
        //             ? ($ctx._sanitizedHtml$0 = api_sanitize_html_content($cmp.foo))
        //             : $ctx._sanitizedHtml$0
        //
        // Note: In the case of iterations, when the lwc:inner-html bound value depends on the
        //       iteration item, the generated expression won't be enough, and `sanitizeHtmlContent`
        //       will be called every time because this expression is based on the specific template
        //       usage of the lwc:inner-html, and in an iteration, usages are dynamically generated.
        return conditionalExpression(binaryExpression('!==', memberExpression(identifier(TEMPLATE_PARAMS.CONTEXT), identifier(`_rawHtml$${instance}`)), assignmentExpression('=', memberExpression(identifier(TEMPLATE_PARAMS.CONTEXT), identifier(`_rawHtml$${instance}`)), expr)), assignmentExpression('=', memberExpression(identifier(TEMPLATE_PARAMS.CONTEXT), identifier(`_sanitizedHtml$${instance}`)), this.genSanitizeHtmlContent(expr)), memberExpression(identifier(TEMPLATE_PARAMS.CONTEXT), identifier(`_sanitizedHtml$${instance}`)));
    }
    _renderApiCall(primitive, params) {
        const { name, alias } = primitive;
        let identifier$1 = this.usedApis[name];
        if (!identifier$1) {
            identifier$1 = this.usedApis[name] = identifier(alias);
        }
        return callExpression(identifier$1, params);
    }
    beginScope() {
        this.scope = this.createScope(this.scope);
    }
    createScope(parent = null) {
        return {
            parent,
            declaration: new Set(),
        };
    }
    endScope() {
        /* istanbul ignore if */
        if (!this.scope.parent) {
            throw new Error("Can't invoke endScope if the current scope has no parent");
        }
        this.scope = this.scope.parent;
    }
    declareIdentifier(identifier) {
        this.scope.declaration.add(identifier.name);
    }
    /**
     * Searches the scopes to find an identifier with a matching name.
     */
    isLocalIdentifier(identifier) {
        let scope = this.scope;
        while (scope !== null) {
            if (scope.declaration.has(identifier.name)) {
                return true;
            }
            scope = scope.parent;
        }
        return false;
    }
    /**
     * Bind the passed expression to the component instance. It applies the following transformation to the expression:
     * - {value} --> {$cmp.value}
     * - {value[index]} --> {$cmp.value[$cmp.index]}
     */
    bindExpression(expression) {
        if (isIdentifier(expression)) {
            if (!this.isLocalIdentifier(expression)) {
                return memberExpression(identifier(TEMPLATE_PARAMS.INSTANCE), expression);
            }
            else {
                return expression;
            }
        }
        // TODO [#3370]: remove experimental template expression flag
        if (this.state.config.experimentalComplexExpressions) {
            return bindComplexExpression(expression, this);
        }
        const scope = this;
        estreeWalker.walk(expression, {
            leave(node, parent) {
                if (parent !== null &&
                    isIdentifier(node) &&
                    isMemberExpression(parent) &&
                    parent.object === node &&
                    !scope.isLocalIdentifier(node)) {
                    this.replace(memberExpression(identifier(TEMPLATE_PARAMS.INSTANCE), node));
                }
            },
        });
        return expression;
    }
    genStaticElement(element, slotParentName) {
        const key = slotParentName !== undefined
            ? `@${slotParentName}:${this.generateKey()}`
            : this.generateKey();
        const html = serializeStaticElement(element, this.preserveComments);
        const parseMethod = element.name !== 'svg' && element.namespace === shared.SVG_NAMESPACE
            ? PARSE_SVG_FRAGMENT_METHOD_NAME
            : PARSE_FRAGMENT_METHOD_NAME;
        this.usedLwcApis.add(parseMethod);
        // building the taggedTemplate expression as if it were a string
        const expr = taggedTemplateExpression(identifier(parseMethod), templateLiteral([
            {
                type: 'TemplateElement',
                tail: true,
                value: {
                    raw: html,
                    cooked: html,
                },
            },
        ], []));
        const identifier$1 = identifier(`$fragment${this.hoistedNodes.length + 1}`);
        this.hoistedNodes.push({
            identifier: identifier$1,
            expr,
        });
        const args = [callExpression(identifier$1, []), literal$1(key)];
        // Only add the third argument (databag) if this element needs it
        if (element.listeners.length || element.directives.length) {
            const databagProperties = [];
            // has event listeners
            if (element.listeners.length) {
                databagProperties.push(this.genEventListeners(element.listeners));
            }
            // see STATIC_SAFE_DIRECTIVES for what's allowed here
            for (const directive of element.directives) {
                if (directive.name === 'Ref') {
                    databagProperties.push(this.genRef(directive));
                }
            }
            args.push(objectExpression(databagProperties));
        }
        return this._renderApiCall(RENDER_APIS.staticFragment, args);
    }
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function kebabcaseToCamelcase(name) {
    const newName = [];
    let nsFound = false;
    let upper = false;
    for (let i = 0; i < name.length; i++) {
        if (name[i] === '-') {
            if (!nsFound) {
                nsFound = true;
                newName.push('/');
            }
            else {
                upper = true;
            }
        }
        else {
            newName.push(upper ? name[i].toUpperCase() : name[i]);
            upper = false;
        }
    }
    return newName.join('');
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Given a template function, extract all static objects/arrays (e.g. `{ key : 1 }`)
 * and return them as a list of `const` declarations. Also return the modified function
 * that is now referencing those declarations.
 *
 * Example input:
 *
 * ```
 * function tmpl() {
 *   return {
 *     foo: dynamic(),
 *     bar: { static: true },
 *     baz: { really: { static: ['yep', 'totally', 'static' ] } }
 *   };
 * }
 * ```
 *
 * Example output:
 *
 * ```
 * const stc0 = { static: true };
 * const stc1 = { really: { static: ['yep', 'totally', 'static' ] } };
 * function tmpl() {
 *   return {
 *     foo: dynamic(),
 *     bar: stc0,
 *     baz: stc1
 *   };
 * }
 * ```
 */
function optimizeStaticExpressions(templateFn) {
    const result = [];
    const keysToVariableNames = new Map();
    // Return true if this node is an object/array that is fully static
    function isStaticObjectOrArray(node) {
        if (isObjectExpression(node)) {
            return node.properties.every((prop) => {
                return (isProperty$1(prop) &&
                    !prop.computed &&
                    !prop.method &&
                    !prop.shorthand &&
                    (isLiteral(prop.value) || isStaticObjectOrArray(prop.value)));
            });
        }
        else if (isArrayExpression(node)) {
            return node.elements.every((element) => {
                return element !== null && (isLiteral(element) || isStaticObjectOrArray(element));
            });
        }
        return false;
    }
    function extractStaticVariable(node) {
        // This key generation can probably be improved using a hash code, but stringification is
        // simplest for finding a unique identifier for an object/array expression
        const key = astring__namespace.generate(node);
        // Check for duplicates to avoid re-declaring the same object/array multiple times
        // Especially for the empty array (`[]`), which is very common in templates
        if (!keysToVariableNames.has(key)) {
            const variableName = `stc${keysToVariableNames.size}`;
            // e.g. `const stc0 = { /* original object */ };
            const declaration = variableDeclaration('const', [
                variableDeclarator(identifier(variableName), node),
            ]);
            result.push(declaration);
            keysToVariableNames.set(key, variableName);
        }
        return identifier(keysToVariableNames.get(key));
    }
    estreeWalker.walk(templateFn, {
        enter(node) {
            // For deeply-nested static object, we only want to extract the top-level node
            if (isStaticObjectOrArray(node)) {
                const newNode = extractStaticVariable(node);
                this.replace(newNode);
                this.skip();
            }
        },
    });
    result.push(templateFn);
    return result;
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function generateComponentImports(codeGen) {
    return Array.from(codeGen.referencedComponents).map((name) => {
        const localIdentifier = identifierFromComponentName(name);
        return importDeclaration([importDefaultSpecifier(localIdentifier)], literal$1(kebabcaseToCamelcase(name)));
    });
}
function generateLwcApisImport(codeGen) {
    const imports = Array.from(codeGen.usedLwcApis)
        .sort()
        .map((name) => {
        return importSpecifier(identifier(name), identifier(name));
    });
    return importDeclaration(imports, literal$1(LWC_MODULE_NAME));
}
function generateHoistedNodes(codegen) {
    return codegen.hoistedNodes.map(({ identifier, expr }) => {
        return variableDeclaration('const', [variableDeclarator(identifier, expr)]);
    });
}
/**
 * Generate an ES module AST from a template ESTree AST. The generated module imports the dependent
 * LWC components via import statements and expose the template function via a default export
 * statement.
 *
 * @example
 * ```js
 * import { registerTemplate } from 'lwc';
 * // Components imports
 *
 * function tmpl() {
 *   // Template generated code
 * }
 * // Template metadata
 *
 * export default tmpl;
 * registerTemplate(tmpl);
 * ```
 */
function format(templateFn, codeGen) {
    codeGen.usedLwcApis.add(SECURE_REGISTER_TEMPLATE_METHOD_NAME);
    const imports = [...generateComponentImports(codeGen), generateLwcApisImport(codeGen)];
    const hoistedNodes = generateHoistedNodes(codeGen);
    const metadata = generateTemplateMetadata(codeGen);
    const optimizedTemplateDeclarations = optimizeStaticExpressions(templateFn);
    const templateBody = [
        ...optimizedTemplateDeclarations,
        exportDefaultDeclaration(callExpression(identifier(SECURE_REGISTER_TEMPLATE_METHOD_NAME), [
            identifier(TEMPLATE_FUNCTION_NAME),
        ])),
    ];
    return program([...imports, ...hoistedNodes, ...templateBody, ...metadata]);
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function transform(codeGen) {
    const instrumentation = codeGen.state.config.instrumentation;
    function transformElement(element, slotParentName) {
        const databag = elementDataBag(element, slotParentName);
        let res;
        if (codeGen.staticNodes.has(element) && isElement(element)) {
            // do not process children of static nodes.
            return codeGen.genStaticElement(element, slotParentName);
        }
        const children = transformChildren(element);
        const { name } = element;
        // lwc:dynamic directive
        const deprecatedDynamicDirective = element.directives.find(isDynamicDirective);
        // lwc:is directive
        const dynamicDirective = element.directives.find(isLwcIsDirective);
        if (deprecatedDynamicDirective) {
            const expression = codeGen.bindExpression(deprecatedDynamicDirective.value);
            res = codeGen.genDeprecatedDynamicElement(name, expression, databag, children);
        }
        else if (dynamicDirective) {
            const expression = codeGen.bindExpression(dynamicDirective.value);
            res = codeGen.genDynamicElement(expression, databag, children);
        }
        else if (isComponent(element)) {
            res = codeGen.genCustomElement(name, identifierFromComponentName(name), databag, children);
        }
        else if (isSlot(element)) {
            const defaultSlot = children;
            res = codeGen.getSlot(element.slotName, databag, defaultSlot);
        }
        else {
            res = codeGen.genElement(name, databag, children);
        }
        return res;
    }
    function transformText(consecutiveText) {
        return codeGen.genText(consecutiveText.map(({ value }) => {
            return isStringLiteral(value) ? value.value : codeGen.bindExpression(value);
        }));
    }
    function transformComment(comment) {
        return codeGen.genComment(comment.value);
    }
    function transformChildren(parent) {
        const res = [];
        const children = parent.children;
        const childrenIterator = children[Symbol.iterator]();
        let current;
        while ((current = childrenIterator.next()) && !current.done) {
            let child = current.value;
            if (isText(child)) {
                const continuousText = [];
                // Consume all the contiguous text nodes.
                do {
                    continuousText.push(child);
                    current = childrenIterator.next();
                    child = current.value;
                } while (!current.done && isText(child));
                res.push(transformText(continuousText));
                // Early exit if a text node is the last child node.
                if (current.done) {
                    break;
                }
            }
            if (isForBlock(child)) {
                res.push(transformForBlock(child));
            }
            else if (isIf(child)) {
                const children = transformIf(child);
                Array.isArray(children) ? res.push(...children) : res.push(children);
            }
            else if (isBaseElement(child)) {
                const slotParentName = isSlot(parent) ? parent.slotName : undefined;
                res.push(transformElement(child, slotParentName));
            }
            else if (isComment(child) && codeGen.preserveComments) {
                res.push(transformComment(child));
            }
            else if (isIfBlock(child)) {
                res.push(transformConditionalParentBlock(child));
            }
            else if (isScopedSlotFragment(child)) {
                res.push(transformScopedSlotFragment(child));
            }
        }
        if (shouldFlatten(codeGen, children)) {
            if (children.length === 1) {
                return res[0];
            }
            else {
                return codeGen.genFlatten([arrayExpression(res)]);
            }
        }
        else {
            return arrayExpression(res);
        }
    }
    function transformScopedSlotFragment(scopedSlotFragment) {
        const { slotName, slotData: { value: dataIdentifier }, } = scopedSlotFragment;
        codeGen.beginScope();
        codeGen.declareIdentifier(dataIdentifier);
        // At runtime, the 'key' of the <slot> element will be propagated to the fragment vnode
        // produced by the ScopedSlotFactory
        const key = identifier('key');
        codeGen.declareIdentifier(key);
        const fragment = codeGen.genFragment(key, transformChildren(scopedSlotFragment));
        codeGen.endScope();
        // The factory is invoked with two parameters:
        // 1. The value of the binding specified in lwc:slot-bind directive
        // 2. The key to be applied to the fragment vnode, this will be used for diffing
        const slotFragmentFactory = functionExpression(null, [dataIdentifier, key], blockStatement([returnStatement(fragment)]));
        let slotNameTransformed;
        if (isLiteral(slotName)) {
            slotNameTransformed = literal$1(slotName.value);
        }
        else {
            slotNameTransformed = codeGen.bindExpression(slotName);
        }
        return codeGen.getScopedSlotFactory(slotFragmentFactory, slotNameTransformed);
    }
    function transformIf(ifNode) {
        const expression = transformChildren(ifNode);
        let res;
        if (isArrayExpression(expression)) {
            // Bind the expression once for all the template children
            const testExpression = codeGen.bindExpression(ifNode.condition);
            res = arrayExpression(expression.elements.map((element) => element !== null
                ? applyInlineIf(ifNode, element, testExpression)
                : null));
        }
        else {
            // If the template has a single children, make sure the ternary expression returns an array
            res = applyInlineIf(ifNode, expression, undefined, arrayExpression([]));
        }
        if (isArrayExpression(res)) {
            // The `if` transformation does not use the SpreadElement, neither null, therefore we can safely
            // typecast it to t.Expression[]
            res = res.elements;
        }
        return res;
    }
    /**
     * Transforms an IfBlock or ElseifBlock along with both its direct descendants and its 'else' descendants.
     *
     * @param conditionalParentBlock The IfBlock or ElseifBlock to transform into a conditional expression
     * @param key The key to use for this chain of IfBlock/ElseifBlock branches, if applicable
     * @returns A conditional expression representing the full conditional tree with conditionalParentBlock as the root node
     */
    function transformConditionalParentBlock(conditionalParentBlock, key) {
        const ifBlockKey = key !== null && key !== void 0 ? key : codeGen.generateKey();
        const childrenExpression = codeGen.genFragment(literal$1(ifBlockKey), transformChildren(conditionalParentBlock));
        let elseExpression = literal$1(null);
        if (conditionalParentBlock.else) {
            elseExpression = isElseifBlock(conditionalParentBlock.else)
                ? transformConditionalParentBlock(conditionalParentBlock.else, ifBlockKey)
                : codeGen.genFragment(literal$1(ifBlockKey), transformChildren(conditionalParentBlock.else));
        }
        return conditionalExpression(codeGen.bindExpression(conditionalParentBlock.condition), childrenExpression, elseExpression);
    }
    function applyInlineIf(ifNode, node, testExpression, falseValue) {
        if (!testExpression) {
            testExpression = codeGen.bindExpression(ifNode.condition);
        }
        let leftExpression;
        const modifier = ifNode.modifier;
        /* istanbul ignore else */
        if (modifier === 'true') {
            leftExpression = testExpression;
        }
        else if (modifier === 'false') {
            leftExpression = unaryExpression('!', testExpression);
        }
        else if (modifier === 'strict-true') {
            leftExpression = binaryExpression('===', testExpression, literal$1(true));
        }
        else {
            // This is a defensive check, should be taken care of during parsing.
            throw errors.generateCompilerError(errors.TemplateErrors.UNKNOWN_IF_MODIFIER, {
                messageArgs: [modifier],
            });
        }
        return conditionalExpression(leftExpression, node, falseValue !== null && falseValue !== void 0 ? falseValue : literal$1(null));
    }
    function transformForBlock(forBlock) {
        let expression = transformForChildren(forBlock);
        if (isArrayExpression(expression) && expression.elements.length === 1) {
            expression = expression.elements[0];
        }
        let res;
        if (isForEach(forBlock)) {
            res = applyInlineFor(forBlock, expression);
        }
        else {
            res = applyInlineForOf(forBlock, expression);
        }
        return res;
    }
    function transformForChildren(forBlock) {
        codeGen.beginScope();
        if (isForEach(forBlock)) {
            const { item, index } = forBlock;
            if (index) {
                codeGen.declareIdentifier(index);
            }
            codeGen.declareIdentifier(item);
        }
        else {
            codeGen.declareIdentifier(forBlock.iterator);
        }
        const children = transformChildren(forBlock);
        codeGen.endScope();
        return children;
    }
    function applyInlineFor(forEach, node) {
        const { expression, item, index } = forEach;
        const params = [item];
        if (index) {
            params.push(index);
        }
        const iterable = codeGen.bindExpression(expression);
        const iterationFunction = functionExpression(null, params, blockStatement([returnStatement(node)]));
        return codeGen.genIterator(iterable, iterationFunction);
    }
    function applyInlineForOf(forOf, node) {
        const { expression, iterator } = forOf;
        const { name: iteratorName } = iterator;
        const argsMapping = {
            value: `${iteratorName}Value`,
            index: `${iteratorName}Index`,
            first: `${iteratorName}First`,
            last: `${iteratorName}Last`,
        };
        const iteratorArgs = Object.values(argsMapping).map((arg) => identifier(arg));
        const iteratorObject = objectExpression(Object.entries(argsMapping).map(([prop, arg]) => property$1(identifier(prop), identifier(arg))));
        const iterable = codeGen.bindExpression(expression);
        const iterationFunction = functionExpression(null, iteratorArgs, blockStatement([
            variableDeclaration('const', [
                variableDeclarator(identifier(iteratorName), iteratorObject),
            ]),
            returnStatement(node),
        ]));
        return codeGen.genIterator(iterable, iterationFunction);
    }
    function computeAttrValue(attr, element, addLegacySanitizationHook) {
        const { name: elmName, namespace = '' } = element;
        const { value: attrValue } = attr;
        // Evaluate properties based on their attribute name
        const attrName = isProperty(attr) ? attr.attributeName : attr.name;
        const isUsedAsAttribute = isAttribute(element, attrName);
        if (isExpression$1(attrValue)) {
            const expression = codeGen.bindExpression(attrValue);
            // TODO [#2012]: Normalize global boolean attrs values passed to custom elements as props
            if (isUsedAsAttribute && shared.isBooleanAttribute(attrName, elmName)) {
                // We need to do some manipulation to allow the diffing algorithm add/remove the attribute
                // without handling special cases at runtime.
                return codeGen.genBooleanAttributeExpr(expression);
            }
            if (attrName === 'tabindex') {
                return codeGen.genTabIndex([expression]);
            }
            if (attrName === 'id' || isIdReferencingAttribute(attrName)) {
                return codeGen.genScopedId(expression);
            }
            if (codeGen.scopeFragmentId &&
                isAllowedFragOnlyUrlsXHTML(elmName, attrName, namespace)) {
                return codeGen.genScopedFragId(expression);
            }
            if (isSvgUseHref(elmName, attrName, namespace)) {
                if (addLegacySanitizationHook) {
                    codeGen.usedLwcApis.add('sanitizeAttribute');
                    return callExpression(identifier('sanitizeAttribute'), [
                        literal$1(elmName),
                        literal$1(namespace),
                        literal$1(attrName),
                        codeGen.genScopedFragId(expression),
                    ]);
                }
                return codeGen.genScopedFragId(expression);
            }
            return expression;
        }
        else if (isStringLiteral(attrValue)) {
            if (attrName === 'id') {
                return codeGen.genScopedId(attrValue.value);
            }
            if (attrName === 'spellcheck') {
                return literal$1(attrValue.value.toLowerCase() !== 'false');
            }
            if (!isUsedAsAttribute && shared.isBooleanAttribute(attrName, elmName)) {
                // We are in presence of a string value, for a recognized boolean attribute, which is used as
                // property. for these cases, always set the property to true.
                return literal$1(true);
            }
            if (isIdReferencingAttribute(attrName)) {
                return codeGen.genScopedId(attrValue.value);
            }
            if (codeGen.scopeFragmentId &&
                isAllowedFragOnlyUrlsXHTML(elmName, attrName, namespace) &&
                isFragmentOnlyUrl(attrValue.value)) {
                return codeGen.genScopedFragId(attrValue.value);
            }
            if (isSvgUseHref(elmName, attrName, namespace)) {
                // apply the fragment id tranformation if necessary
                const value = isFragmentOnlyUrl(attrValue.value)
                    ? codeGen.genScopedFragId(attrValue.value)
                    : literal$1(attrValue.value);
                if (addLegacySanitizationHook) {
                    codeGen.usedLwcApis.add('sanitizeAttribute');
                    return callExpression(identifier('sanitizeAttribute'), [
                        literal$1(elmName),
                        literal$1(namespace),
                        literal$1(attrName),
                        value,
                    ]);
                }
                return value;
            }
            return literal$1(attrValue.value);
        }
        else {
            // A boolean value used in an attribute should always generate .setAttribute(attr.name, ''),
            // regardless if is a boolean attribute or not.
            return isUsedAsAttribute ? literal$1('') : literal$1(attrValue.value);
        }
    }
    function elementDataBag(element, slotParentName) {
        const data = [];
        const { attributes, properties, listeners } = element;
        const innerHTML = element.directives.find(isInnerHTMLDirective);
        const forKey = element.directives.find(isKeyDirective);
        const dom = element.directives.find(isDomDirective);
        const ref = element.directives.find(isRefDirective);
        const spread = element.directives.find(isSpreadDirective);
        const addSanitizationHook = isCustomRendererHookRequired(element, codeGen.state);
        const slotBindDirective = element.directives.find(isSlotBindDirective);
        // Attributes
        if (attributes.length) {
            const rest = {};
            for (const attr of attributes) {
                const { name, value } = attr;
                if (name === 'class') {
                    // Handle class attribute:
                    // - expression values are turned into a `className` property.
                    // - string values are parsed and turned into a `classMap` object associating
                    //   each individual class name with a `true` boolean.
                    if (isExpression$1(value)) {
                        const classExpression = codeGen.bindExpression(value);
                        data.push(property$1(identifier('className'), classExpression));
                    }
                    else if (isStringLiteral(value)) {
                        const classNames = parseClassNames(value.value);
                        const classMap = objectExpression(classNames.map((name) => property$1(literal$1(name), literal$1(true))));
                        data.push(property$1(identifier('classMap'), classMap));
                    }
                }
                else if (name === 'style') {
                    // Handle style attribute:
                    // - expression values are turned into a `style` property.
                    // - string values are parsed and turned into a `styles` array
                    // containing triples of [name, value, important (optional)]
                    if (isExpression$1(value)) {
                        const styleExpression = codeGen.bindExpression(value);
                        data.push(property$1(identifier('style'), styleExpression));
                    }
                    else if (isStringLiteral(value)) {
                        const styleMap = parseStyleText(value.value);
                        const styleAST = styleMapToStyleDeclsAST(styleMap);
                        data.push(property$1(identifier('styleDecls'), styleAST));
                    }
                }
                else {
                    rest[name] = computeAttrValue(attr, element, !addSanitizationHook);
                }
            }
            // Add all the remaining attributes to an `attrs` object where the key is the attribute
            // name and the value is the computed attribute value.
            if (Object.keys(rest).length) {
                const attrsObj = objectToAST(rest, (key) => rest[key]);
                data.push(property$1(identifier('attrs'), attrsObj));
            }
        }
        // Properties
        const propsObj = objectExpression([]);
        // Properties
        if (properties.length) {
            for (const prop of properties) {
                propsObj.properties.push(property$1(literal$1(prop.name), computeAttrValue(prop, element, !addSanitizationHook)));
            }
        }
        // Properties: lwc:inner-html directive
        if (innerHTML) {
            const expr = isStringLiteral(innerHTML.value)
                ? literal$1(innerHTML.value.value)
                : codeGen.bindExpression(innerHTML.value);
            propsObj.properties.push(property$1(identifier('innerHTML'), 
            // If lwc:inner-html is added as a directive requiring custom renderer, no need
            // to add the legacy sanitizeHtmlContent hook
            addSanitizationHook ? expr : codeGen.genSanitizedHtmlExpr(expr)));
        }
        // Properties: lwc:ref directive
        if (ref) {
            data.push(codeGen.genRef(ref));
        }
        if (propsObj.properties.length) {
            data.push(property$1(identifier('props'), propsObj));
        }
        // Context
        if (dom || innerHTML) {
            const contextObj = objectExpression([
                property$1(identifier('lwc'), objectExpression([property$1(identifier('dom'), literal$1('manual'))])),
            ]);
            data.push(property$1(identifier('context'), contextObj));
        }
        // Spread
        if (spread) {
            data.push(property$1(identifier('spread'), codeGen.bindExpression(spread.value)));
            instrumentation === null || instrumentation === void 0 ? void 0 : instrumentation.incrementCounter(errors.CompilerMetrics.LWCSpreadDirective);
        }
        // Key property on VNode
        if (forKey) {
            // If element has user-supplied `key` or is in iterator, call `api.k`
            const forKeyExpression = codeGen.bindExpression(forKey.value);
            const generatedKey = codeGen.genKey(literal$1(codeGen.generateKey()), forKeyExpression);
            data.push(property$1(identifier('key'), generatedKey));
        }
        else {
            // If standalone element with no user-defined key
            let key = codeGen.generateKey();
            // Parent slot name could be the empty string
            if (slotParentName !== undefined) {
                // Prefixing the key is necessary to avoid conflicts with default content for the
                // slot which might have similar keys. Each vnode will always have a key that starts
                // with a numeric character from compiler. In this case, we add a unique notation
                // for slotted vnodes keys, e.g.: `@foo:1:1`. Note that this is *not* needed for
                // dynamic keys, since `api.k` already scopes based on the iteration.
                key = `@${slotParentName}:${key}`;
            }
            data.push(property$1(identifier('key'), literal$1(key)));
        }
        // Event handler
        if (listeners.length) {
            data.push(codeGen.genEventListeners(listeners));
        }
        // SVG handling
        if (element.namespace === shared.SVG_NAMESPACE) {
            data.push(property$1(identifier('svg'), literal$1(true)));
        }
        if (addSanitizationHook) {
            codeGen.usedLwcApis.add(RENDERER);
            data.push(property$1(identifier(RENDERER), identifier(RENDERER)));
        }
        if (!shared.isUndefined(slotBindDirective)) {
            data.push(property$1(identifier('slotData'), codeGen.bindExpression(slotBindDirective.value)));
        }
        if (isExternalComponent(element)) {
            data.push(property$1(identifier('external'), literal$1(true)));
        }
        return objectExpression(data);
    }
    return transformChildren(codeGen.root);
}
function generateTemplateFunction(codeGen) {
    const returnedValue = transform(codeGen);
    const args = [
        TEMPLATE_PARAMS.API,
        TEMPLATE_PARAMS.INSTANCE,
        TEMPLATE_PARAMS.SLOT_SET,
        TEMPLATE_PARAMS.CONTEXT,
    ].map((id) => identifier(id));
    const usedApis = Object.keys(codeGen.usedApis);
    const body = usedApis.length === 0
        ? []
        : [
            variableDeclaration('const', [
                variableDeclarator(objectPattern(usedApis.map((name) => assignmentProperty(identifier(name), codeGen.usedApis[name]))), identifier(TEMPLATE_PARAMS.API)),
            ]),
        ];
    if (codeGen.memorizedIds.length) {
        body.push(variableDeclaration('const', [
            variableDeclarator(objectPattern(codeGen.memorizedIds.map((id) => assignmentProperty(id, id, { shorthand: true }))), identifier(TEMPLATE_PARAMS.CONTEXT)),
        ]));
    }
    body.push(returnStatement(returnedValue));
    return functionDeclaration(identifier(TEMPLATE_FUNCTION_NAME), args, blockStatement(body, {
        trailingComments: [comment$1(shared.LWC_VERSION_COMMENT)],
    }));
}
function generate (root, state) {
    const scopeFragmentId = hasIdAttribute(root);
    const codeGen = new CodeGen({
        root,
        state,
        scopeFragmentId,
    });
    const templateFunction = generateTemplateFunction(codeGen);
    const program = format(templateFunction, codeGen);
    return astring__namespace.generate(program, { comments: true });
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function parse(source, config = {}) {
    const options = normalizeConfig(config);
    const state = new State(options);
    return parse$1(source, state);
}
function compile(source, config) {
    const options = normalizeConfig(config);
    const state = new State(options);
    let code = '';
    let root;
    const warnings = [];
    try {
        const parsingResults = parse$1(source, state);
        warnings.push(...parsingResults.warnings);
        const hasParsingError = parsingResults.warnings.some((warning) => warning.level === errors.DiagnosticLevel.Error);
        if (!hasParsingError && parsingResults.root) {
            code = generate(parsingResults.root, state);
            root = parsingResults.root;
        }
    }
    catch (error) {
        const diagnostic = errors.normalizeToDiagnostic(errors.ParserDiagnostics.GENERIC_PARSING_ERROR, error);
        diagnostic.message = `Unexpected compilation error: ${diagnostic.message}`;
        warnings.push(diagnostic);
    }
    return {
        code,
        root,
        warnings,
    };
}

exports.compile = compile;
exports.default = compile;
exports.parse = parse;
/** version: 2.50.0 */
//# sourceMappingURL=index.cjs.js.map

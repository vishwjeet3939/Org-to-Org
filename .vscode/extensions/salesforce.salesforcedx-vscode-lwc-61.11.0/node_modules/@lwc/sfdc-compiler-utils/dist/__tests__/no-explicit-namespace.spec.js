"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const namespace_utils_1 = require("../namespace-utils");
describe('disallow references with an explicit namespace', () => {
    describe('negative cases', () => {
        test('should throw when invocation is misconfigured', () => {
            expect(() => (0, namespace_utils_1.containsExplicitNamespace)(undefined, 'a', 'b')).toThrowError('Failed to check explicit namespace usage.' +
                'Expected string values for "value", "type", and "explicitNamespace" ' +
                'parameters, received "undefined," "a", "b".');
        });
        test('should throw on processing unsupported reference type', () => {
            expect(() => (0, namespace_utils_1.containsExplicitNamespace)('label', 'bar', 'nsC')).toThrowError('Unsupported reference type bar');
        });
    });
    describe('reference types that do not have namespace', () => {
        test('"client" type should return false', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('formFactor', 'client', 'c');
            expect(actual).toBe(false);
        });
        test('"cssvars" type should return false', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('customProperties', 'cssvars', 'c');
            expect(actual).toBe(false);
        });
        test('"i18n" type should return false', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('id', 'i18n', 'c');
            expect(actual).toBe(false);
        });
        test('"slds" type should return false', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('index.css', 'slds', 'c');
            expect(actual).toBe(false);
        });
        test('"user" type should return false', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('id', 'user', 'c');
            expect(actual).toBe(false);
        });
        test('"userPermission" type should return false', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('ViewSetup', 'userPermission', 'c');
            expect(actual).toBe(false);
        });
        test('"gate" type should return false', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('foo.bar.gate.name', 'gate', 'c');
            expect(actual).toBe(false);
        });
        test('"metric" type should return false', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('foo.bar.metric.name', 'metric', 'c');
            expect(actual).toBe(false);
        });
        test('"internal" type should return false', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('id', 'internal', 'c');
            expect(actual).toBe(false);
        });
    });
    describe('explicit namespace in label', () => {
        test('should return "false" when not using namespace and explicit value is "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('label', 'label', 'c');
            expect(actual).toBe(false);
        });
        test('should return "true" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC.label', 'label', 'nsC');
            expect(actual).toBe(true);
        });
        test('should return "false" when explicit parameter value is "c" and the reference is explicit ', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC.label', 'label', 'c');
            expect(actual).toBe(false);
        });
        test('should return "false" when references value has default namespace', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c.label', 'label', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when not using namespace at all', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('label', 'label', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when both explicit namespace and reference use "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c.label', 'label', 'c');
            expect(actual).toBe(false);
        });
    });
    describe('explicit namespace in resourceUrl', () => {
        test('should return "false" when not using namespace and explicit value is "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('resource', 'resourceUrl', 'c');
            expect(actual).toBe(false);
        });
        test('should return "true" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC__resource', 'resourceUrl', 'nsC');
            expect(actual).toBe(true);
        });
        test('should return "false" when using default namespace in the reference', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c__resourceUrl', 'resourceUrl', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('resource', 'resourceUrl', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when explicit parameter value is "c" but the reference is explicit ', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC__resourceUrl', 'resourceUrl', 'c');
            expect(actual).toBe(false);
        });
        test('should return "false" when both explicit namespace and reference use "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c__resourceUrl', 'resourceUrl', 'c');
            expect(actual).toBe(false);
        });
    });
    describe('explicit namespace in contentAssetUrl', () => {
        test('should return "false" when not using namespace and explicit value is "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('asset', 'contentAssetUrl', 'c');
            expect(actual).toBe(false);
        });
        test('should return "true" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC__asset', 'contentAssetUrl', 'nsC');
            expect(actual).toBe(true);
        });
        test('should return "false" when using default namespace in the reference', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c__asset', 'contentAssetUrl', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('asset', 'contentAssetUrl', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "true" when explicit parameter value is "c" but the reference is explicit ', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC__asset', 'contentAssetUrl', 'c');
            expect(actual).toBe(false);
        });
        test('should return "false" when both explicit namespace and reference use "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c__asset', 'contentAssetUrl', 'c');
            expect(actual).toBe(false);
        });
    });
    describe('explicit namespace in customPermission', () => {
        test('should return "false" when not using namespace and explicit value is "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('perm', 'customPermission', 'c');
            expect(actual).toBe(false);
        });
        test('should return "true" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC__customPermission', 'customPermission', 'nsC');
            expect(actual).toBe(true);
        });
        test('should return "false" when using default namespace in the reference', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c__customPermission', 'customPermission', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('perm', 'customPermission', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when explicit parameter value is "c" but the reference is explicit ', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC__customPermission', 'customPermission', 'c');
            expect(actual).toBe(false);
        });
        test('should return "false" when both explicit namespace and reference use "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c__customPermission', 'customPermission', 'c');
            expect(actual).toBe(false);
        });
    });
    describe('explicit namespace in apexMethod', () => {
        test('should return "false" when not using namespace and explicit value is "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('MyClass.methodA', 'apexMethod', 'c');
            expect(actual).toBe(false);
        });
        test('should return "true" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC.MyClass.methodA', 'apexMethod', 'nsC');
            expect(actual).toBe(true);
        });
        test('should return "false" when using default namespace in the reference', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c.MyClass.methodA', 'apexMethod', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when not using namespace at all', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('MyClass.methodA', 'apexMethod', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when explicit parameter value is "c" but the reference is explicit ', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC.MyClass.methodA', 'apexMethod', 'c');
            expect(actual).toBe(false);
        });
        test('should return "false" when both explicit namespace and reference use "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c.MyClass.methodA', 'apexMethod', 'c');
            expect(actual).toBe(false);
        });
    });
    describe('explicit namespace in schema', () => {
        test('should return "false" when not using namespace and explicit value is "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('CustomObject__c', 'schema', 'c');
            expect(actual).toBe(false);
        });
        test('should return "true" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC__CustomObject__c.nsC__parentContact__r.Account.Name', 'schema', 'nsC');
            expect(actual).toBe(true);
        });
        test('should return "false" when references value has default namespace', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c__CustomObject__c.c__parentContact__r.Account.Name', 'schema', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "true" when using mixed resource contains explicit namespace', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c__CustomObject__c.nsC__parentContact__r.Account.Name', 'schema', 'nsC');
            expect(actual).toBe(true);
        });
        test('should return "false" when not using namespace at all', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('MyClass.methodA', 'schema', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when explicit parameter value is "c" but the reference is explicit ', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC__CustomObject__c.nsC__parentContact__r.Account.Name', 'schema', 'c');
            expect(actual).toBe(false);
        });
        test('should return "false" when both explicit namespace and reference use "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c__CustomObject__c.nsC__parentContact__r.Account.Name', 'schema', 'c');
            expect(actual).toBe(false);
        });
    });
    describe('explicit namespace in module', () => {
        test('should return "true" when not using default namespace and reference is explicit', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC/utils', 'module', 'nsC');
            expect(actual).toBe(true);
        });
        test('should return "false" when references value has default namespace', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c/utils', 'module', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when explicit parameter value is "c" but the reference is explicit ', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsC/utils', 'module', 'c');
            expect(actual).toBe(false);
        });
        test('should return "false" when both explicit namespace and reference use "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c/utils', 'module', 'c');
            expect(actual).toBe(false);
        });
        test('should return "false" when module does not have namespace and explicit value is "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('lwc', 'module', 'c');
            expect(actual).toBe(false);
        });
    });
    describe('explicit namespace in component', () => {
        test('should return "true" when using explicit namespace', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('explicit-child-tag', 'component', 'explicit');
            expect(actual).toBe(true);
        });
        test('should return "true" when using camel-cased namespace', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('nsc-child-tag', 'component', 'nsC');
            expect(actual).toBe(true);
        });
        test('should return "false" when using default namespace in the reference', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c-child-tag', 'component', 'nsC');
            expect(actual).toBe(false);
        });
        test('should return "false" when explicit parameter value is "c" but the reference is explicit ', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('explicit-child-tag', 'component', 'c');
            expect(actual).toBe(false);
        });
        test('should return "false" when both explicit namespace and reference use "c"', () => {
            const actual = (0, namespace_utils_1.containsExplicitNamespace)('c-child-tag', 'component', 'c');
            expect(actual).toBe(false);
        });
    });
});
//# sourceMappingURL=no-explicit-namespace.spec.js.map
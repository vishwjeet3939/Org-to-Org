"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findDynamicContent = exports.Token = exports.iteratorRegex = exports.propertyRegex = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const path_1 = require("path");
const compiler_1 = require("./javascript/compiler");
const aura_data_provider_1 = require("./aura-data-provider");
const lwc_data_provider_1 = require("./lwc-data-provider");
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const component_indexer_1 = __importDefault(require("./component-indexer"));
const typing_indexer_1 = __importDefault(require("./typing-indexer"));
const linter_1 = __importDefault(require("./template/linter"));
const vscode_uri_1 = require("vscode-uri");
const constants_1 = require("./constants");
const utils_1 = require("@salesforce/lightning-lsp-common/lib/utils");
exports.propertyRegex = new RegExp(/\{(?<property>\w+)\.*.*\}/);
exports.iteratorRegex = new RegExp(/iterator:(?<name>\w+)/);
const { WorkspaceType } = lightning_lsp_common_1.shared;
var Token;
(function (Token) {
    Token["Tag"] = "tag";
    Token["AttributeKey"] = "attributeKey";
    Token["AttributeValue"] = "attributeValue";
    Token["DynamicAttributeValue"] = "dynamicAttributeValue";
    Token["Content"] = "content";
    Token["DynamicContent"] = "dynamicContent";
})(Token = exports.Token || (exports.Token = {}));
function findDynamicContent(text, offset) {
    const regex = new RegExp(/\{(?<property>\w+)\.*|\:*\w+\}/, 'g');
    let match = regex.exec(text);
    while (match && offset > match.index) {
        if (match.groups && match.groups.property && offset > match.index && regex.lastIndex > offset) {
            return match.groups.property;
        }
        match = regex.exec(text);
    }
    return null;
}
exports.findDynamicContent = findDynamicContent;
class Server {
    constructor() {
        this.connection = (0, vscode_languageserver_1.createConnection)();
        this.documents = new vscode_languageserver_1.TextDocuments();
        this.connection.onInitialize(this.onInitialize.bind(this));
        this.connection.onInitialized(this.onInitialized.bind(this));
        this.connection.onCompletion(this.onCompletion.bind(this));
        this.connection.onCompletionResolve(this.onCompletionResolve.bind(this));
        this.connection.onHover(this.onHover.bind(this));
        this.connection.onShutdown(this.onShutdown.bind(this));
        this.connection.onDefinition(this.onDefinition.bind(this));
        this.connection.onInitialized(this.onInitialized.bind(this));
        this.connection.onDidChangeWatchedFiles(this.onDidChangeWatchedFiles.bind(this));
        this.documents.listen(this.connection);
        this.documents.onDidChangeContent(this.onDidChangeContent.bind(this));
        this.documents.onDidSave(this.onDidSave.bind(this));
    }
    async onInitialize(params) {
        this.workspaceFolders = params.workspaceFolders;
        this.workspaceRoots = this.workspaceFolders.map(folder => vscode_uri_1.URI.parse(folder.uri).fsPath);
        this.context = new lightning_lsp_common_1.WorkspaceContext(this.workspaceRoots);
        this.componentIndexer = new component_indexer_1.default({ workspaceRoot: this.workspaceRoots[0] });
        this.lwcDataProvider = new lwc_data_provider_1.LWCDataProvider({ indexer: this.componentIndexer });
        this.auraDataProvider = new aura_data_provider_1.AuraDataProvider({ indexer: this.componentIndexer });
        this.typingIndexer = new typing_indexer_1.default({ workspaceRoot: this.workspaceRoots[0] });
        this.languageService = (0, vscode_html_languageservice_1.getLanguageService)({
            customDataProviders: [this.lwcDataProvider, this.auraDataProvider],
            useDefaultDataProvider: false,
        });
        await this.context.configureProject();
        await this.componentIndexer.init();
        this.typingIndexer.init();
        return this.capabilities;
    }
    get capabilities() {
        return {
            capabilities: {
                textDocumentSync: this.documents.syncKind,
                completionProvider: {
                    resolveProvider: true,
                    triggerCharacters: ['.', '-', '_', '<', '"', '=', '/', '>', '{'],
                },
                hoverProvider: true,
                definitionProvider: true,
                workspace: {
                    workspaceFolders: {
                        supported: true,
                    },
                },
            },
        };
    }
    async onInitialized() {
        const hasTsEnabled = await this.isTsSupportEnabled();
        if (hasTsEnabled) {
            await this.context.configureProjectForTs();
            this.componentIndexer.updateSfdxTsConfigPath();
        }
    }
    async isTsSupportEnabled() {
        return this.connection.workspace.getConfiguration(constants_1.TYPESCRIPT_SUPPORT_SETTING);
    }
    async onCompletion(params) {
        const { position, textDocument: { uri }, } = params;
        const doc = this.documents.get(uri);
        const htmlDoc = this.languageService.parseHTMLDocument(doc);
        if (await this.context.isLWCTemplate(doc)) {
            this.auraDataProvider.activated = false; // provide completions for lwc components in an Aura template
            this.lwcDataProvider.activated = true;
            if (this.shouldProvideBindingsInHTML(params)) {
                const docBasename = lightning_lsp_common_1.utils.getBasename(doc);
                const customTags = this.findBindItems(docBasename);
                return {
                    isIncomplete: false,
                    items: customTags,
                };
            }
        }
        else if (await this.context.isLWCJavascript(doc)) {
            if (this.shouldCompleteJavascript(params)) {
                const customTags = this.componentIndexer.customData.map(tag => {
                    return {
                        label: tag.lwcTypingsName,
                        kind: vscode_html_languageservice_1.CompletionItemKind.Folder,
                    };
                });
                return {
                    isIncomplete: false,
                    items: customTags,
                };
            }
            else {
                return;
            }
        }
        else if (await this.context.isAuraMarkup(doc)) {
            this.auraDataProvider.activated = true;
            this.lwcDataProvider.activated = false;
        }
        else {
            return;
        }
        return this.languageService.doComplete(doc, position, htmlDoc);
    }
    shouldProvideBindingsInHTML(params) {
        var _a;
        return ((_a = params.context) === null || _a === void 0 ? void 0 : _a.triggerCharacter) === '{' || this.isWithinCurlyBraces(params);
    }
    isWithinCurlyBraces(params) {
        const position = params.position;
        const doc = this.documents.get(params.textDocument.uri);
        const offset = doc.offsetAt(position);
        const text = doc.getText();
        let startIndex = offset - 1;
        let char = text.charAt(startIndex);
        const regPattern = /(\w|\$)/; // Valid variable names in JavaScript can contain letters, digits, underscore or $
        while (char.match(regPattern)) {
            startIndex -= 1;
            char = text.charAt(startIndex);
        }
        return char === '{';
    }
    shouldCompleteJavascript(params) {
        var _a;
        return ((_a = params.context) === null || _a === void 0 ? void 0 : _a.triggerCharacter) !== '{';
    }
    findBindItems(docBasename) {
        const customTags = [];
        this.componentIndexer.customData.forEach(t => {
            if (t.name === docBasename) {
                t.classMembers.forEach(cm => {
                    const bindName = `${t.name}.${cm.name}`;
                    const kind = cm.type === 'method' ? vscode_html_languageservice_1.CompletionItemKind.Function : vscode_html_languageservice_1.CompletionItemKind.Property;
                    const detail = cm.decorator ? `@${cm.decorator}` : '';
                    customTags.push({ label: cm.name, kind, documentation: bindName, detail, sortText: bindName });
                });
            }
        });
        return customTags;
    }
    onCompletionResolve(item) {
        return item;
    }
    async onHover(params) {
        const { position, textDocument: { uri }, } = params;
        const doc = this.documents.get(uri);
        const htmlDoc = this.languageService.parseHTMLDocument(doc);
        if (await this.context.isLWCTemplate(doc)) {
            this.auraDataProvider.activated = false;
            this.lwcDataProvider.activated = true;
        }
        else if (await this.context.isAuraMarkup(doc)) {
            this.auraDataProvider.activated = true;
            this.lwcDataProvider.activated = false;
        }
        else {
            return;
        }
        return this.languageService.doHover(doc, position, htmlDoc);
    }
    async onDidChangeContent(changeEvent) {
        const { document } = changeEvent;
        const { uri } = document;
        if (await this.context.isLWCTemplate(document)) {
            const diagnostics = (0, linter_1.default)(document);
            this.connection.sendDiagnostics({ uri, diagnostics });
        }
        if (await this.context.isLWCJavascript(document)) {
            const { metadata, diagnostics } = await (0, compiler_1.compileDocument)(document);
            this.connection.sendDiagnostics({ uri, diagnostics });
            if (metadata) {
                const tag = this.componentIndexer.findTagByURI(uri);
                if (tag) {
                    tag.updateMetadata(metadata);
                }
            }
        }
    }
    // TODO: Once the LWC custom module resolution plugin has been developed in the language server
    // this can be removed.
    async onDidChangeWatchedFiles(changeEvent) {
        if (this.context.type === WorkspaceType.SFDX) {
            try {
                const hasTsEnabled = await this.isTsSupportEnabled();
                if (hasTsEnabled) {
                    const { changes } = changeEvent;
                    if (lightning_lsp_common_1.utils.isLWCRootDirectoryCreated(this.context, changes)) {
                        // LWC directory created
                        this.context.updateNamespaceRootTypeCache();
                        this.componentIndexer.updateSfdxTsConfigPath();
                    }
                    else {
                        const hasDeleteEvent = await lightning_lsp_common_1.utils.containsDeletedLwcWatchedDirectory(this.context, changes);
                        if (hasDeleteEvent) {
                            // We need to scan the file system for deletion events as the change event does not include
                            // information about the files that were deleted.
                            this.componentIndexer.updateSfdxTsConfigPath();
                        }
                        else {
                            const filePaths = [];
                            for (const event of changes) {
                                const insideLwcWatchedDirectory = await (0, utils_1.isLWCWatchedDirectory)(this.context, event.uri);
                                if (event.type === vscode_languageserver_1.FileChangeType.Created && insideLwcWatchedDirectory) {
                                    // File creation
                                    const filePath = lightning_lsp_common_1.utils.toResolvedPath(event.uri);
                                    const { dir, name: fileName, ext } = (0, path_1.parse)(filePath);
                                    const folderName = (0, path_1.basename)(dir);
                                    const parentFolder = (0, path_1.basename)((0, path_1.dirname)(dir));
                                    // Only update path mapping for newly created lwc modules
                                    if (/.*(.ts|.js)$/.test(ext) && folderName === fileName && parentFolder === 'lwc') {
                                        filePaths.push(filePath);
                                    }
                                }
                            }
                            if (filePaths.length) {
                                this.componentIndexer.insertSfdxTsConfigPath(filePaths);
                            }
                        }
                    }
                }
            }
            catch (e) {
                this.connection.sendNotification(vscode_languageserver_1.ShowMessageNotification.type, {
                    type: vscode_languageserver_1.MessageType.Error,
                    message: `Error updating tsconfig.sfdx.json path mapping: ${e.message}`,
                });
            }
        }
    }
    async onDidSave(change) {
        const { document } = change;
        const { uri } = document;
        if (await this.context.isLWCJavascript(document)) {
            const doc = await (0, compiler_1.compileDocument)(document);
            const metadata = doc.metadata;
            if (metadata) {
                const tag = this.componentIndexer.findTagByURI(uri);
                if (tag) {
                    tag.updateMetadata(metadata);
                }
            }
        }
    }
    onShutdown() {
        this.componentIndexer.persistCustomComponents();
    }
    onExit() {
        this.componentIndexer.persistCustomComponents();
    }
    onDefinition(params) {
        const cursorInfo = this.cursorInfo(params);
        if (!cursorInfo) {
            return null;
        }
        const tag = this.componentIndexer.findTagByName(cursorInfo.tag);
        switch (cursorInfo.type) {
            case Token.Tag:
                return (tag === null || tag === void 0 ? void 0 : tag.allLocations) || [];
            case Token.AttributeKey:
                const attr = tag === null || tag === void 0 ? void 0 : tag.attribute(cursorInfo.name);
                if (attr) {
                    return [attr.location];
                }
            case Token.DynamicContent:
            case Token.DynamicAttributeValue:
                const { uri } = params.textDocument;
                if (cursorInfo.range) {
                    return [vscode_languageserver_1.Location.create(uri, cursorInfo.range)];
                }
                else {
                    const component = this.componentIndexer.findTagByURI(uri);
                    const location = component === null || component === void 0 ? void 0 : component.classMemberLocation(cursorInfo.name);
                    if (location) {
                        return [location];
                    }
                }
        }
        return [];
    }
    cursorInfo({ textDocument: { uri }, position }, document) {
        const doc = document || this.documents.get(uri);
        const offset = doc.offsetAt(position);
        const scanner = this.languageService.createScanner(doc.getText());
        let token;
        let tag;
        let attributeName;
        const iterators = [];
        do {
            token = scanner.scan();
            if (token === vscode_html_languageservice_1.TokenType.StartTag) {
                tag = scanner.getTokenText();
            }
            if (token === vscode_html_languageservice_1.TokenType.AttributeName) {
                attributeName = scanner.getTokenText();
                const iterator = exports.iteratorRegex.exec(attributeName);
                if (iterator) {
                    iterators.unshift({
                        name: iterator.groups.name,
                        range: {
                            start: doc.positionAt(scanner.getTokenOffset() + 9),
                            end: doc.positionAt(scanner.getTokenEnd()),
                        },
                    });
                }
            }
            if (token === vscode_html_languageservice_1.TokenType.AttributeValue && attributeName === 'for:item') {
                iterators.unshift({
                    name: scanner.getTokenText().replace(/"|'/g, ''),
                    range: {
                        start: doc.positionAt(scanner.getTokenOffset()),
                        end: doc.positionAt(scanner.getTokenEnd()),
                    },
                });
            }
        } while (token !== vscode_html_languageservice_1.TokenType.EOS && scanner.getTokenEnd() <= offset);
        const content = scanner.getTokenText();
        switch (token) {
            case vscode_html_languageservice_1.TokenType.StartTag:
            case vscode_html_languageservice_1.TokenType.EndTag: {
                return { type: Token.Tag, name: tag, tag };
            }
            case vscode_html_languageservice_1.TokenType.AttributeName: {
                return { type: Token.AttributeKey, tag, name: content };
            }
            case vscode_html_languageservice_1.TokenType.AttributeValue: {
                const match = exports.propertyRegex.exec(content);
                if (match) {
                    const item = iterators.find(i => i.name === match.groups.property) || null;
                    return {
                        type: Token.DynamicAttributeValue,
                        name: match.groups.property,
                        range: item === null || item === void 0 ? void 0 : item.range,
                        tag,
                    };
                }
                else {
                    return { type: Token.AttributeValue, name: content, tag };
                }
            }
            case vscode_html_languageservice_1.TokenType.Content: {
                const relativeOffset = offset - scanner.getTokenOffset();
                const match = findDynamicContent(content, relativeOffset);
                if (match) {
                    const item = iterators.find(i => i.name === match) || null;
                    return {
                        type: Token.DynamicContent,
                        name: match,
                        range: item === null || item === void 0 ? void 0 : item.range,
                        tag,
                    };
                }
                else {
                    return {
                        type: Token.Content,
                        tag,
                        name: content,
                    };
                }
            }
        }
        return null;
    }
    listen() {
        (0, lightning_lsp_common_1.interceptConsoleLogger)(this.connection);
        this.connection.listen();
    }
}
exports.default = Server;
//# sourceMappingURL=lwc-server.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractAttributes = exports.toVSCodeRange = exports.compileFile = exports.compileDocument = exports.compileSource = exports.extractMessageFromBabelError = exports.extractLocationFromBabelError = exports.getMethods = exports.getProperties = exports.getApiMethods = exports.getPrivateReactiveProperties = exports.getPublicReactiveProperties = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const constants_1 = require("../constants");
const metadata_1 = require("@lwc/metadata");
const compiler_1 = require("@lwc/compiler");
const type_mapping_1 = require("./type-mapping");
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const comment_parser_1 = __importDefault(require("comment-parser"));
function getClassMembers(metadata, memberType, memberDecorator) {
    const members = [];
    if (metadata.classMembers) {
        for (const member of metadata.classMembers) {
            if (member.type === memberType) {
                if (!memberDecorator || member.decorator === memberDecorator) {
                    members.push(member);
                }
            }
        }
    }
    return members;
}
function getDecoratorsTargets(metadata, elementType, targetType) {
    const props = [];
    if (metadata.decorators) {
        for (const element of metadata.decorators) {
            if (element.type === elementType) {
                for (const target of element.targets) {
                    if (target.type === targetType) {
                        props.push(target);
                    }
                }
                break;
            }
        }
    }
    return props;
}
function getPublicReactiveProperties(metadata) {
    return getClassMembers(metadata, 'property', 'api');
}
exports.getPublicReactiveProperties = getPublicReactiveProperties;
function getPrivateReactiveProperties(metadata) {
    return getDecoratorsTargets(metadata, 'track', 'property');
}
exports.getPrivateReactiveProperties = getPrivateReactiveProperties;
function getApiMethods(metadata) {
    return getDecoratorsTargets(metadata, 'api', 'method');
}
exports.getApiMethods = getApiMethods;
function getProperties(metadata) {
    return getClassMembers(metadata, 'property');
}
exports.getProperties = getProperties;
function getMethods(metadata) {
    return getClassMembers(metadata, 'method');
}
exports.getMethods = getMethods;
function sanitizeComment(comment) {
    const parsed = (0, comment_parser_1.default)('/*' + comment + '*/');
    return parsed && parsed.length > 0 ? parsed[0].source : null;
}
function patchComments(metadata) {
    if (metadata.doc) {
        metadata.doc = sanitizeComment(metadata.doc);
        for (const classMember of metadata.classMembers) {
            if (classMember.doc) {
                classMember.doc = sanitizeComment(classMember.doc);
            }
        }
    }
}
function extractLocationFromBabelError(message) {
    const m = message.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
    const startLine = m.indexOf('\n> ') + 3;
    const line = parseInt(m.substring(startLine, m.indexOf(' | ', startLine)), 10);
    const startColumn = m.indexOf('    | ', startLine);
    const mark = m.indexOf('^', startColumn);
    const column = mark - startColumn - 6;
    const location = { line, column };
    return location;
}
exports.extractLocationFromBabelError = extractLocationFromBabelError;
function extractMessageFromBabelError(message) {
    const start = message.indexOf(': ') + 2;
    const end = message.indexOf('\n', start);
    return message.substring(start, end);
}
exports.extractMessageFromBabelError = extractMessageFromBabelError;
// TODO: proper type for 'err' (i.e. SyntaxError)
function toDiagnostic(err) {
    // TODO: 'err' doesn't have end loc, squiggling until the end of the line until babel 7 is released
    const message = err.message;
    let location = err.location;
    if (!location) {
        location = extractLocationFromBabelError(message);
    }
    const startLine = location.line - 1;
    const startCharacter = location.column;
    // https://github.com/forcedotcom/salesforcedx-vscode/issues/2074
    // Limit the end character to max 32 bit integer so that it doesn't overflow other language servers
    const range = vscode_languageserver_1.Range.create(startLine, startCharacter, startLine, constants_1.MAX_32BIT_INTEGER);
    return {
        range,
        severity: vscode_languageserver_1.DiagnosticSeverity.Error,
        source: constants_1.DIAGNOSTIC_SOURCE,
        message: extractMessageFromBabelError(message),
    };
}
async function compileSource(source, fileName = 'foo.js') {
    const name = fileName.substring(0, fileName.lastIndexOf('.'));
    const transformOptions = {
        name,
        namespace: 'x',
    };
    try {
        (0, compiler_1.transformSync)(source, fileName, transformOptions);
    }
    catch (err) {
        return {
            diagnostics: [toDiagnostic(err)],
        };
    }
    const options = {
        type: 'platform',
        name,
        namespace: 'x',
        namespaceMapping: {},
        files: [
            {
                fileName,
                source,
            },
        ],
    };
    const modernMetadata = (0, metadata_1.collectBundleMetadata)(options);
    if (modernMetadata.diagnostics.length) {
        return {
            diagnostics: modernMetadata.diagnostics.map(toDiagnostic),
        };
    }
    const metadata = (0, type_mapping_1.mapLwcMetadataToInternal)(modernMetadata.files[0]);
    patchComments(metadata);
    return { metadata, diagnostics: [] };
}
exports.compileSource = compileSource;
/**
 * Use to compile a live document (contents may be different from current file in disk)
 */
async function compileDocument(document) {
    const file = vscode_uri_1.URI.file(document.uri).fsPath;
    const filePath = path.parse(file);
    const fileName = filePath.base;
    return compileSource(document.getText(), fileName);
}
exports.compileDocument = compileDocument;
async function compileFile(file) {
    const filePath = path.parse(file);
    const fileName = filePath.base;
    const data = await fs.readFile(file, 'utf-8');
    return compileSource(data, fileName);
}
exports.compileFile = compileFile;
function toVSCodeRange(babelRange) {
    // babel (column:0-based line:1-based) => vscode (character:0-based line:0-based)
    return vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(babelRange.start.line - 1, babelRange.start.column), vscode_languageserver_1.Position.create(babelRange.end.line - 1, babelRange.end.column));
}
exports.toVSCodeRange = toVSCodeRange;
function extractAttributes(metadata, uri) {
    const publicAttributes = [];
    const privateAttributes = [];
    for (const x of getProperties(metadata)) {
        if (x.decorator === 'api') {
            const location = vscode_languageserver_1.Location.create(uri, toVSCodeRange(x.loc));
            const name = x.name.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);
            const memberType = x.type === 'property' ? lightning_lsp_common_1.MemberType.PROPERTY : lightning_lsp_common_1.MemberType.METHOD;
            publicAttributes.push(new lightning_lsp_common_1.AttributeInfo(name, x.doc, memberType, lightning_lsp_common_1.Decorator.API, undefined, location, 'LWC custom attribute'));
        }
        else {
            const location = vscode_languageserver_1.Location.create(uri, toVSCodeRange(x.loc));
            const name = x.name.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);
            const memberType = x.type === 'property' ? lightning_lsp_common_1.MemberType.PROPERTY : lightning_lsp_common_1.MemberType.METHOD;
            const decorator = x.decorator === 'track' ? lightning_lsp_common_1.Decorator.TRACK : undefined;
            privateAttributes.push(new lightning_lsp_common_1.AttributeInfo(name, x.doc, memberType, decorator, undefined, location, 'LWC custom attribute'));
        }
    }
    return {
        publicAttributes,
        privateAttributes,
    };
}
exports.extractAttributes = extractAttributes;
//# sourceMappingURL=compiler.js.map
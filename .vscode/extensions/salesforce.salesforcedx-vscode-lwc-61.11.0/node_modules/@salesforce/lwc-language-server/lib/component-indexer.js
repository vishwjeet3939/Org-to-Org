"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureDirectoryExists = exports.unIndexedFiles = exports.tagEqualsFile = exports.DelimiterType = void 0;
const tag_1 = __importDefault(require("./tag"));
const path = __importStar(require("path"));
const lightning_lsp_common_1 = require("@salesforce/lightning-lsp-common");
const fast_glob_1 = require("fast-glob");
const normalize_path_1 = __importDefault(require("normalize-path"));
const fsExtra = __importStar(require("fs-extra"));
const fs = __importStar(require("fs"));
const change_case_1 = require("change-case");
const camelcase_1 = __importDefault(require("camelcase"));
const base_indexer_1 = __importDefault(require("./base-indexer"));
const { detectWorkspaceHelper, WorkspaceType } = lightning_lsp_common_1.shared;
const CUSTOM_COMPONENT_INDEX_PATH = path.join('.sfdx', 'indexes', 'lwc');
const CUSTOM_COMPONENT_INDEX_FILE = path.join(CUSTOM_COMPONENT_INDEX_PATH, 'custom-components.json');
const componentPrefixRegex = new RegExp(/^(?<type>c|lightning|interop){0,1}(?<delimiter>:|-{0,1})(?<name>[\w\-]+)$/);
var DelimiterType;
(function (DelimiterType) {
    DelimiterType["Aura"] = ":";
    DelimiterType["LWC"] = "-";
})(DelimiterType = exports.DelimiterType || (exports.DelimiterType = {}));
function tagEqualsFile(tag, entry) {
    var _a, _b;
    return tag.file === entry.path && ((_a = tag.updatedAt) === null || _a === void 0 ? void 0 : _a.getTime()) === ((_b = entry.stats) === null || _b === void 0 ? void 0 : _b.mtime.getTime());
}
exports.tagEqualsFile = tagEqualsFile;
function unIndexedFiles(entries, tags) {
    return entries.filter(entry => !tags.some(tag => tagEqualsFile(tag, entry)));
}
exports.unIndexedFiles = unIndexedFiles;
function ensureDirectoryExists(filePath) {
    if (fs.existsSync(filePath)) {
        return;
    }
    ensureDirectoryExists(path.dirname(filePath));
    fs.mkdirSync(filePath);
}
exports.ensureDirectoryExists = ensureDirectoryExists;
class ComponentIndexer extends base_indexer_1.default {
    constructor(attributes) {
        super(attributes);
        this.tags = new Map();
        this.workspaceType = detectWorkspaceHelper(attributes.workspaceRoot);
    }
    get componentEntries() {
        let files = [];
        switch (this.workspaceType) {
            case WorkspaceType.SFDX:
                const sfdxSource = (0, normalize_path_1.default)(`${this.workspaceRoot}/${this.sfdxPackageDirsPattern}/**/*/lwc/**/*.js`);
                files = (0, fast_glob_1.sync)(sfdxSource, {
                    stats: true,
                });
                return files.filter((item) => {
                    const data = path.parse(item.path);
                    return data.dir.endsWith(data.name);
                });
            default:
                // For CORE_ALL and CORE_PARTIAL
                const defaultSource = (0, normalize_path_1.default)(`${this.workspaceRoot}/**/*/modules/**/*.js`);
                files = (0, fast_glob_1.sync)(defaultSource, {
                    stats: true,
                });
                return files.filter((item) => {
                    const data = path.parse(item.path);
                    return data.dir.endsWith(data.name);
                });
        }
    }
    get customData() {
        return Array.from(this.tags.values());
    }
    findTagByName(query) {
        try {
            const matches = componentPrefixRegex.exec(query);
            const { delimiter, name } = matches === null || matches === void 0 ? void 0 : matches.groups;
            if (delimiter === DelimiterType.Aura && !/[-_]+/.test(name)) {
                return this.tags.get(name) || this.tags.get((0, change_case_1.snakeCase)(name)) || null;
            }
            else if (delimiter === DelimiterType.LWC) {
                return this.tags.get(name) || this.tags.get((0, camelcase_1.default)(name)) || null;
            }
            return this.tags.get(query) || null;
        }
        catch (err) {
            return null;
        }
    }
    findTagByURI(uri) {
        const uriText = uri.replace('.html', '.js');
        return Array.from(this.tags.values()).find(tag => tag.uri === uriText) || null;
    }
    loadTagsFromIndex() {
        try {
            const indexPath = path.join(this.workspaceRoot, CUSTOM_COMPONENT_INDEX_FILE);
            const shouldInit = fsExtra.existsSync(indexPath);
            if (shouldInit) {
                const indexJsonString = fsExtra.readFileSync(indexPath, 'utf8');
                const index = JSON.parse(indexJsonString);
                index.forEach(data => {
                    const info = new tag_1.default(data);
                    this.tags.set(info.name, info);
                });
            }
        }
        catch (err) {
            console.error(err);
        }
    }
    persistCustomComponents() {
        const indexPath = path.join(this.workspaceRoot, CUSTOM_COMPONENT_INDEX_FILE);
        ensureDirectoryExists(path.join(this.workspaceRoot, CUSTOM_COMPONENT_INDEX_PATH));
        const indexJsonString = JSON.stringify(this.customData);
        fsExtra.writeFileSync(indexPath, indexJsonString);
    }
    insertSfdxTsConfigPath(filePaths) {
        var _a;
        var _b;
        const sfdxTsConfigPath = (0, normalize_path_1.default)(`${this.workspaceRoot}/.sfdx/tsconfig.sfdx.json`);
        if (fs.existsSync(sfdxTsConfigPath)) {
            try {
                const sfdxTsConfig = lightning_lsp_common_1.utils.readJsonSync(sfdxTsConfigPath);
                for (const filePath of filePaths) {
                    const { dir, name: fileName } = path.parse(filePath);
                    const componentName = `c/${fileName}`;
                    const componentFilePath = path.join(dir, fileName);
                    const tsConfigFilePaths = ((_a = (_b = sfdxTsConfig.compilerOptions.paths)[componentName]) !== null && _a !== void 0 ? _a : (_b[componentName] = []));
                    const hasExistingPath = tsConfigFilePaths.some((existingPath) => existingPath === componentFilePath);
                    if (!hasExistingPath) {
                        tsConfigFilePaths.push(componentFilePath);
                    }
                }
                lightning_lsp_common_1.utils.writeJsonSync(sfdxTsConfigPath, sfdxTsConfig);
            }
            catch (err) {
                console.error(err);
            }
        }
    }
    // This is a temporary solution to enable automated LWC module resolution for TypeScript modules.
    // It is intended to update the path mapping in the .sfdx/tsconfig.sfdx.json file.
    // TODO: Once the LWC custom module resolution plugin has been developed in the language server
    // this can be removed.
    updateSfdxTsConfigPath() {
        const sfdxTsConfigPath = (0, normalize_path_1.default)(`${this.workspaceRoot}/.sfdx/tsconfig.sfdx.json`);
        if (fs.existsSync(sfdxTsConfigPath)) {
            try {
                const sfdxTsConfig = lightning_lsp_common_1.utils.readJsonSync(sfdxTsConfigPath);
                // The assumption here is that sfdxTsConfig will not be modified by the user as
                // it is located in the .sfdx directory.
                sfdxTsConfig.compilerOptions.paths = this.tsConfigPathMapping;
                lightning_lsp_common_1.utils.writeJsonSync(sfdxTsConfigPath, sfdxTsConfig);
            }
            catch (err) {
                console.error(err);
            }
        }
    }
    get tsConfigPathMapping() {
        var _a;
        const files = {};
        if (this.workspaceType === WorkspaceType.SFDX) {
            const sfdxSource = (0, normalize_path_1.default)(`${this.workspaceRoot}/${this.sfdxPackageDirsPattern}/**/*/lwc/*/*.{js,ts}`);
            const filePaths = (0, fast_glob_1.sync)(sfdxSource, { stats: true });
            for (const filePath of filePaths) {
                const { dir, name: fileName } = path.parse(filePath.path);
                const folderName = path.basename(dir);
                if (folderName === fileName) {
                    const componentName = `c/${fileName}`;
                    const componentFilePath = path.join(dir, fileName);
                    const tsConfigFilePaths = ((_a = files[componentName]) !== null && _a !== void 0 ? _a : (files[componentName] = []));
                    const hasExistingPath = tsConfigFilePaths.some((existingPath) => existingPath === componentFilePath);
                    if (!hasExistingPath) {
                        tsConfigFilePaths.push(componentFilePath);
                    }
                }
            }
        }
        return files;
    }
    get unIndexedFiles() {
        return unIndexedFiles(this.componentEntries, this.customData);
    }
    get staleTags() {
        const { componentEntries } = this;
        return this.customData.filter(tag => {
            return !componentEntries.some(entry => entry.path === tag.file);
        });
    }
    async init() {
        this.loadTagsFromIndex();
        const promises = this.unIndexedFiles.map(entry => tag_1.default.fromFile(entry.path, entry.stats.mtime));
        const tags = await Promise.all(promises);
        tags.filter(Boolean).forEach(tag => {
            this.tags.set(tag.name, tag);
        });
        this.staleTags.forEach(tag => this.tags.delete(tag.name));
        this.persistCustomComponents();
    }
    async reindex() {
        const promises = this.componentEntries.map(entry => tag_1.default.fromFile(entry.path));
        const tags = await Promise.all(promises);
        this.tags.clear();
        tags.forEach(tag => {
            this.tags.set(tag.name, tag);
        });
    }
}
exports.default = ComponentIndexer;
//# sourceMappingURL=component-indexer.js.map